diff -ruN ../apinger-0.6.1-patched/src/apinger.c ./src/apinger.c
--- ../apinger-0.6.1-patched/src/apinger.c	2014-01-06 10:07:04.809469506 -0200
+++ ./src/apinger.c	2014-01-06 16:50:04.070479934 -0200
@@ -340,7 +340,7 @@
 			logit("alarm canceled (config reload): %s(%s)  *** %s ***",t->description,t->name,a->name);
 	}
 
-	if (on < 0) {
+	if ((on < 0) || (t->config->force_down == 1)) {
 		return;
 	}
 
@@ -784,7 +784,9 @@
 			fprintf(f,"%0.1f%%",AVG_LOSS(t));
 		}
 		fprintf(f, "|");
-		if (t->active_alarms){
+		if (t->config->force_down == 1)
+			fprintf(f,"force_down");
+		else if (t->active_alarms){
 			for(al=t->active_alarms;al;al=al->next){
 				a=al->alarm;
 				fprintf(f,"%s",a->name);
diff -ruN ../apinger-0.6.1-patched/src/cfgparser1.c ./src/cfgparser1.c
--- ../apinger-0.6.1-patched/src/cfgparser1.c	2014-01-06 10:06:42.670168471 -0200
+++ ./src/cfgparser1.c	2014-01-06 11:33:47.543920154 -0200
@@ -1,10 +1,8 @@
+/* A Bison parser, made by GNU Bison 2.7.  */
 
-/* A Bison parser, made by GNU Bison 2.4.1.  */
-
-/* Skeleton implementation for Bison's Yacc-like parsers in C
+/* Bison implementation for Yacc-like parsers in C
    
-      Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
-   Free Software Foundation, Inc.
+      Copyright (C) 1984, 1989-1990, 2000-2012 Free Software Foundation, Inc.
    
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -46,7 +44,7 @@
 #define YYBISON 1
 
 /* Bison version.  */
-#define YYBISON_VERSION "2.4.1"
+#define YYBISON_VERSION "2.7"
 
 /* Skeleton name.  */
 #define YYSKELETON_NAME "yacc.c"
@@ -60,14 +58,11 @@
 /* Pull parsers.  */
 #define YYPULL 1
 
-/* Using locations.  */
-#define YYLSP_NEEDED 1
 
 
 
 /* Copy the first part of user declarations.  */
-
-/* Line 189 of yacc.c  */
+/* Line 371 of yacc.c  */
 #line 22 "cfgparser1.y"
 
 
@@ -94,14 +89,16 @@
 
 
 
+/* Line 371 of yacc.c  */
+#line 94 "y.tab.c"
 
-/* Line 189 of yacc.c  */
-#line 100 "cfgparser1.tab.c"
-
-/* Enabling traces.  */
-#ifndef YYDEBUG
-# define YYDEBUG 0
-#endif
+# ifndef YY_NULL
+#  if defined __cplusplus && 201103L <= __cplusplus
+#   define YY_NULL nullptr
+#  else
+#   define YY_NULL 0
+#  endif
+# endif
 
 /* Enabling verbose error messages.  */
 #ifdef YYERROR_VERBOSE
@@ -111,11 +108,17 @@
 # define YYERROR_VERBOSE 0
 #endif
 
-/* Enabling the token table.  */
-#ifndef YYTOKEN_TABLE
-# define YYTOKEN_TABLE 0
+/* In a future release of Bison, this section will be replaced
+   by #include "y.tab.h".  */
+#ifndef YY_YY_Y_TAB_H_INCLUDED
+# define YY_YY_Y_TAB_H_INCLUDED
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+#if YYDEBUG
+extern int yydebug;
 #endif
-
 
 /* Tokens.  */
 #ifndef YYTOKENTYPE
@@ -157,28 +160,76 @@
      DESCRIPTION = 289,
      SRCIP = 290,
      ALARMS = 291,
-     INTERVAL = 292,
-     AVG_DELAY_SAMPLES = 293,
-     AVG_LOSS_SAMPLES = 294,
-     AVG_LOSS_DELAY_SAMPLES = 295,
-     FILE_ = 296,
-     ERROR = 297,
-     ON = 298,
-     OFF = 299,
-     YES = 300,
-     NO = 301,
-     TRUE = 302,
-     FALSE = 303
+     FORCE_DOWN = 292,
+     INTERVAL = 293,
+     AVG_DELAY_SAMPLES = 294,
+     AVG_LOSS_SAMPLES = 295,
+     AVG_LOSS_DELAY_SAMPLES = 296,
+     FILE_ = 297,
+     ERROR = 298,
+     ON = 299,
+     OFF = 300,
+     YES = 301,
+     NO = 302,
+     TRUE = 303,
+     FALSE = 304
    };
 #endif
+/* Tokens.  */
+#define TIME 258
+#define INTEGER 259
+#define STRING 260
+#define DEBUG 261
+#define USER 262
+#define GROUP 263
+#define PID_FILE 264
+#define MAILER 265
+#define TIMESTAMP_FORMAT 266
+#define RRD 267
+#define STATUS 268
+#define ALARM 269
+#define TARGET 270
+#define OVERRIDE 271
+#define DEFAULT 272
+#define MAILTO 273
+#define MAILFROM 274
+#define MAILENVFROM 275
+#define MAILSUBJECT 276
+#define COMMAND 277
+#define PIPE 278
+#define COMBINE 279
+#define REPEAT 280
+#define DOWN 281
+#define LOSS 282
+#define DELAY 283
+#define TIME_ 284
+#define PERCENT_LOW 285
+#define PERCENT_HIGH 286
+#define DELAY_LOW 287
+#define DELAY_HIGH 288
+#define DESCRIPTION 289
+#define SRCIP 290
+#define ALARMS 291
+#define FORCE_DOWN 292
+#define INTERVAL 293
+#define AVG_DELAY_SAMPLES 294
+#define AVG_LOSS_SAMPLES 295
+#define AVG_LOSS_DELAY_SAMPLES 296
+#define FILE_ 297
+#define ERROR 298
+#define ON 299
+#define OFF 300
+#define YES 301
+#define NO 302
+#define TRUE 303
+#define FALSE 304
 
 
 
 #if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
 typedef union YYSTYPE
 {
-
-/* Line 214 of yacc.c  */
+/* Line 387 of yacc.c  */
 #line 51 "cfgparser1.y"
 
 	int i;
@@ -189,9 +240,8 @@
 	struct alarm_list *al;
 
 
-
-/* Line 214 of yacc.c  */
-#line 195 "cfgparser1.tab.c"
+/* Line 387 of yacc.c  */
+#line 245 "y.tab.c"
 } YYSTYPE;
 # define YYSTYPE_IS_TRIVIAL 1
 # define yystype YYSTYPE /* obsolescent; will be withdrawn */
@@ -211,12 +261,28 @@
 # define YYLTYPE_IS_TRIVIAL 1
 #endif
 
+extern YYSTYPE yylval;
+extern YYLTYPE yylloc;
+#ifdef YYPARSE_PARAM
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void *YYPARSE_PARAM);
+#else
+int yyparse ();
+#endif
+#else /* ! YYPARSE_PARAM */
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void);
+#else
+int yyparse ();
+#endif
+#endif /* ! YYPARSE_PARAM */
+
+#endif /* !YY_YY_Y_TAB_H_INCLUDED  */
 
 /* Copy the second part of user declarations.  */
 
-
-/* Line 264 of yacc.c  */
-#line 220 "cfgparser1.tab.c"
+/* Line 390 of yacc.c  */
+#line 286 "y.tab.c"
 
 #ifdef short
 # undef short
@@ -266,27 +332,27 @@
 #define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
 
 #ifndef YY_
-# if YYENABLE_NLS
+# if defined YYENABLE_NLS && YYENABLE_NLS
 #  if ENABLE_NLS
 #   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
-#   define YY_(msgid) dgettext ("bison-runtime", msgid)
+#   define YY_(Msgid) dgettext ("bison-runtime", Msgid)
 #  endif
 # endif
 # ifndef YY_
-#  define YY_(msgid) msgid
+#  define YY_(Msgid) Msgid
 # endif
 #endif
 
 /* Suppress unused-variable warnings by "using" E.  */
 #if ! defined lint || defined __GNUC__
-# define YYUSE(e) ((void) (e))
+# define YYUSE(E) ((void) (E))
 #else
-# define YYUSE(e) /* empty */
+# define YYUSE(E) /* empty */
 #endif
 
 /* Identity function, used to suppress warnings about constant conditions.  */
 #ifndef lint
-# define YYID(n) (n)
+# define YYID(N) (N)
 #else
 #if (defined __STDC__ || defined __C99__FUNC__ \
      || defined __cplusplus || defined _MSC_VER)
@@ -319,11 +385,12 @@
 #    define alloca _alloca
 #   else
 #    define YYSTACK_ALLOC alloca
-#    if ! defined _ALLOCA_H && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS && (defined __STDC__ || defined __C99__FUNC__ \
      || defined __cplusplus || defined _MSC_VER)
 #     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
-#     ifndef _STDLIB_H
-#      define _STDLIB_H 1
+      /* Use EXIT_SUCCESS as a witness for stdlib.h.  */
+#     ifndef EXIT_SUCCESS
+#      define EXIT_SUCCESS 0
 #     endif
 #    endif
 #   endif
@@ -346,24 +413,24 @@
 #  ifndef YYSTACK_ALLOC_MAXIMUM
 #   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
 #  endif
-#  if (defined __cplusplus && ! defined _STDLIB_H \
+#  if (defined __cplusplus && ! defined EXIT_SUCCESS \
        && ! ((defined YYMALLOC || defined malloc) \
 	     && (defined YYFREE || defined free)))
 #   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
-#   ifndef _STDLIB_H
-#    define _STDLIB_H 1
+#   ifndef EXIT_SUCCESS
+#    define EXIT_SUCCESS 0
 #   endif
 #  endif
 #  ifndef YYMALLOC
 #   define YYMALLOC malloc
-#   if ! defined malloc && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+#   if ! defined malloc && ! defined EXIT_SUCCESS && (defined __STDC__ || defined __C99__FUNC__ \
      || defined __cplusplus || defined _MSC_VER)
 void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
 #   endif
 #  endif
 #  ifndef YYFREE
 #   define YYFREE free
-#   if ! defined free && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+#   if ! defined free && ! defined EXIT_SUCCESS && (defined __STDC__ || defined __C99__FUNC__ \
      || defined __cplusplus || defined _MSC_VER)
 void free (void *); /* INFRINGES ON USER NAME SPACE */
 #   endif
@@ -394,23 +461,7 @@
      ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE) + sizeof (YYLTYPE)) \
       + 2 * YYSTACK_GAP_MAXIMUM)
 
-/* Copy COUNT objects from FROM to TO.  The source and destination do
-   not overlap.  */
-# ifndef YYCOPY
-#  if defined __GNUC__ && 1 < __GNUC__
-#   define YYCOPY(To, From, Count) \
-      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
-#  else
-#   define YYCOPY(To, From, Count)		\
-      do					\
-	{					\
-	  YYSIZE_T yyi;				\
-	  for (yyi = 0; yyi < (Count); yyi++)	\
-	    (To)[yyi] = (From)[yyi];		\
-	}					\
-      while (YYID (0))
-#  endif
-# endif
+# define YYCOPY_NEEDED 1
 
 /* Relocate STACK from its old location to the new one.  The
    local variables YYSIZE and YYSTACKSIZE give the old and new number of
@@ -430,23 +481,43 @@
 
 #endif
 
+#if defined YYCOPY_NEEDED && YYCOPY_NEEDED
+/* Copy COUNT objects from SRC to DST.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined __GNUC__ && 1 < __GNUC__
+#   define YYCOPY(Dst, Src, Count) \
+      __builtin_memcpy (Dst, Src, (Count) * sizeof (*(Src)))
+#  else
+#   define YYCOPY(Dst, Src, Count)              \
+      do                                        \
+        {                                       \
+          YYSIZE_T yyi;                         \
+          for (yyi = 0; yyi < (Count); yyi++)   \
+            (Dst)[yyi] = (Src)[yyi];            \
+        }                                       \
+      while (YYID (0))
+#  endif
+# endif
+#endif /* !YYCOPY_NEEDED */
+
 /* YYFINAL -- State number of the termination state.  */
 #define YYFINAL  34
 /* YYLAST -- Last index in YYTABLE.  */
-#define YYLAST   186
+#define YYLAST   187
 
 /* YYNTOKENS -- Number of terminals.  */
-#define YYNTOKENS  54
+#define YYNTOKENS  55
 /* YYNNTS -- Number of nonterminals.  */
 #define YYNNTS  19
 /* YYNRULES -- Number of rules.  */
-#define YYNRULES  79
+#define YYNRULES  80
 /* YYNRULES -- Number of states.  */
-#define YYNSTATES  148
+#define YYNSTATES  150
 
 /* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
 #define YYUNDEFTOK  2
-#define YYMAXUTOK   303
+#define YYMAXUTOK   304
 
 #define YYTRANSLATE(YYX)						\
   ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
@@ -455,18 +526,18 @@
 static const yytype_uint8 yytranslate[] =
 {
        0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-      52,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+      53,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,    51,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,    53,
+       2,     2,     2,     2,    52,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,    54,
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,    49,     2,    50,     2,     2,     2,     2,
+       2,     2,     2,    50,     2,    51,     2,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
@@ -484,7 +555,7 @@
       15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
       25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
       35,    36,    37,    38,    39,    40,    41,    42,    43,    44,
-      45,    46,    47,    48
+      45,    46,    47,    48,    49
 };
 
 #if YYDEBUG
@@ -498,55 +569,58 @@
       96,    99,   102,   106,   108,   111,   115,   116,   119,   122,
      125,   128,   131,   135,   139,   142,   146,   150,   153,   157,
      160,   167,   174,   175,   178,   181,   184,   188,   191,   194,
-     197,   200,   203,   207,   211,   213,   217,   218,   221,   224,
-     227,   231,   233,   235,   237,   239,   241,   243,   245,   247
+     197,   200,   203,   206,   210,   214,   216,   220,   221,   224,
+     227,   230,   234,   236,   238,   240,   242,   244,   246,   248,
+     250
 };
 
 /* YYRHS -- A `-1'-separated list of the rules' RHS.  */
 static const yytype_int8 yyrhs[] =
 {
-      55,     0,    -1,    -1,     6,    71,    -1,     7,    70,    -1,
-       8,    70,    -1,    10,    70,    -1,    11,    70,    -1,     9,
-      70,    -1,    13,    49,    69,    50,    -1,    12,    37,     3,
-      -1,    60,    -1,    66,    -1,    55,    72,    55,    -1,     1,
-      -1,    -1,    -1,    -1,    -1,    14,    58,    17,    49,    61,
-      50,    -1,    14,    56,    26,    70,    49,    64,    50,    -1,
-      14,    56,    27,    70,    49,    62,    50,    -1,    14,    56,
-      28,    70,    49,    63,    50,    -1,    65,    -1,    61,    72,
-      61,    -1,    65,    -1,    30,     4,    -1,    31,     4,    -1,
-      62,    72,    62,    -1,    65,    -1,    32,     3,    -1,    33,
-       3,    -1,    63,    72,    63,    -1,    65,    -1,    29,     3,
-      -1,    64,    72,    64,    -1,    -1,    18,    70,    -1,    19,
-      70,    -1,    20,    70,    -1,    21,    70,    -1,    22,    70,
-      -1,    22,    43,    70,    -1,    22,    44,    70,    -1,    23,
-      70,    -1,    23,    43,    70,    -1,    23,    44,    70,    -1,
+      56,     0,    -1,    -1,     6,    72,    -1,     7,    71,    -1,
+       8,    71,    -1,    10,    71,    -1,    11,    71,    -1,     9,
+      71,    -1,    13,    50,    70,    51,    -1,    12,    38,     3,
+      -1,    61,    -1,    67,    -1,    56,    73,    56,    -1,     1,
+      -1,    -1,    -1,    -1,    -1,    14,    59,    17,    50,    62,
+      51,    -1,    14,    57,    26,    71,    50,    65,    51,    -1,
+      14,    57,    27,    71,    50,    63,    51,    -1,    14,    57,
+      28,    71,    50,    64,    51,    -1,    66,    -1,    62,    73,
+      62,    -1,    66,    -1,    30,     4,    -1,    31,     4,    -1,
+      63,    73,    63,    -1,    66,    -1,    32,     3,    -1,    33,
+       3,    -1,    64,    73,    64,    -1,    66,    -1,    29,     3,
+      -1,    65,    73,    65,    -1,    -1,    18,    71,    -1,    19,
+      71,    -1,    20,    71,    -1,    21,    71,    -1,    22,    71,
+      -1,    22,    44,    71,    -1,    22,    45,    71,    -1,    23,
+      71,    -1,    23,    44,    71,    -1,    23,    45,    71,    -1,
       24,     3,    -1,    25,     3,     4,    -1,    25,     3,    -1,
-      15,    59,    17,    49,    67,    50,    -1,    15,    57,    70,
-      49,    67,    50,    -1,    -1,    34,    70,    -1,    35,    70,
-      -1,    36,    68,    -1,    36,    16,    68,    -1,    37,     4,
-      -1,    37,     3,    -1,    38,     4,    -1,    39,     4,    -1,
-      40,     4,    -1,    12,    41,     5,    -1,    67,    72,    67,
-      -1,    70,    -1,    68,    51,    70,    -1,    -1,    41,    70,
-      -1,    37,     4,    -1,    37,     3,    -1,    69,    72,    69,
-      -1,     5,    -1,    43,    -1,    44,    -1,    45,    -1,    46,
-      -1,    47,    -1,    48,    -1,    52,    -1,    53,    -1
+      15,    60,    17,    50,    68,    51,    -1,    15,    58,    71,
+      50,    68,    51,    -1,    -1,    34,    71,    -1,    35,    71,
+      -1,    36,    69,    -1,    36,    16,    69,    -1,    37,    72,
+      -1,    38,     4,    -1,    38,     3,    -1,    39,     4,    -1,
+      40,     4,    -1,    41,     4,    -1,    12,    42,     5,    -1,
+      68,    73,    68,    -1,    71,    -1,    69,    52,    71,    -1,
+      -1,    42,    71,    -1,    38,     4,    -1,    38,     3,    -1,
+      70,    73,    70,    -1,     5,    -1,    44,    -1,    45,    -1,
+      46,    -1,    47,    -1,    48,    -1,    49,    -1,    53,    -1,
+      54,    -1
 };
 
 /* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
 static const yytype_uint16 yyrline[] =
 {
-       0,   123,   123,   124,   125,   126,   127,   128,   129,   130,
-     131,   132,   133,   134,   135,   143,   146,   149,   155,   161,
-     162,   167,   172,   179,   180,   183,   184,   186,   188,   191,
-     192,   194,   196,   199,   200,   202,   205,   206,   208,   210,
-     212,   214,   219,   221,   223,   228,   230,   232,   234,   236,
-     241,   242,   249,   250,   252,   254,   256,   258,   260,   262,
-     264,   266,   268,   270,   273,   275,   279,   280,   282,   284,
-     286,   290,   293,   294,   295,   296,   297,   298,   301,   302
+       0,   124,   124,   125,   126,   127,   128,   129,   130,   131,
+     132,   133,   134,   135,   136,   144,   147,   150,   156,   162,
+     163,   168,   173,   180,   181,   184,   185,   187,   189,   192,
+     193,   195,   197,   200,   201,   203,   206,   207,   209,   211,
+     213,   215,   220,   222,   224,   229,   231,   233,   235,   237,
+     242,   243,   250,   251,   253,   255,   257,   259,   261,   263,
+     265,   267,   269,   271,   273,   276,   278,   282,   283,   285,
+     287,   289,   293,   296,   297,   298,   299,   300,   301,   304,
+     305
 };
 #endif
 
-#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+#if YYDEBUG || YYERROR_VERBOSE || 0
 /* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
    First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
 static const char *const yytname[] =
@@ -556,13 +630,14 @@
   "STATUS", "ALARM", "TARGET", "OVERRIDE", "DEFAULT", "MAILTO", "MAILFROM",
   "MAILENVFROM", "MAILSUBJECT", "COMMAND", "PIPE", "COMBINE", "REPEAT",
   "DOWN", "LOSS", "DELAY", "TIME_", "PERCENT_LOW", "PERCENT_HIGH",
-  "DELAY_LOW", "DELAY_HIGH", "DESCRIPTION", "SRCIP", "ALARMS", "INTERVAL",
-  "AVG_DELAY_SAMPLES", "AVG_LOSS_SAMPLES", "AVG_LOSS_DELAY_SAMPLES",
-  "FILE_", "ERROR", "ON", "OFF", "YES", "NO", "TRUE", "FALSE", "'{'",
-  "'}'", "','", "'\\n'", "';'", "$accept", "config", "makealarm",
-  "maketarget", "getdefalarm", "getdeftarget", "alarm", "alarmcommoncfg",
-  "alarmlosscfg", "alarmdelaycfg", "alarmdowncfg", "alarmcommon", "target",
-  "targetcfg", "alarmlist", "statuscfg", "string", "boolean", "separator", 0
+  "DELAY_LOW", "DELAY_HIGH", "DESCRIPTION", "SRCIP", "ALARMS",
+  "FORCE_DOWN", "INTERVAL", "AVG_DELAY_SAMPLES", "AVG_LOSS_SAMPLES",
+  "AVG_LOSS_DELAY_SAMPLES", "FILE_", "ERROR", "ON", "OFF", "YES", "NO",
+  "TRUE", "FALSE", "'{'", "'}'", "','", "'\\n'", "';'", "$accept",
+  "config", "makealarm", "maketarget", "getdefalarm", "getdeftarget",
+  "alarm", "alarmcommoncfg", "alarmlosscfg", "alarmdelaycfg",
+  "alarmdowncfg", "alarmcommon", "target", "targetcfg", "alarmlist",
+  "statuscfg", "string", "boolean", "separator", YY_NULL
 };
 #endif
 
@@ -575,22 +650,23 @@
      265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
      275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
      285,   286,   287,   288,   289,   290,   291,   292,   293,   294,
-     295,   296,   297,   298,   299,   300,   301,   302,   303,   123,
-     125,    44,    10,    59
+     295,   296,   297,   298,   299,   300,   301,   302,   303,   304,
+     123,   125,    44,    10,    59
 };
 # endif
 
 /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
 static const yytype_uint8 yyr1[] =
 {
-       0,    54,    55,    55,    55,    55,    55,    55,    55,    55,
-      55,    55,    55,    55,    55,    56,    57,    58,    59,    60,
-      60,    60,    60,    61,    61,    62,    62,    62,    62,    63,
-      63,    63,    63,    64,    64,    64,    65,    65,    65,    65,
-      65,    65,    65,    65,    65,    65,    65,    65,    65,    65,
-      66,    66,    67,    67,    67,    67,    67,    67,    67,    67,
-      67,    67,    67,    67,    68,    68,    69,    69,    69,    69,
-      69,    70,    71,    71,    71,    71,    71,    71,    72,    72
+       0,    55,    56,    56,    56,    56,    56,    56,    56,    56,
+      56,    56,    56,    56,    56,    57,    58,    59,    60,    61,
+      61,    61,    61,    62,    62,    63,    63,    63,    63,    64,
+      64,    64,    64,    65,    65,    65,    66,    66,    66,    66,
+      66,    66,    66,    66,    66,    66,    66,    66,    66,    66,
+      67,    67,    68,    68,    68,    68,    68,    68,    68,    68,
+      68,    68,    68,    68,    68,    69,    69,    70,    70,    70,
+      70,    70,    71,    72,    72,    72,    72,    72,    72,    73,
+      73
 };
 
 /* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
@@ -602,117 +678,123 @@
        2,     2,     3,     1,     2,     3,     0,     2,     2,     2,
        2,     2,     3,     3,     2,     3,     3,     2,     3,     2,
        6,     6,     0,     2,     2,     2,     3,     2,     2,     2,
-       2,     2,     3,     3,     1,     3,     0,     2,     2,     2,
-       3,     1,     1,     1,     1,     1,     1,     1,     1,     1
+       2,     2,     2,     3,     3,     1,     3,     0,     2,     2,
+       2,     3,     1,     1,     1,     1,     1,     1,     1,     1,
+       1
 };
 
-/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
-   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
+/* YYDEFACT[STATE-NAME] -- Default reduction number in state STATE-NUM.
+   Performed when YYTABLE doesn't specify something else to do.  Zero
    means the default is an error.  */
 static const yytype_uint8 yydefact[] =
 {
        0,    14,     0,     0,     0,     0,     0,     0,     0,     0,
-      15,    16,     0,    11,    12,    72,    73,    74,    75,    76,
-      77,     3,    71,     4,     5,     8,     6,     7,     0,    66,
-       0,     0,     0,     0,     1,    78,    79,     0,    10,     0,
-       0,     0,     0,     0,     0,     0,     0,     0,    13,    69,
-      68,    67,     9,    66,     0,     0,     0,    36,    52,    52,
-      70,    36,    36,    36,     0,     0,     0,     0,     0,     0,
+      15,    16,     0,    11,    12,    73,    74,    75,    76,    77,
+      78,     3,    72,     4,     5,     8,     6,     7,     0,    67,
+       0,     0,     0,     0,     1,    79,    80,     0,    10,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,    13,    70,
+      69,    68,     9,    67,     0,     0,     0,    36,    52,    52,
+      71,    36,    36,    36,     0,     0,     0,     0,     0,     0,
        0,     0,     0,    23,     0,     0,     0,     0,     0,     0,
-       0,     0,     0,     0,     0,     0,    33,     0,     0,     0,
-      25,     0,     0,     0,    29,    37,    38,    39,    40,     0,
-       0,    41,     0,     0,    44,    47,    49,    19,    36,     0,
-      53,    54,     0,    55,    64,    58,    57,    59,    60,    61,
-      51,    52,    50,    34,    20,    36,    26,    27,    21,    36,
-      30,    31,    22,    36,    42,    43,    45,    46,    48,    24,
-      62,    56,     0,    63,    35,    28,    32,    65
+       0,     0,     0,     0,     0,     0,     0,    33,     0,     0,
+       0,    25,     0,     0,     0,    29,    37,    38,    39,    40,
+       0,     0,    41,     0,     0,    44,    47,    49,    19,    36,
+       0,    53,    54,     0,    55,    65,    57,    59,    58,    60,
+      61,    62,    51,    52,    50,    34,    20,    36,    26,    27,
+      21,    36,    30,    31,    22,    36,    42,    43,    45,    46,
+      48,    24,    63,    56,     0,    64,    35,    28,    32,    66
 };
 
 /* YYDEFGOTO[NTERM-NUM].  */
 static const yytype_int8 yydefgoto[] =
 {
-      -1,    12,    30,    32,    31,    33,    13,    72,    89,    93,
-      85,    73,    14,    82,   113,    41,   114,    21,   121
+      -1,    12,    30,    32,    31,    33,    13,    72,    90,    94,
+      86,    73,    14,    83,   114,    41,   115,    21,   123
 };
 
 /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
    STATE-NUM.  */
-#define YYPACT_NINF -56
+#define YYPACT_NINF -57
 static const yytype_int16 yypact[] =
 {
-      76,   -56,   -29,     5,     5,     5,     5,     5,   -25,   -16,
-      19,    21,    27,   -56,   -56,   -56,   -56,   -56,   -56,   -56,
-     -56,   -56,   -56,   -56,   -56,   -56,   -56,   -56,    40,   -17,
-      32,    29,     5,    37,   -56,   -56,   -56,    76,   -56,   108,
-       5,   -27,     5,     5,     5,     0,    22,    26,    73,   -56,
-     -56,   -56,   -56,   -17,    44,    46,    52,    85,    80,    80,
-      73,   152,   138,   112,     5,     5,     5,     5,     4,     8,
-      65,   110,   -22,   -56,    81,     5,     5,     6,   139,   123,
-     142,   143,   -18,    -8,   146,     3,   -56,   147,   148,    71,
-     -56,   161,   162,    88,   -56,   -56,   -56,   -56,   -56,     5,
-       5,   -56,     5,     5,   -56,   -56,   163,   -56,    85,   145,
-     -56,   -56,     5,   115,   -56,   -56,   -56,   -56,   -56,   -56,
-     -56,    80,   -56,   -56,   -56,   152,   -56,   -56,   -56,   138,
-     -56,   -56,   -56,   112,   -56,   -56,   -56,   -56,   -56,    73,
-     -56,   115,     5,    73,    73,    73,    73,   -56
+      76,   -57,   -22,     8,     8,     8,     8,     8,   -21,   -17,
+      19,    21,    14,   -57,   -57,   -57,   -57,   -57,   -57,   -57,
+     -57,   -57,   -57,   -57,   -57,   -57,   -57,   -57,    40,   -27,
+      32,    29,     8,    37,   -57,   -57,   -57,    76,   -57,    90,
+       8,   -35,     8,     8,     8,    -1,    20,    28,    59,   -57,
+     -57,   -57,   -57,   -27,    30,    46,    52,    86,    80,    80,
+      59,   154,   140,   113,     8,     8,     8,     8,     3,     7,
+     120,   125,   -23,   -57,    97,     8,     8,     4,   -22,   123,
+     143,   144,   145,   -19,    -9,   141,     2,   -57,   147,   148,
+      71,   -57,   150,   151,    89,   -57,   -57,   -57,   -57,   -57,
+       8,     8,   -57,     8,     8,   -57,   -57,   162,   -57,    86,
+     163,   -57,   -57,     8,   115,   -57,   -57,   -57,   -57,   -57,
+     -57,   -57,   -57,    80,   -57,   -57,   -57,   154,   -57,   -57,
+     -57,   140,   -57,   -57,   -57,   113,   -57,   -57,   -57,   -57,
+     -57,    59,   -57,   115,     8,    59,    59,    59,    59,   -57
 };
 
 /* YYPGOTO[NTERM-NUM].  */
 static const yytype_int16 yypgoto[] =
 {
-     -56,   141,   -56,   -56,   -56,   -56,   -56,    72,    50,    49,
-      58,   -55,   -56,   -54,    74,   131,    -3,   -56,     9
+     -57,   132,   -57,   -57,   -57,   -57,   -57,    72,    49,    47,
+      57,   -56,   -57,   -49,    73,   134,    -3,   107,     9
 };
 
 /* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
    positive, shift that token.  If negative, reduce the rule which
-   number is the opposite.  If zero, do what YYDEFACT says.
-   If YYTABLE_NINF, syntax error.  */
+   number is the opposite.  If YYTABLE_NINF, syntax error.  */
 #define YYTABLE_NINF -19
 static const yytype_int16 yytable[] =
 {
-      23,    24,    25,    26,    27,    83,    86,    90,    94,    22,
-      22,    22,    28,    22,    15,    16,    17,    18,    19,    20,
-      39,    37,   112,    52,    40,    35,    36,    34,   107,    46,
-      35,    36,   120,    29,    35,    36,   -17,    51,   -18,    54,
-      55,    56,   122,    38,    35,    36,    45,    99,   100,    57,
-      53,   102,   103,   124,    47,    35,    36,    37,    42,    43,
-      44,    95,    96,    97,    98,   101,   104,   143,   105,    53,
-      86,    58,   110,   111,    90,    59,    -2,     1,    94,    35,
-      36,   108,     2,     3,     4,     5,     6,     7,     8,     9,
-      10,    11,    74,    61,   125,    62,   134,   135,   129,   136,
-     137,    63,   133,    64,    65,    66,    67,    68,    69,    70,
-      71,    49,    50,   106,    75,    76,    77,    78,    79,    80,
-      81,   128,   109,    35,    36,    35,    36,   117,    -2,    -2,
-      64,    65,    66,    67,    68,    69,    70,    71,   132,   147,
-      35,    36,   115,   116,    91,    92,   118,   119,   108,   123,
-     140,   126,   127,   125,   129,   133,    64,    65,    66,    67,
-      68,    69,    70,    71,   130,   131,   142,   138,    87,    88,
-      64,    65,    66,    67,    68,    69,    70,    71,    48,   145,
-     139,    84,   146,   144,    60,     0,   141
+      23,    24,    25,    26,    27,    87,    91,    95,    22,    22,
+      84,    39,    22,    22,    34,    40,    52,    28,    35,    36,
+     113,    37,    15,    16,    17,    18,    19,    20,   108,    46,
+      35,    36,   122,    29,    35,    36,   -17,    51,   -18,    54,
+      55,    56,   124,    38,    35,    36,    45,   100,   101,    57,
+      53,   103,   104,   126,    47,    35,    36,    37,    42,    43,
+      44,    96,    97,    98,    99,   102,   105,    35,    36,    53,
+      58,    87,   111,   112,   145,    91,    -2,     1,    59,    95,
+      61,   109,     2,     3,     4,     5,     6,     7,     8,     9,
+      10,    11,    74,    49,    50,   127,    62,   136,   137,   131,
+     138,   139,    63,   135,    64,    65,    66,    67,    68,    69,
+      70,    71,    35,    36,    75,    76,    77,    78,    79,    80,
+      81,    82,   130,   106,    35,    36,   117,   118,   107,    -2,
+      -2,    64,    65,    66,    67,    68,    69,    70,    71,   110,
+     134,   149,    35,    36,   125,    92,    93,   119,   120,   121,
+     109,   128,   129,   132,   133,   127,   131,   135,    64,    65,
+      66,    67,    68,    69,    70,    71,   140,   144,   142,    48,
+      88,    89,    64,    65,    66,    67,    68,    69,    70,    71,
+     147,   141,   148,    85,   146,   116,   143,    60
 };
 
-static const yytype_int16 yycheck[] =
+#define yypact_value_is_default(Yystate) \
+  (!!((Yystate) == (-57)))
+
+#define yytable_value_is_error(Yytable_value) \
+  YYID (0)
+
+static const yytype_uint8 yycheck[] =
 {
-       3,     4,     5,     6,     7,    59,    61,    62,    63,     5,
-       5,     5,    37,     5,    43,    44,    45,    46,    47,    48,
-      37,    12,    16,    50,    41,    52,    53,     0,    50,    32,
-      52,    53,    50,    49,    52,    53,    17,    40,    17,    42,
-      43,    44,    50,     3,    52,    53,    17,    43,    44,    49,
-      41,    43,    44,    50,    17,    52,    53,    48,    26,    27,
-      28,    64,    65,    66,    67,    68,    69,   121,     3,    60,
-     125,    49,    75,    76,   129,    49,     0,     1,   133,    52,
-      53,    72,     6,     7,     8,     9,    10,    11,    12,    13,
-      14,    15,    12,    49,    85,    49,    99,   100,    89,   102,
-     103,    49,    93,    18,    19,    20,    21,    22,    23,    24,
-      25,     3,     4,     3,    34,    35,    36,    37,    38,    39,
-      40,    50,    41,    52,    53,    52,    53,     4,    52,    53,
-      18,    19,    20,    21,    22,    23,    24,    25,    50,   142,
-      52,    53,     3,     4,    32,    33,     4,     4,   139,     3,
-       5,     4,     4,   144,   145,   146,    18,    19,    20,    21,
-      22,    23,    24,    25,     3,     3,    51,     4,    30,    31,
-      18,    19,    20,    21,    22,    23,    24,    25,    37,   129,
-     108,    29,   133,   125,    53,    -1,   112
+       3,     4,     5,     6,     7,    61,    62,    63,     5,     5,
+      59,    38,     5,     5,     0,    42,    51,    38,    53,    54,
+      16,    12,    44,    45,    46,    47,    48,    49,    51,    32,
+      53,    54,    51,    50,    53,    54,    17,    40,    17,    42,
+      43,    44,    51,     3,    53,    54,    17,    44,    45,    50,
+      41,    44,    45,    51,    17,    53,    54,    48,    26,    27,
+      28,    64,    65,    66,    67,    68,    69,    53,    54,    60,
+      50,   127,    75,    76,   123,   131,     0,     1,    50,   135,
+      50,    72,     6,     7,     8,     9,    10,    11,    12,    13,
+      14,    15,    12,     3,     4,    86,    50,   100,   101,    90,
+     103,   104,    50,    94,    18,    19,    20,    21,    22,    23,
+      24,    25,    53,    54,    34,    35,    36,    37,    38,    39,
+      40,    41,    51,     3,    53,    54,     3,     4,     3,    53,
+      54,    18,    19,    20,    21,    22,    23,    24,    25,    42,
+      51,   144,    53,    54,     3,    32,    33,     4,     4,     4,
+     141,     4,     4,     3,     3,   146,   147,   148,    18,    19,
+      20,    21,    22,    23,    24,    25,     4,    52,     5,    37,
+      30,    31,    18,    19,    20,    21,    22,    23,    24,    25,
+     131,   109,   135,    29,   127,    78,   113,    53
 };
 
 /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
@@ -720,20 +802,20 @@
 static const yytype_uint8 yystos[] =
 {
        0,     1,     6,     7,     8,     9,    10,    11,    12,    13,
-      14,    15,    55,    60,    66,    43,    44,    45,    46,    47,
-      48,    71,     5,    70,    70,    70,    70,    70,    37,    49,
-      56,    58,    57,    59,     0,    52,    53,    72,     3,    37,
-      41,    69,    26,    27,    28,    17,    70,    17,    55,     3,
-       4,    70,    50,    72,    70,    70,    70,    49,    49,    49,
-      69,    49,    49,    49,    18,    19,    20,    21,    22,    23,
-      24,    25,    61,    65,    12,    34,    35,    36,    37,    38,
-      39,    40,    67,    67,    29,    64,    65,    30,    31,    62,
-      65,    32,    33,    63,    65,    70,    70,    70,    70,    43,
-      44,    70,    43,    44,    70,     3,     3,    50,    72,    41,
-      70,    70,    16,    68,    70,     3,     4,     4,     4,     4,
-      50,    72,    50,     3,    50,    72,     4,     4,    50,    72,
-       3,     3,    50,    72,    70,    70,    70,    70,     4,    61,
-       5,    68,    51,    67,    64,    62,    63,    70
+      14,    15,    56,    61,    67,    44,    45,    46,    47,    48,
+      49,    72,     5,    71,    71,    71,    71,    71,    38,    50,
+      57,    59,    58,    60,     0,    53,    54,    73,     3,    38,
+      42,    70,    26,    27,    28,    17,    71,    17,    56,     3,
+       4,    71,    51,    73,    71,    71,    71,    50,    50,    50,
+      70,    50,    50,    50,    18,    19,    20,    21,    22,    23,
+      24,    25,    62,    66,    12,    34,    35,    36,    37,    38,
+      39,    40,    41,    68,    68,    29,    65,    66,    30,    31,
+      63,    66,    32,    33,    64,    66,    71,    71,    71,    71,
+      44,    45,    71,    44,    45,    71,     3,     3,    51,    73,
+      42,    71,    71,    16,    69,    71,    72,     3,     4,     4,
+       4,     4,    51,    73,    51,     3,    51,    73,     4,     4,
+      51,    73,     3,     3,    51,    73,    71,    71,    71,    71,
+       4,    62,     5,    69,    52,    68,    65,    63,    64,    71
 };
 
 #define yyerrok		(yyerrstatus = 0)
@@ -748,30 +830,39 @@
 
 /* Like YYERROR except do call yyerror.  This remains here temporarily
    to ease the transition to the new meaning of YYERROR, for GCC.
-   Once GCC version 2 has supplanted version 1, this can go.  */
+   Once GCC version 2 has supplanted version 1, this can go.  However,
+   YYFAIL appears to be in use.  Nevertheless, it is formally deprecated
+   in Bison 2.4.2's NEWS entry, where a plan to phase it out is
+   discussed.  */
 
 #define YYFAIL		goto yyerrlab
+#if defined YYFAIL
+  /* This is here to suppress warnings from the GCC cpp's
+     -Wunused-macros.  Normally we don't worry about that warning, but
+     some users do, and we want to make it easy for users to remove
+     YYFAIL uses, which will produce warnings from Bison 2.5.  */
+#endif
 
 #define YYRECOVERING()  (!!yyerrstatus)
 
-#define YYBACKUP(Token, Value)					\
-do								\
-  if (yychar == YYEMPTY && yylen == 1)				\
-    {								\
-      yychar = (Token);						\
-      yylval = (Value);						\
-      yytoken = YYTRANSLATE (yychar);				\
-      YYPOPSTACK (1);						\
-      goto yybackup;						\
-    }								\
-  else								\
-    {								\
+#define YYBACKUP(Token, Value)                                  \
+do                                                              \
+  if (yychar == YYEMPTY)                                        \
+    {                                                           \
+      yychar = (Token);                                         \
+      yylval = (Value);                                         \
+      YYPOPSTACK (yylen);                                       \
+      yystate = *yyssp;                                         \
+      goto yybackup;                                            \
+    }                                                           \
+  else                                                          \
+    {                                                           \
       yyerror (YY_("syntax error: cannot back up")); \
       YYERROR;							\
     }								\
 while (YYID (0))
 
-
+/* Error token number */
 #define YYTERROR	1
 #define YYERRCODE	256
 
@@ -780,38 +871,75 @@
    If N is 0, then set CURRENT to the empty location which ends
    the previous symbol: RHS[0] (always defined).  */
 
-#define YYRHSLOC(Rhs, K) ((Rhs)[K])
 #ifndef YYLLOC_DEFAULT
-# define YYLLOC_DEFAULT(Current, Rhs, N)				\
-    do									\
-      if (YYID (N))                                                    \
-	{								\
-	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
-	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
-	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
-	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
-	}								\
-      else								\
-	{								\
-	  (Current).first_line   = (Current).last_line   =		\
-	    YYRHSLOC (Rhs, 0).last_line;				\
-	  (Current).first_column = (Current).last_column =		\
-	    YYRHSLOC (Rhs, 0).last_column;				\
-	}								\
+# define YYLLOC_DEFAULT(Current, Rhs, N)                                \
+    do                                                                  \
+      if (YYID (N))                                                     \
+        {                                                               \
+          (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;        \
+          (Current).first_column = YYRHSLOC (Rhs, 1).first_column;      \
+          (Current).last_line    = YYRHSLOC (Rhs, N).last_line;         \
+          (Current).last_column  = YYRHSLOC (Rhs, N).last_column;       \
+        }                                                               \
+      else                                                              \
+        {                                                               \
+          (Current).first_line   = (Current).last_line   =              \
+            YYRHSLOC (Rhs, 0).last_line;                                \
+          (Current).first_column = (Current).last_column =              \
+            YYRHSLOC (Rhs, 0).last_column;                              \
+        }                                                               \
     while (YYID (0))
 #endif
 
+#define YYRHSLOC(Rhs, K) ((Rhs)[K])
+
 
 /* YY_LOCATION_PRINT -- Print the location on the stream.
    This macro was not mandated originally: define only if we know
    we won't break user code: when these are the locations we know.  */
 
 #ifndef YY_LOCATION_PRINT
-# if YYLTYPE_IS_TRIVIAL
-#  define YY_LOCATION_PRINT(File, Loc)			\
-     fprintf (File, "%d.%d-%d.%d",			\
-	      (Loc).first_line, (Loc).first_column,	\
-	      (Loc).last_line,  (Loc).last_column)
+# if defined YYLTYPE_IS_TRIVIAL && YYLTYPE_IS_TRIVIAL
+
+/* Print *YYLOCP on YYO.  Private, do not rely on its existence. */
+
+__attribute__((__unused__))
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static unsigned
+yy_location_print_ (FILE *yyo, YYLTYPE const * const yylocp)
+#else
+static unsigned
+yy_location_print_ (yyo, yylocp)
+    FILE *yyo;
+    YYLTYPE const * const yylocp;
+#endif
+{
+  unsigned res = 0;
+  int end_col = 0 != yylocp->last_column ? yylocp->last_column - 1 : 0;
+  if (0 <= yylocp->first_line)
+    {
+      res += fprintf (yyo, "%d", yylocp->first_line);
+      if (0 <= yylocp->first_column)
+        res += fprintf (yyo, ".%d", yylocp->first_column);
+    }
+  if (0 <= yylocp->last_line)
+    {
+      if (yylocp->first_line < yylocp->last_line)
+        {
+          res += fprintf (yyo, "-%d", yylocp->last_line);
+          if (0 <= end_col)
+            res += fprintf (yyo, ".%d", end_col);
+        }
+      else if (0 <= end_col && yylocp->first_column < end_col)
+        res += fprintf (yyo, "-%d", end_col);
+    }
+  return res;
+ }
+
+#  define YY_LOCATION_PRINT(File, Loc)          \
+  yy_location_print_ (File, &(Loc))
+
 # else
 #  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
 # endif
@@ -819,7 +947,6 @@
 
 
 /* YYLEX -- calling `yylex' with the right arguments.  */
-
 #ifdef YYLEX_PARAM
 # define YYLEX yylex (YYLEX_PARAM)
 #else
@@ -870,6 +997,8 @@
     YYLTYPE const * const yylocationp;
 #endif
 {
+  FILE *yyo = yyoutput;
+  YYUSE (yyo);
   if (!yyvaluep)
     return;
   YYUSE (yylocationp);
@@ -882,7 +1011,7 @@
   switch (yytype)
     {
       default:
-	break;
+        break;
     }
 }
 
@@ -1012,7 +1141,6 @@
 # define YYMAXDEPTH 10000
 #endif
 
-
 
 #if YYERROR_VERBOSE
 
@@ -1115,115 +1243,145 @@
 }
 # endif
 
-/* Copy into YYRESULT an error message about the unexpected token
-   YYCHAR while in state YYSTATE.  Return the number of bytes copied,
-   including the terminating null byte.  If YYRESULT is null, do not
-   copy anything; just return the number of bytes that would be
-   copied.  As a special case, return 0 if an ordinary "syntax error"
-   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
-   size calculation.  */
-static YYSIZE_T
-yysyntax_error (char *yyresult, int yystate, int yychar)
+/* Copy into *YYMSG, which is of size *YYMSG_ALLOC, an error message
+   about the unexpected token YYTOKEN for the state stack whose top is
+   YYSSP.
+
+   Return 0 if *YYMSG was successfully written.  Return 1 if *YYMSG is
+   not large enough to hold the message.  In that case, also set
+   *YYMSG_ALLOC to the required number of bytes.  Return 2 if the
+   required number of bytes is too large to store.  */
+static int
+yysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,
+                yytype_int16 *yyssp, int yytoken)
 {
-  int yyn = yypact[yystate];
-
-  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))
-    return 0;
-  else
+  YYSIZE_T yysize0 = yytnamerr (YY_NULL, yytname[yytoken]);
+  YYSIZE_T yysize = yysize0;
+  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+  /* Internationalized format string. */
+  const char *yyformat = YY_NULL;
+  /* Arguments of yyformat. */
+  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+  /* Number of reported tokens (one for the "unexpected", one per
+     "expected"). */
+  int yycount = 0;
+
+  /* There are many possibilities here to consider:
+     - Assume YYFAIL is not used.  It's too flawed to consider.  See
+       <http://lists.gnu.org/archive/html/bison-patches/2009-12/msg00024.html>
+       for details.  YYERROR is fine as it does not invoke this
+       function.
+     - If this state is a consistent state with a default action, then
+       the only way this function was invoked is if the default action
+       is an error action.  In that case, don't check for expected
+       tokens because there are none.
+     - The only way there can be no lookahead present (in yychar) is if
+       this state is a consistent state with a default action.  Thus,
+       detecting the absence of a lookahead is sufficient to determine
+       that there is no unexpected or expected token to report.  In that
+       case, just report a simple "syntax error".
+     - Don't assume there isn't a lookahead just because this state is a
+       consistent state with a default action.  There might have been a
+       previous inconsistent state, consistent state with a non-default
+       action, or user semantic action that manipulated yychar.
+     - Of course, the expected token list depends on states to have
+       correct lookahead information, and it depends on the parser not
+       to perform extra reductions after fetching a lookahead from the
+       scanner and before detecting a syntax error.  Thus, state merging
+       (from LALR or IELR) and default reductions corrupt the expected
+       token list.  However, the list is correct for canonical LR with
+       one exception: it will still contain any token that will not be
+       accepted due to an error action in a later state.
+  */
+  if (yytoken != YYEMPTY)
     {
-      int yytype = YYTRANSLATE (yychar);
-      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
-      YYSIZE_T yysize = yysize0;
-      YYSIZE_T yysize1;
-      int yysize_overflow = 0;
-      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
-      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
-      int yyx;
-
-# if 0
-      /* This is so xgettext sees the translatable formats that are
-	 constructed on the fly.  */
-      YY_("syntax error, unexpected %s");
-      YY_("syntax error, unexpected %s, expecting %s");
-      YY_("syntax error, unexpected %s, expecting %s or %s");
-      YY_("syntax error, unexpected %s, expecting %s or %s or %s");
-      YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
-# endif
-      char *yyfmt;
-      char const *yyf;
-      static char const yyunexpected[] = "syntax error, unexpected %s";
-      static char const yyexpecting[] = ", expecting %s";
-      static char const yyor[] = " or %s";
-      char yyformat[sizeof yyunexpected
-		    + sizeof yyexpecting - 1
-		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
-		       * (sizeof yyor - 1))];
-      char const *yyprefix = yyexpecting;
-
-      /* Start YYX at -YYN if negative to avoid negative indexes in
-	 YYCHECK.  */
-      int yyxbegin = yyn < 0 ? -yyn : 0;
-
-      /* Stay within bounds of both yycheck and yytname.  */
-      int yychecklim = YYLAST - yyn + 1;
-      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
-      int yycount = 1;
-
-      yyarg[0] = yytname[yytype];
-      yyfmt = yystpcpy (yyformat, yyunexpected);
-
-      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-	if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
-	  {
-	    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
-	      {
-		yycount = 1;
-		yysize = yysize0;
-		yyformat[sizeof yyunexpected - 1] = '\0';
-		break;
-	      }
-	    yyarg[yycount++] = yytname[yyx];
-	    yysize1 = yysize + yytnamerr (0, yytname[yyx]);
-	    yysize_overflow |= (yysize1 < yysize);
-	    yysize = yysize1;
-	    yyfmt = yystpcpy (yyfmt, yyprefix);
-	    yyprefix = yyor;
-	  }
+      int yyn = yypact[*yyssp];
+      yyarg[yycount++] = yytname[yytoken];
+      if (!yypact_value_is_default (yyn))
+        {
+          /* Start YYX at -YYN if negative to avoid negative indexes in
+             YYCHECK.  In other words, skip the first -YYN actions for
+             this state because they are default actions.  */
+          int yyxbegin = yyn < 0 ? -yyn : 0;
+          /* Stay within bounds of both yycheck and yytname.  */
+          int yychecklim = YYLAST - yyn + 1;
+          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+          int yyx;
+
+          for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR
+                && !yytable_value_is_error (yytable[yyx + yyn]))
+              {
+                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+                  {
+                    yycount = 1;
+                    yysize = yysize0;
+                    break;
+                  }
+                yyarg[yycount++] = yytname[yyx];
+                {
+                  YYSIZE_T yysize1 = yysize + yytnamerr (YY_NULL, yytname[yyx]);
+                  if (! (yysize <= yysize1
+                         && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
+                    return 2;
+                  yysize = yysize1;
+                }
+              }
+        }
+    }
 
-      yyf = YY_(yyformat);
-      yysize1 = yysize + yystrlen (yyf);
-      yysize_overflow |= (yysize1 < yysize);
-      yysize = yysize1;
+  switch (yycount)
+    {
+# define YYCASE_(N, S)                      \
+      case N:                               \
+        yyformat = S;                       \
+      break
+      YYCASE_(0, YY_("syntax error"));
+      YYCASE_(1, YY_("syntax error, unexpected %s"));
+      YYCASE_(2, YY_("syntax error, unexpected %s, expecting %s"));
+      YYCASE_(3, YY_("syntax error, unexpected %s, expecting %s or %s"));
+      YYCASE_(4, YY_("syntax error, unexpected %s, expecting %s or %s or %s"));
+      YYCASE_(5, YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s"));
+# undef YYCASE_
+    }
 
-      if (yysize_overflow)
-	return YYSIZE_MAXIMUM;
+  {
+    YYSIZE_T yysize1 = yysize + yystrlen (yyformat);
+    if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
+      return 2;
+    yysize = yysize1;
+  }
 
-      if (yyresult)
-	{
-	  /* Avoid sprintf, as that infringes on the user's name space.
-	     Don't have undefined behavior even if the translation
-	     produced a string with the wrong number of "%s"s.  */
-	  char *yyp = yyresult;
-	  int yyi = 0;
-	  while ((*yyp = *yyf) != '\0')
-	    {
-	      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
-		{
-		  yyp += yytnamerr (yyp, yyarg[yyi++]);
-		  yyf += 2;
-		}
-	      else
-		{
-		  yyp++;
-		  yyf++;
-		}
-	    }
-	}
-      return yysize;
+  if (*yymsg_alloc < yysize)
+    {
+      *yymsg_alloc = 2 * yysize;
+      if (! (yysize <= *yymsg_alloc
+             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))
+        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;
+      return 1;
     }
+
+  /* Avoid sprintf, as that infringes on the user's name space.
+     Don't have undefined behavior even if the translation
+     produced a string with the wrong number of "%s"s.  */
+  {
+    char *yyp = *yymsg;
+    int yyi = 0;
+    while ((*yyp = *yyformat) != '\0')
+      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)
+        {
+          yyp += yytnamerr (yyp, yyarg[yyi++]);
+          yyformat += 2;
+        }
+      else
+        {
+          yyp++;
+          yyformat++;
+        }
+  }
+  return 0;
 }
 #endif /* YYERROR_VERBOSE */
-
 
 /*-----------------------------------------------.
 | Release the memory associated to this symbol.  |
@@ -1254,43 +1412,43 @@
     {
 
       default:
-	break;
+        break;
     }
 }
 
-/* Prevent warnings from -Wmissing-prototypes.  */
-#ifdef YYPARSE_PARAM
-#if defined __STDC__ || defined __cplusplus
-int yyparse (void *YYPARSE_PARAM);
-#else
-int yyparse ();
-#endif
-#else /* ! YYPARSE_PARAM */
-#if defined __STDC__ || defined __cplusplus
-int yyparse (void);
-#else
-int yyparse ();
-#endif
-#endif /* ! YYPARSE_PARAM */
+
 
 
 /* The lookahead symbol.  */
 int yychar;
 
+
+#ifndef YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+# define YY_IGNORE_MAYBE_UNINITIALIZED_END
+#endif
+#ifndef YY_INITIAL_VALUE
+# define YY_INITIAL_VALUE(Value) /* Nothing. */
+#endif
+
 /* The semantic value of the lookahead symbol.  */
-YYSTYPE yylval;
+YYSTYPE yylval YY_INITIAL_VALUE(yyval_default);
 
 /* Location data for the lookahead symbol.  */
-YYLTYPE yylloc;
+YYLTYPE yylloc
+# if defined YYLTYPE_IS_TRIVIAL && YYLTYPE_IS_TRIVIAL
+  = { 1, 1, 1, 1 }
+# endif
+;
+
 
 /* Number of syntax errors so far.  */
 int yynerrs;
 
 
-
-/*-------------------------.
-| yyparse or yypush_parse.  |
-`-------------------------*/
+/*----------.
+| yyparse.  |
+`----------*/
 
 #ifdef YYPARSE_PARAM
 #if (defined __STDC__ || defined __C99__FUNC__ \
@@ -1314,8 +1472,6 @@
 #endif
 #endif
 {
-
-
     int yystate;
     /* Number of tokens to shift before error messages enabled.  */
     int yyerrstatus;
@@ -1325,7 +1481,7 @@
        `yyvs': related to semantic values.
        `yyls': related to locations.
 
-       Refer to the stacks thru separate pointers, to allow yyoverflow
+       Refer to the stacks through separate pointers, to allow yyoverflow
        to reallocate them elsewhere.  */
 
     /* The state stack.  */
@@ -1344,14 +1500,14 @@
     YYLTYPE *yylsp;
 
     /* The locations where the error started and ended.  */
-    YYLTYPE yyerror_range[2];
+    YYLTYPE yyerror_range[3];
 
     YYSIZE_T yystacksize;
 
   int yyn;
   int yyresult;
   /* Lookahead token as an internal (translated) token number.  */
-  int yytoken;
+  int yytoken = 0;
   /* The variables used to return semantic value and location from the
      action routines.  */
   YYSTYPE yyval;
@@ -1370,10 +1526,9 @@
      Keep to zero when no symbol should be popped.  */
   int yylen = 0;
 
-  yytoken = 0;
-  yyss = yyssa;
-  yyvs = yyvsa;
-  yyls = yylsa;
+  yyssp = yyss = yyssa;
+  yyvsp = yyvs = yyvsa;
+  yylsp = yyls = yylsa;
   yystacksize = YYINITDEPTH;
 
   YYDPRINTF ((stderr, "Starting parse\n"));
@@ -1382,21 +1537,7 @@
   yyerrstatus = 0;
   yynerrs = 0;
   yychar = YYEMPTY; /* Cause a token to be read.  */
-
-  /* Initialize stack pointers.
-     Waste one element of value and location stack
-     so that they stay on the same level as the state stack.
-     The wasted elements are never initialized.  */
-  yyssp = yyss;
-  yyvsp = yyvs;
-  yylsp = yyls;
-
-#if YYLTYPE_IS_TRIVIAL
-  /* Initialize the default location before parsing starts.  */
-  yylloc.first_line   = yylloc.last_line   = 1;
-  yylloc.first_column = yylloc.last_column = 1;
-#endif
-
+  yylsp[0] = yylloc;
   goto yysetstate;
 
 /*------------------------------------------------------------.
@@ -1493,7 +1634,7 @@
 
   /* First try to decide what to do without reference to lookahead token.  */
   yyn = yypact[yystate];
-  if (yyn == YYPACT_NINF)
+  if (yypact_value_is_default (yyn))
     goto yydefault;
 
   /* Not known => get a lookahead token if don't already have one.  */
@@ -1524,8 +1665,8 @@
   yyn = yytable[yyn];
   if (yyn <= 0)
     {
-      if (yyn == 0 || yyn == YYTABLE_NINF)
-	goto yyerrlab;
+      if (yytable_value_is_error (yyn))
+        goto yyerrlab;
       yyn = -yyn;
       goto yyreduce;
     }
@@ -1542,7 +1683,9 @@
   yychar = YYEMPTY;
 
   yystate = yyn;
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
   *++yyvsp = yylval;
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
   *++yylsp = yylloc;
   goto yynewstate;
 
@@ -1580,431 +1723,391 @@
   switch (yyn)
     {
         case 3:
-
-/* Line 1455 of yacc.c  */
-#line 124 "cfgparser1.y"
-    { cur_config.debug=(yyvsp[(2) - (2)].i); ;}
+/* Line 1792 of yacc.c  */
+#line 125 "cfgparser1.y"
+    { cur_config.debug=(yyvsp[(2) - (2)].i); }
     break;
 
   case 4:
-
-/* Line 1455 of yacc.c  */
-#line 125 "cfgparser1.y"
-    { cur_config.user=(yyvsp[(2) - (2)].s); ;}
+/* Line 1792 of yacc.c  */
+#line 126 "cfgparser1.y"
+    { cur_config.user=(yyvsp[(2) - (2)].s); }
     break;
 
   case 5:
-
-/* Line 1455 of yacc.c  */
-#line 126 "cfgparser1.y"
-    { cur_config.group=(yyvsp[(2) - (2)].s); ;}
+/* Line 1792 of yacc.c  */
+#line 127 "cfgparser1.y"
+    { cur_config.group=(yyvsp[(2) - (2)].s); }
     break;
 
   case 6:
-
-/* Line 1455 of yacc.c  */
-#line 127 "cfgparser1.y"
-    { cur_config.mailer=(yyvsp[(2) - (2)].s); ;}
+/* Line 1792 of yacc.c  */
+#line 128 "cfgparser1.y"
+    { cur_config.mailer=(yyvsp[(2) - (2)].s); }
     break;
 
   case 7:
-
-/* Line 1455 of yacc.c  */
-#line 128 "cfgparser1.y"
-    { cur_config.timestamp_format=(yyvsp[(2) - (2)].s); ;}
+/* Line 1792 of yacc.c  */
+#line 129 "cfgparser1.y"
+    { cur_config.timestamp_format=(yyvsp[(2) - (2)].s); }
     break;
 
   case 8:
-
-/* Line 1455 of yacc.c  */
-#line 129 "cfgparser1.y"
-    { cur_config.pid_file=(yyvsp[(2) - (2)].s); ;}
+/* Line 1792 of yacc.c  */
+#line 130 "cfgparser1.y"
+    { cur_config.pid_file=(yyvsp[(2) - (2)].s); }
     break;
 
   case 10:
-
-/* Line 1455 of yacc.c  */
-#line 131 "cfgparser1.y"
-    { cur_config.rrd_interval=(yyvsp[(3) - (3)].i); ;}
+/* Line 1792 of yacc.c  */
+#line 132 "cfgparser1.y"
+    { cur_config.rrd_interval=(yyvsp[(3) - (3)].i); }
     break;
 
   case 14:
-
-/* Line 1455 of yacc.c  */
-#line 136 "cfgparser1.y"
+/* Line 1792 of yacc.c  */
+#line 137 "cfgparser1.y"
     {
 			logit("Configuration file syntax error. Line %i, character %i",
 					(yyloc).first_line+1,(yyloc).first_column+1);
 			YYABORT;
-		;}
+		}
     break;
 
   case 15:
-
-/* Line 1455 of yacc.c  */
-#line 143 "cfgparser1.y"
-    { (yyval.a)=make_alarm(); ;}
+/* Line 1792 of yacc.c  */
+#line 144 "cfgparser1.y"
+    { (yyval.a)=make_alarm(); }
     break;
 
   case 16:
-
-/* Line 1455 of yacc.c  */
-#line 146 "cfgparser1.y"
-    { (yyval.t)=make_target(); ;}
+/* Line 1792 of yacc.c  */
+#line 147 "cfgparser1.y"
+    { (yyval.t)=make_target(); }
     break;
 
   case 17:
-
-/* Line 1455 of yacc.c  */
-#line 149 "cfgparser1.y"
+/* Line 1792 of yacc.c  */
+#line 150 "cfgparser1.y"
     { 
 	   		(yyval.a)=&cur_config.alarm_defaults; 
 			cur_alarm=(yyval.a);
-	   	;}
+	   	}
     break;
 
   case 18:
-
-/* Line 1455 of yacc.c  */
-#line 155 "cfgparser1.y"
+/* Line 1792 of yacc.c  */
+#line 156 "cfgparser1.y"
     { 
 	    		(yyval.t)=&cur_config.target_defaults; 
 			cur_target=(yyval.t);
-		;}
+		}
     break;
 
   case 20:
-
-/* Line 1455 of yacc.c  */
-#line 163 "cfgparser1.y"
+/* Line 1792 of yacc.c  */
+#line 164 "cfgparser1.y"
     { 
 			cur_alarm->name=(yyvsp[(4) - (7)].s);
 			add_alarm(AL_DOWN); 
-		;}
+		}
     break;
 
   case 21:
-
-/* Line 1455 of yacc.c  */
-#line 168 "cfgparser1.y"
+/* Line 1792 of yacc.c  */
+#line 169 "cfgparser1.y"
     { 
 			cur_alarm->name=(yyvsp[(4) - (7)].s);
 			add_alarm(AL_LOSS); 
-		;}
+		}
     break;
 
   case 22:
-
-/* Line 1455 of yacc.c  */
-#line 173 "cfgparser1.y"
+/* Line 1792 of yacc.c  */
+#line 174 "cfgparser1.y"
     { 
 			cur_alarm->name=(yyvsp[(4) - (7)].s);
 			add_alarm(AL_DELAY); 
-		;}
+		}
     break;
 
   case 26:
-
-/* Line 1455 of yacc.c  */
-#line 185 "cfgparser1.y"
-    { cur_alarm->p.lh.low=(yyvsp[(2) - (2)].i); ;}
+/* Line 1792 of yacc.c  */
+#line 186 "cfgparser1.y"
+    { cur_alarm->p.lh.low=(yyvsp[(2) - (2)].i); }
     break;
 
   case 27:
-
-/* Line 1455 of yacc.c  */
-#line 187 "cfgparser1.y"
-    { cur_alarm->p.lh.high=(yyvsp[(2) - (2)].i); ;}
+/* Line 1792 of yacc.c  */
+#line 188 "cfgparser1.y"
+    { cur_alarm->p.lh.high=(yyvsp[(2) - (2)].i); }
     break;
 
   case 30:
-
-/* Line 1455 of yacc.c  */
-#line 193 "cfgparser1.y"
-    { cur_alarm->p.lh.low=(yyvsp[(2) - (2)].i); ;}
+/* Line 1792 of yacc.c  */
+#line 194 "cfgparser1.y"
+    { cur_alarm->p.lh.low=(yyvsp[(2) - (2)].i); }
     break;
 
   case 31:
-
-/* Line 1455 of yacc.c  */
-#line 195 "cfgparser1.y"
-    { cur_alarm->p.lh.high=(yyvsp[(2) - (2)].i); ;}
+/* Line 1792 of yacc.c  */
+#line 196 "cfgparser1.y"
+    { cur_alarm->p.lh.high=(yyvsp[(2) - (2)].i); }
     break;
 
   case 34:
-
-/* Line 1455 of yacc.c  */
-#line 201 "cfgparser1.y"
-    { cur_alarm->p.val=(yyvsp[(2) - (2)].i); ;}
+/* Line 1792 of yacc.c  */
+#line 202 "cfgparser1.y"
+    { cur_alarm->p.val=(yyvsp[(2) - (2)].i); }
     break;
 
   case 37:
-
-/* Line 1455 of yacc.c  */
-#line 207 "cfgparser1.y"
-    { cur_alarm->mailto=(yyvsp[(2) - (2)].s); ;}
+/* Line 1792 of yacc.c  */
+#line 208 "cfgparser1.y"
+    { cur_alarm->mailto=(yyvsp[(2) - (2)].s); }
     break;
 
   case 38:
-
-/* Line 1455 of yacc.c  */
-#line 209 "cfgparser1.y"
-    { cur_alarm->mailfrom=(yyvsp[(2) - (2)].s); ;}
+/* Line 1792 of yacc.c  */
+#line 210 "cfgparser1.y"
+    { cur_alarm->mailfrom=(yyvsp[(2) - (2)].s); }
     break;
 
   case 39:
-
-/* Line 1455 of yacc.c  */
-#line 211 "cfgparser1.y"
-    { cur_alarm->mailenvfrom=(yyvsp[(2) - (2)].s); ;}
+/* Line 1792 of yacc.c  */
+#line 212 "cfgparser1.y"
+    { cur_alarm->mailenvfrom=(yyvsp[(2) - (2)].s); }
     break;
 
   case 40:
-
-/* Line 1455 of yacc.c  */
-#line 213 "cfgparser1.y"
-    { cur_alarm->mailsubject=(yyvsp[(2) - (2)].s); ;}
+/* Line 1792 of yacc.c  */
+#line 214 "cfgparser1.y"
+    { cur_alarm->mailsubject=(yyvsp[(2) - (2)].s); }
     break;
 
   case 41:
-
-/* Line 1455 of yacc.c  */
-#line 215 "cfgparser1.y"
+/* Line 1792 of yacc.c  */
+#line 216 "cfgparser1.y"
     { 
 			if (cur_alarm->command_on==NULL) cur_alarm->command_on=(yyvsp[(2) - (2)].s); 
 			if (cur_alarm->command_off==NULL) cur_alarm->command_off=(yyvsp[(2) - (2)].s); 
-		;}
+		}
     break;
 
   case 42:
-
-/* Line 1455 of yacc.c  */
-#line 220 "cfgparser1.y"
-    { cur_alarm->command_on=(yyvsp[(3) - (3)].s); ;}
+/* Line 1792 of yacc.c  */
+#line 221 "cfgparser1.y"
+    { cur_alarm->command_on=(yyvsp[(3) - (3)].s); }
     break;
 
   case 43:
-
-/* Line 1455 of yacc.c  */
-#line 222 "cfgparser1.y"
-    { cur_alarm->command_off=(yyvsp[(3) - (3)].s); ;}
+/* Line 1792 of yacc.c  */
+#line 223 "cfgparser1.y"
+    { cur_alarm->command_off=(yyvsp[(3) - (3)].s); }
     break;
 
   case 44:
-
-/* Line 1455 of yacc.c  */
-#line 224 "cfgparser1.y"
+/* Line 1792 of yacc.c  */
+#line 225 "cfgparser1.y"
     { 
 			if (cur_alarm->pipe_on==NULL) cur_alarm->pipe_on=(yyvsp[(2) - (2)].s); 
 			if (cur_alarm->pipe_off==NULL) cur_alarm->pipe_off=(yyvsp[(2) - (2)].s); 
-		;}
+		}
     break;
 
   case 45:
-
-/* Line 1455 of yacc.c  */
-#line 229 "cfgparser1.y"
-    { cur_alarm->pipe_on=(yyvsp[(3) - (3)].s); ;}
+/* Line 1792 of yacc.c  */
+#line 230 "cfgparser1.y"
+    { cur_alarm->pipe_on=(yyvsp[(3) - (3)].s); }
     break;
 
   case 46:
-
-/* Line 1455 of yacc.c  */
-#line 231 "cfgparser1.y"
-    { cur_alarm->pipe_off=(yyvsp[(3) - (3)].s); ;}
+/* Line 1792 of yacc.c  */
+#line 232 "cfgparser1.y"
+    { cur_alarm->pipe_off=(yyvsp[(3) - (3)].s); }
     break;
 
   case 47:
-
-/* Line 1455 of yacc.c  */
-#line 233 "cfgparser1.y"
-    { cur_alarm->combine_interval=(yyvsp[(2) - (2)].i); ;}
+/* Line 1792 of yacc.c  */
+#line 234 "cfgparser1.y"
+    { cur_alarm->combine_interval=(yyvsp[(2) - (2)].i); }
     break;
 
   case 48:
-
-/* Line 1455 of yacc.c  */
-#line 235 "cfgparser1.y"
-    { cur_alarm->repeat_interval=(yyvsp[(2) - (3)].i); cur_alarm->repeat_max=(yyvsp[(3) - (3)].i); ;}
+/* Line 1792 of yacc.c  */
+#line 236 "cfgparser1.y"
+    { cur_alarm->repeat_interval=(yyvsp[(2) - (3)].i); cur_alarm->repeat_max=(yyvsp[(3) - (3)].i); }
     break;
 
   case 49:
-
-/* Line 1455 of yacc.c  */
-#line 237 "cfgparser1.y"
-    { cur_alarm->combine_interval=(yyvsp[(2) - (2)].i); cur_alarm->repeat_max=0;;}
+/* Line 1792 of yacc.c  */
+#line 238 "cfgparser1.y"
+    { cur_alarm->combine_interval=(yyvsp[(2) - (2)].i); cur_alarm->repeat_max=0;}
     break;
 
   case 51:
-
-/* Line 1455 of yacc.c  */
-#line 243 "cfgparser1.y"
+/* Line 1792 of yacc.c  */
+#line 244 "cfgparser1.y"
     { 
 			cur_target->name=(yyvsp[(3) - (6)].s);
 			add_target(); 
-		;}
+		}
     break;
 
   case 53:
-
-/* Line 1455 of yacc.c  */
-#line 251 "cfgparser1.y"
-    { cur_target->description=(yyvsp[(2) - (2)].s); ;}
+/* Line 1792 of yacc.c  */
+#line 252 "cfgparser1.y"
+    { cur_target->description=(yyvsp[(2) - (2)].s); }
     break;
 
   case 54:
-
-/* Line 1455 of yacc.c  */
-#line 253 "cfgparser1.y"
-    { cur_target->srcip = (yyvsp[(2) - (2)].s); ;}
+/* Line 1792 of yacc.c  */
+#line 254 "cfgparser1.y"
+    { cur_target->srcip = (yyvsp[(2) - (2)].s); }
     break;
 
   case 55:
-
-/* Line 1455 of yacc.c  */
-#line 255 "cfgparser1.y"
-    { cur_target->alarms=(yyvsp[(2) - (2)].al); ;}
+/* Line 1792 of yacc.c  */
+#line 256 "cfgparser1.y"
+    { cur_target->alarms=(yyvsp[(2) - (2)].al); }
     break;
 
   case 56:
-
-/* Line 1455 of yacc.c  */
-#line 257 "cfgparser1.y"
-    { cur_target->alarms_override=1; cur_target->alarms=(yyvsp[(3) - (3)].al); ;}
+/* Line 1792 of yacc.c  */
+#line 258 "cfgparser1.y"
+    { cur_target->alarms_override=1; cur_target->alarms=(yyvsp[(3) - (3)].al); }
     break;
 
   case 57:
-
-/* Line 1455 of yacc.c  */
-#line 259 "cfgparser1.y"
-    { cur_target->interval=(yyvsp[(2) - (2)].i); ;}
+/* Line 1792 of yacc.c  */
+#line 260 "cfgparser1.y"
+    { cur_target->force_down=(yyvsp[(2) - (2)].i); }
     break;
 
   case 58:
-
-/* Line 1455 of yacc.c  */
-#line 261 "cfgparser1.y"
-    { cur_target->interval=(yyvsp[(2) - (2)].i); ;}
+/* Line 1792 of yacc.c  */
+#line 262 "cfgparser1.y"
+    { cur_target->interval=(yyvsp[(2) - (2)].i); }
     break;
 
   case 59:
-
-/* Line 1455 of yacc.c  */
-#line 263 "cfgparser1.y"
-    { cur_target->avg_delay_samples=(yyvsp[(2) - (2)].i); ;}
+/* Line 1792 of yacc.c  */
+#line 264 "cfgparser1.y"
+    { cur_target->interval=(yyvsp[(2) - (2)].i); }
     break;
 
   case 60:
-
-/* Line 1455 of yacc.c  */
-#line 265 "cfgparser1.y"
-    { cur_target->avg_loss_samples=(yyvsp[(2) - (2)].i); ;}
+/* Line 1792 of yacc.c  */
+#line 266 "cfgparser1.y"
+    { cur_target->avg_delay_samples=(yyvsp[(2) - (2)].i); }
     break;
 
   case 61:
-
-/* Line 1455 of yacc.c  */
-#line 267 "cfgparser1.y"
-    { cur_target->avg_loss_delay_samples=(yyvsp[(2) - (2)].i); ;}
+/* Line 1792 of yacc.c  */
+#line 268 "cfgparser1.y"
+    { cur_target->avg_loss_samples=(yyvsp[(2) - (2)].i); }
     break;
 
   case 62:
-
-/* Line 1455 of yacc.c  */
-#line 269 "cfgparser1.y"
-    { cur_target->rrd_filename=(yyvsp[(3) - (3)].s); ;}
+/* Line 1792 of yacc.c  */
+#line 270 "cfgparser1.y"
+    { cur_target->avg_loss_delay_samples=(yyvsp[(2) - (2)].i); }
     break;
 
-  case 64:
-
-/* Line 1455 of yacc.c  */
-#line 274 "cfgparser1.y"
-    { (yyval.al)=alarm2list((yyvsp[(1) - (1)].s),NULL); ;}
+  case 63:
+/* Line 1792 of yacc.c  */
+#line 272 "cfgparser1.y"
+    { cur_target->rrd_filename=(yyvsp[(3) - (3)].s); }
     break;
 
   case 65:
-
-/* Line 1455 of yacc.c  */
-#line 276 "cfgparser1.y"
-    { (yyval.al)=alarm2list((yyvsp[(3) - (3)].s),(yyvsp[(1) - (3)].al)); ;}
+/* Line 1792 of yacc.c  */
+#line 277 "cfgparser1.y"
+    { (yyval.al)=alarm2list((yyvsp[(1) - (1)].s),NULL); }
     break;
 
-  case 67:
-
-/* Line 1455 of yacc.c  */
-#line 281 "cfgparser1.y"
-    { cur_config.status_file=(yyvsp[(2) - (2)].s); ;}
+  case 66:
+/* Line 1792 of yacc.c  */
+#line 279 "cfgparser1.y"
+    { (yyval.al)=alarm2list((yyvsp[(3) - (3)].s),(yyvsp[(1) - (3)].al)); }
     break;
 
   case 68:
-
-/* Line 1455 of yacc.c  */
-#line 283 "cfgparser1.y"
-    { cur_config.status_interval=(yyvsp[(2) - (2)].i); ;}
+/* Line 1792 of yacc.c  */
+#line 284 "cfgparser1.y"
+    { cur_config.status_file=(yyvsp[(2) - (2)].s); }
     break;
 
   case 69:
-
-/* Line 1455 of yacc.c  */
-#line 285 "cfgparser1.y"
-    { cur_config.status_interval=(yyvsp[(2) - (2)].i); ;}
+/* Line 1792 of yacc.c  */
+#line 286 "cfgparser1.y"
+    { cur_config.status_interval=(yyvsp[(2) - (2)].i); }
     break;
 
-  case 71:
-
-/* Line 1455 of yacc.c  */
-#line 290 "cfgparser1.y"
-    { (yyval.s)=pool_strdup(&cur_config.pool,(yyvsp[(1) - (1)].s)); ;}
+  case 70:
+/* Line 1792 of yacc.c  */
+#line 288 "cfgparser1.y"
+    { cur_config.status_interval=(yyvsp[(2) - (2)].i); }
     break;
 
   case 72:
-
-/* Line 1455 of yacc.c  */
+/* Line 1792 of yacc.c  */
 #line 293 "cfgparser1.y"
-    { (yyval.i)=1; ;}
+    { (yyval.s)=pool_strdup(&cur_config.pool,(yyvsp[(1) - (1)].s)); }
     break;
 
   case 73:
-
-/* Line 1455 of yacc.c  */
-#line 294 "cfgparser1.y"
-    { (yyval.i)=0; ;}
+/* Line 1792 of yacc.c  */
+#line 296 "cfgparser1.y"
+    { (yyval.i)=1; }
     break;
 
   case 74:
-
-/* Line 1455 of yacc.c  */
-#line 295 "cfgparser1.y"
-    { (yyval.i)=1; ;}
+/* Line 1792 of yacc.c  */
+#line 297 "cfgparser1.y"
+    { (yyval.i)=0; }
     break;
 
   case 75:
-
-/* Line 1455 of yacc.c  */
-#line 296 "cfgparser1.y"
-    { (yyval.i)=0; ;}
+/* Line 1792 of yacc.c  */
+#line 298 "cfgparser1.y"
+    { (yyval.i)=1; }
     break;
 
   case 76:
-
-/* Line 1455 of yacc.c  */
-#line 297 "cfgparser1.y"
-    { (yyval.i)=1; ;}
+/* Line 1792 of yacc.c  */
+#line 299 "cfgparser1.y"
+    { (yyval.i)=0; }
     break;
 
   case 77:
-
-/* Line 1455 of yacc.c  */
-#line 298 "cfgparser1.y"
-    { (yyval.i)=0; ;}
+/* Line 1792 of yacc.c  */
+#line 300 "cfgparser1.y"
+    { (yyval.i)=1; }
     break;
 
+  case 78:
+/* Line 1792 of yacc.c  */
+#line 301 "cfgparser1.y"
+    { (yyval.i)=0; }
+    break;
 
 
-/* Line 1455 of yacc.c  */
-#line 2006 "cfgparser1.tab.c"
+/* Line 1792 of yacc.c  */
+#line 2098 "y.tab.c"
       default: break;
     }
+  /* User semantic actions sometimes alter yychar, and that requires
+     that yytoken be updated with the new translation.  We take the
+     approach of translating immediately before every use of yytoken.
+     One alternative is translating here after every semantic action,
+     but that translation would be missed if the semantic action invokes
+     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
+     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
+     incorrect destructor might then be invoked immediately.  In the
+     case of YYERROR or YYBACKUP, subsequent parser actions might lead
+     to an incorrect destructor call or verbose syntax error message
+     before the lookahead is translated.  */
   YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
 
   YYPOPSTACK (yylen);
@@ -2033,6 +2136,10 @@
 | yyerrlab -- here on detecting error |
 `------------------------------------*/
 yyerrlab:
+  /* Make sure we have latest lookahead translation.  See comments at
+     user semantic actions for why this is necessary.  */
+  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);
+
   /* If not already recovering from an error, report this error.  */
   if (!yyerrstatus)
     {
@@ -2040,41 +2147,40 @@
 #if ! YYERROR_VERBOSE
       yyerror (YY_("syntax error"));
 #else
+# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
+                                        yyssp, yytoken)
       {
-	YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
-	if (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)
-	  {
-	    YYSIZE_T yyalloc = 2 * yysize;
-	    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))
-	      yyalloc = YYSTACK_ALLOC_MAXIMUM;
-	    if (yymsg != yymsgbuf)
-	      YYSTACK_FREE (yymsg);
-	    yymsg = (char *) YYSTACK_ALLOC (yyalloc);
-	    if (yymsg)
-	      yymsg_alloc = yyalloc;
-	    else
-	      {
-		yymsg = yymsgbuf;
-		yymsg_alloc = sizeof yymsgbuf;
-	      }
-	  }
-
-	if (0 < yysize && yysize <= yymsg_alloc)
-	  {
-	    (void) yysyntax_error (yymsg, yystate, yychar);
-	    yyerror (yymsg);
-	  }
-	else
-	  {
-	    yyerror (YY_("syntax error"));
-	    if (yysize != 0)
-	      goto yyexhaustedlab;
-	  }
+        char const *yymsgp = YY_("syntax error");
+        int yysyntax_error_status;
+        yysyntax_error_status = YYSYNTAX_ERROR;
+        if (yysyntax_error_status == 0)
+          yymsgp = yymsg;
+        else if (yysyntax_error_status == 1)
+          {
+            if (yymsg != yymsgbuf)
+              YYSTACK_FREE (yymsg);
+            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
+            if (!yymsg)
+              {
+                yymsg = yymsgbuf;
+                yymsg_alloc = sizeof yymsgbuf;
+                yysyntax_error_status = 2;
+              }
+            else
+              {
+                yysyntax_error_status = YYSYNTAX_ERROR;
+                yymsgp = yymsg;
+              }
+          }
+        yyerror (yymsgp);
+        if (yysyntax_error_status == 2)
+          goto yyexhaustedlab;
       }
+# undef YYSYNTAX_ERROR
 #endif
     }
 
-  yyerror_range[0] = yylloc;
+  yyerror_range[1] = yylloc;
 
   if (yyerrstatus == 3)
     {
@@ -2111,7 +2217,7 @@
   if (/*CONSTCOND*/ 0)
      goto yyerrorlab;
 
-  yyerror_range[0] = yylsp[1-yylen];
+  yyerror_range[1] = yylsp[1-yylen];
   /* Do not reclaim the symbols of the rule which action triggered
      this YYERROR.  */
   YYPOPSTACK (yylen);
@@ -2130,7 +2236,7 @@
   for (;;)
     {
       yyn = yypact[yystate];
-      if (yyn != YYPACT_NINF)
+      if (!yypact_value_is_default (yyn))
 	{
 	  yyn += YYTERROR;
 	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
@@ -2145,7 +2251,7 @@
       if (yyssp == yyss)
 	YYABORT;
 
-      yyerror_range[0] = *yylsp;
+      yyerror_range[1] = *yylsp;
       yydestruct ("Error: popping",
 		  yystos[yystate], yyvsp, yylsp);
       YYPOPSTACK (1);
@@ -2153,12 +2259,14 @@
       YY_STACK_PRINT (yyss, yyssp);
     }
 
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
   *++yyvsp = yylval;
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
 
-  yyerror_range[1] = yylloc;
+  yyerror_range[2] = yylloc;
   /* Using YYLLOC is tempting, but would change the location of
      the lookahead.  YYLOC is available though.  */
-  YYLLOC_DEFAULT (yyloc, (yyerror_range - 1), 2);
+  YYLLOC_DEFAULT (yyloc, yyerror_range, 2);
   *++yylsp = yyloc;
 
   /* Shift the error token.  */
@@ -2182,7 +2290,7 @@
   yyresult = 1;
   goto yyreturn;
 
-#if !defined(yyoverflow) || YYERROR_VERBOSE
+#if !defined yyoverflow || YYERROR_VERBOSE
 /*-------------------------------------------------.
 | yyexhaustedlab -- memory exhaustion comes here.  |
 `-------------------------------------------------*/
@@ -2194,8 +2302,13 @@
 
 yyreturn:
   if (yychar != YYEMPTY)
-     yydestruct ("Cleanup: discarding lookahead",
-		 yytoken, &yylval, &yylloc);
+    {
+      /* Make sure we have latest lookahead translation.  See comments at
+         user semantic actions for why this is necessary.  */
+      yytoken = YYTRANSLATE (yychar);
+      yydestruct ("Cleanup: discarding lookahead",
+                  yytoken, &yylval, &yylloc);
+    }
   /* Do not reclaim the symbols of the rule which action triggered
      this YYABORT or YYACCEPT.  */
   YYPOPSTACK (yylen);
@@ -2219,12 +2332,10 @@
 }
 
 
-
-/* Line 1675 of yacc.c  */
-#line 306 "cfgparser1.y"
+/* Line 2055 of yacc.c  */
+#line 309 "cfgparser1.y"
 
 void yyerror (const char *s) {
 	logit("%s", s);
 }
 
-
diff -ruN ../apinger-0.6.1-patched/src/cfgparser1.h ./src/cfgparser1.h
--- ../apinger-0.6.1-patched/src/cfgparser1.h	2014-01-06 10:06:42.671168484 -0200
+++ ./src/cfgparser1.h	2014-01-06 11:33:47.543920154 -0200
@@ -1,81 +1,200 @@
-#ifndef BISON_Y_TAB_H
-# define BISON_Y_TAB_H
+/* A Bison parser, made by GNU Bison 2.7.  */
+
+/* Bison interface for Yacc-like parsers in C
+   
+      Copyright (C) 1984, 1989-1990, 2000-2012 Free Software Foundation, Inc.
+   
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+   
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+#ifndef YY_YY_Y_TAB_H_INCLUDED
+# define YY_YY_Y_TAB_H_INCLUDED
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+#if YYDEBUG
+extern int yydebug;
+#endif
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     TIME = 258,
+     INTEGER = 259,
+     STRING = 260,
+     DEBUG = 261,
+     USER = 262,
+     GROUP = 263,
+     PID_FILE = 264,
+     MAILER = 265,
+     TIMESTAMP_FORMAT = 266,
+     RRD = 267,
+     STATUS = 268,
+     ALARM = 269,
+     TARGET = 270,
+     OVERRIDE = 271,
+     DEFAULT = 272,
+     MAILTO = 273,
+     MAILFROM = 274,
+     MAILENVFROM = 275,
+     MAILSUBJECT = 276,
+     COMMAND = 277,
+     PIPE = 278,
+     COMBINE = 279,
+     REPEAT = 280,
+     DOWN = 281,
+     LOSS = 282,
+     DELAY = 283,
+     TIME_ = 284,
+     PERCENT_LOW = 285,
+     PERCENT_HIGH = 286,
+     DELAY_LOW = 287,
+     DELAY_HIGH = 288,
+     DESCRIPTION = 289,
+     SRCIP = 290,
+     ALARMS = 291,
+     FORCE_DOWN = 292,
+     INTERVAL = 293,
+     AVG_DELAY_SAMPLES = 294,
+     AVG_LOSS_SAMPLES = 295,
+     AVG_LOSS_DELAY_SAMPLES = 296,
+     FILE_ = 297,
+     ERROR = 298,
+     ON = 299,
+     OFF = 300,
+     YES = 301,
+     NO = 302,
+     TRUE = 303,
+     FALSE = 304
+   };
+#endif
+/* Tokens.  */
+#define TIME 258
+#define INTEGER 259
+#define STRING 260
+#define DEBUG 261
+#define USER 262
+#define GROUP 263
+#define PID_FILE 264
+#define MAILER 265
+#define TIMESTAMP_FORMAT 266
+#define RRD 267
+#define STATUS 268
+#define ALARM 269
+#define TARGET 270
+#define OVERRIDE 271
+#define DEFAULT 272
+#define MAILTO 273
+#define MAILFROM 274
+#define MAILENVFROM 275
+#define MAILSUBJECT 276
+#define COMMAND 277
+#define PIPE 278
+#define COMBINE 279
+#define REPEAT 280
+#define DOWN 281
+#define LOSS 282
+#define DELAY 283
+#define TIME_ 284
+#define PERCENT_LOW 285
+#define PERCENT_HIGH 286
+#define DELAY_LOW 287
+#define DELAY_HIGH 288
+#define DESCRIPTION 289
+#define SRCIP 290
+#define ALARMS 291
+#define FORCE_DOWN 292
+#define INTERVAL 293
+#define AVG_DELAY_SAMPLES 294
+#define AVG_LOSS_SAMPLES 295
+#define AVG_LOSS_DELAY_SAMPLES 296
+#define FILE_ 297
+#define ERROR 298
+#define ON 299
+#define OFF 300
+#define YES 301
+#define NO 302
+#define TRUE 303
+#define FALSE 304
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+{
+/* Line 2058 of yacc.c  */
+#line 51 "cfgparser1.y"
 
-#ifndef YYSTYPE
-typedef union {
 	int i;
 	char *s;
 	struct alarm_cfg *a;
 	struct target_cfg *t;
 	struct config *c;
 	struct alarm_list *al;
-} yystype;
-# define YYSTYPE yystype
+
+
+/* Line 2058 of yacc.c  */
+#line 165 "y.tab.h"
+} YYSTYPE;
 # define YYSTYPE_IS_TRIVIAL 1
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
 #endif
 
-#ifndef YYLTYPE
-typedef struct yyltype
+#if ! defined YYLTYPE && ! defined YYLTYPE_IS_DECLARED
+typedef struct YYLTYPE
 {
   int first_line;
   int first_column;
-
   int last_line;
   int last_column;
-} yyltype;
-
-# define YYLTYPE yyltype
+} YYLTYPE;
+# define yyltype YYLTYPE /* obsolescent; will be withdrawn */
+# define YYLTYPE_IS_DECLARED 1
 # define YYLTYPE_IS_TRIVIAL 1
 #endif
 
-# define	TIME	258
-# define	INTEGER	259
-# define	STRING	260
-# define	DEBUG	261
-# define	USER	262
-# define	GROUP	263
-# define	PID_FILE	264
-# define	MAILER	265
-# define	TIMESTAMP_FORMAT	266
-# define	RRD	267
-# define	STATUS	268
-# define	ALARM	269
-# define	TARGET	270
-# define	OVERRIDE	271
-# define	DEFAULT	272
-# define	MAILTO	273
-# define	MAILFROM	274
-# define	MAILENVFROM	275
-# define	MAILSUBJECT	276
-# define	COMMAND	277
-# define	PIPE	278
-# define	COMBINE	279
-# define	REPEAT	280
-# define	DOWN	281
-# define	LOSS	282
-# define	DELAY	283
-# define	TIME_	284
-# define	PERCENT_LOW	285
-# define	PERCENT_HIGH	286
-# define	DELAY_LOW	287
-# define	DELAY_HIGH	288
-# define	DESCRIPTION	289
-# define	SRCIP	290
-# define	ALARMS	291
-# define	INTERVAL	292
-# define	AVG_DELAY_SAMPLES	293
-# define	AVG_LOSS_SAMPLES	294
-# define	AVG_LOSS_DELAY_SAMPLES	295
-# define	FILE_	296
-# define	ERROR	297
-# define	ON	298
-# define	OFF	299
-# define	YES	300
-# define	NO	301
-# define	TRUE	302
-# define	FALSE	303
-
-
 extern YYSTYPE yylval;
+extern YYLTYPE yylloc;
+#ifdef YYPARSE_PARAM
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void *YYPARSE_PARAM);
+#else
+int yyparse ();
+#endif
+#else /* ! YYPARSE_PARAM */
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void);
+#else
+int yyparse ();
+#endif
+#endif /* ! YYPARSE_PARAM */
 
-#endif /* not BISON_Y_TAB_H */
+#endif /* !YY_YY_Y_TAB_H_INCLUDED  */
diff -ruN ../apinger-0.6.1-patched/src/cfgparser1.y ./src/cfgparser1.y
--- ../apinger-0.6.1-patched/src/cfgparser1.y	2014-01-06 10:06:42.671168484 -0200
+++ ./src/cfgparser1.y	2014-01-06 11:15:02.510642209 -0200
@@ -99,6 +99,7 @@
 %token DESCRIPTION
 %token SRCIP
 %token ALARMS
+%token FORCE_DOWN
 %token INTERVAL
 %token AVG_DELAY_SAMPLES
 %token AVG_LOSS_SAMPLES
@@ -255,6 +256,8 @@
 		{ cur_target->alarms=$2; }
 	| ALARMS OVERRIDE alarmlist
 		{ cur_target->alarms_override=1; cur_target->alarms=$3; }
+	| FORCE_DOWN boolean
+		{ cur_target->force_down=$2; }
 	| INTERVAL INTEGER
 		{ cur_target->interval=$2; }
 	| INTERVAL TIME
diff -ruN ../apinger-0.6.1-patched/src/cfgparser2.c ./src/cfgparser2.c
--- ../apinger-0.6.1-patched/src/cfgparser2.c	2003-03-26 08:35:05.000000000 -0300
+++ ./src/cfgparser2.c	2014-01-06 13:12:45.799761783 -0200
@@ -1,67 +1,113 @@
-/* A lexical scanner generated by flex */
 
-/* Scanner skeleton version:
- * $Header: /home/daffy/u0/vern/flex/RCS/flex.skl,v 2.91 96/09/10 16:58:48 vern Exp $
- */
+#line 3 "lex.yy.c"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
 
 #define FLEX_SCANNER
 #define YY_FLEX_MAJOR_VERSION 2
 #define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 37
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
 
+/* begin standard C headers. */
 #include <stdio.h>
-#include <unistd.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
 
+/* end standard C headers. */
 
-/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
-#ifdef c_plusplus
-#ifndef __cplusplus
-#define __cplusplus
-#endif
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
 #endif
 
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
 
-#ifdef __cplusplus
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
 
-#include <stdlib.h>
+#endif /* ! C99 */
+
+#endif /* ! FLEXINT_H */
 
-/* Use prototypes in function declarations. */
-#define YY_USE_PROTOS
+#ifdef __cplusplus
 
 /* The "const" storage-class-modifier is valid. */
 #define YY_USE_CONST
 
 #else	/* ! __cplusplus */
 
-#if __STDC__
+/* C99 requires __STDC__ to be defined as 1. */
+#if defined (__STDC__)
 
-#define YY_USE_PROTOS
 #define YY_USE_CONST
 
-#endif	/* __STDC__ */
+#endif	/* defined (__STDC__) */
 #endif	/* ! __cplusplus */
 
-#ifdef __TURBOC__
- #pragma warn -rch
- #pragma warn -use
-#include <io.h>
-#include <stdlib.h>
-#define YY_USE_CONST
-#define YY_USE_PROTOS
-#endif
-
 #ifdef YY_USE_CONST
 #define yyconst const
 #else
 #define yyconst
 #endif
 
-
-#ifdef YY_USE_PROTOS
-#define YY_PROTO(proto) proto
-#else
-#define YY_PROTO(proto) ()
-#endif
-
 /* Returned upon end-of-file. */
 #define YY_NULL 0
 
@@ -76,71 +122,70 @@
  * but we do it the disgusting crufty way forced on us by the ()-less
  * definition of BEGIN.
  */
-#define BEGIN yy_start = 1 + 2 *
+#define BEGIN (yy_start) = 1 + 2 *
 
 /* Translate the current start state into a value that can be later handed
  * to BEGIN to return to the state.  The YYSTATE alias is for lex
  * compatibility.
  */
-#define YY_START ((yy_start - 1) / 2)
+#define YY_START (((yy_start) - 1) / 2)
 #define YYSTATE YY_START
 
 /* Action number for EOF rule of a given start state. */
 #define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
 
 /* Special action meaning "start processing a new file". */
-#define YY_NEW_FILE yyrestart( yyin )
+#define YY_NEW_FILE yyrestart(yyin  )
 
 #define YY_END_OF_BUFFER_CHAR 0
 
 /* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
 #define YY_BUF_SIZE 16384
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
 
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
 typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef size_t yy_size_t;
+#endif
+
+extern yy_size_t yyleng;
 
-extern int yyleng;
 extern FILE *yyin, *yyout;
 
 #define EOB_ACT_CONTINUE_SCAN 0
 #define EOB_ACT_END_OF_FILE 1
 #define EOB_ACT_LAST_MATCH 2
 
-/* The funky do-while in the following #define is used to turn the definition
- * int a single C statement (which needs a semi-colon terminator).  This
- * avoids problems with code like:
- *
- * 	if ( condition_holds )
- *		yyless( 5 );
- *	else
- *		do_something_else();
- *
- * Prior to using the do-while the compiler would get upset at the
- * "else" because it interpreted the "if" statement as being all
- * done when it reached the ';' after the yyless() call.
- */
-
-/* Return all but the first 'n' matched characters back to the input stream. */
-
+    #define YY_LESS_LINENO(n)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
 #define yyless(n) \
 	do \
 		{ \
 		/* Undo effects of setting up yytext. */ \
-		*yy_cp = yy_hold_char; \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
 		YY_RESTORE_YY_MORE_OFFSET \
-		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
 		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
 		} \
 	while ( 0 )
 
-#define unput(c) yyunput( c, yytext_ptr )
-
-/* The following is because we cannot portably get our hands on size_t
- * (without autoconf's help, which isn't available because we want
- * flex-generated scanners to compile on their own).
- */
-typedef unsigned int yy_size_t;
-
+#define unput(c) yyunput( c, (yytext_ptr)  )
 
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
 struct yy_buffer_state
 	{
 	FILE *yy_input_file;
@@ -156,7 +201,7 @@
 	/* Number of characters read into yy_ch_buf, not including EOB
 	 * characters.
 	 */
-	int yy_n_chars;
+	yy_size_t yy_n_chars;
 
 	/* Whether we "own" the buffer - i.e., we know we created it,
 	 * and can realloc() it to grow it, and should free() it to
@@ -177,12 +222,16 @@
 	 */
 	int yy_at_bol;
 
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
 	/* Whether to try to fill the input buffer when we reach the
 	 * end of it.
 	 */
 	int yy_fill_buffer;
 
 	int yy_buffer_status;
+
 #define YY_BUFFER_NEW 0
 #define YY_BUFFER_NORMAL 1
 	/* When an EOF's been seen but there's still some text to process
@@ -196,28 +245,38 @@
 	 * just pointing yyin at a new input file.
 	 */
 #define YY_BUFFER_EOF_PENDING 2
+
 	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
 
-static YY_BUFFER_STATE yy_current_buffer = 0;
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
 
 /* We provide macros for accessing buffer states in case in the
  * future we want to put the buffer states in a more general
  * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
  */
-#define YY_CURRENT_BUFFER yy_current_buffer
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
 
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
 
 /* yy_hold_char holds the character lost when yytext is formed. */
 static char yy_hold_char;
-
-static int yy_n_chars;		/* number of characters read into yy_ch_buf */
-
-
-int yyleng;
+static yy_size_t yy_n_chars;		/* number of characters read into yy_ch_buf */
+yy_size_t yyleng;
 
 /* Points to current character in buffer. */
 static char *yy_c_buf_p = (char *) 0;
-static int yy_init = 1;		/* whether we need to initialize */
+static int yy_init = 0;		/* whether we need to initialize */
 static int yy_start = 0;	/* start state number */
 
 /* Flag which is used to allow yywrap()'s to do buffer switches
@@ -225,100 +284,127 @@
  */
 static int yy_did_buffer_switch_on_eof;
 
-void yyrestart YY_PROTO(( FILE *input_file ));
-
-void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
-void yy_load_buffer_state YY_PROTO(( void ));
-YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
-void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
-void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
-void yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));
-#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )
-
-YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));
-YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *yy_str ));
-YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));
-
-static void *yy_flex_alloc YY_PROTO(( yy_size_t ));
-static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t ));
-static void yy_flex_free YY_PROTO(( void * ));
+void yyrestart (FILE *input_file  );
+void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );
+void yy_delete_buffer (YY_BUFFER_STATE b  );
+void yy_flush_buffer (YY_BUFFER_STATE b  );
+void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );
+void yypop_buffer_state (void );
+
+static void yyensure_buffer_stack (void );
+static void yy_load_buffer_state (void );
+static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );
+
+#define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );
+YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );
+YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,yy_size_t len  );
+
+void *yyalloc (yy_size_t  );
+void *yyrealloc (void *,yy_size_t  );
+void yyfree (void *  );
 
 #define yy_new_buffer yy_create_buffer
 
 #define yy_set_interactive(is_interactive) \
 	{ \
-	if ( ! yy_current_buffer ) \
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
-	yy_current_buffer->yy_is_interactive = is_interactive; \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer(yyin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
 	}
 
 #define yy_set_bol(at_bol) \
 	{ \
-	if ( ! yy_current_buffer ) \
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
-	yy_current_buffer->yy_at_bol = at_bol; \
+	if ( ! YY_CURRENT_BUFFER ){\
+        yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer(yyin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
 	}
 
-#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
 
+/* Begin user sect3 */
 
 #define yywrap() 1
 #define YY_SKIP_YYWRAP
+
 typedef unsigned char YY_CHAR;
+
 FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
+
 typedef int yy_state_type;
+
+extern int yylineno;
+
+int yylineno = 1;
+
 extern char *yytext;
 #define yytext_ptr yytext
 
-static yy_state_type yy_get_previous_state YY_PROTO(( void ));
-static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
-static int yy_get_next_buffer YY_PROTO(( void ));
-static void yy_fatal_error YY_PROTO(( yyconst char msg[] ));
+static yy_state_type yy_get_previous_state (void );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+static int yy_get_next_buffer (void );
+static void yy_fatal_error (yyconst char msg[]  );
 
 /* Done after the current pattern has been matched and before the
  * corresponding action - sets up yytext.
  */
 #define YY_DO_BEFORE_ACTION \
-	yytext_ptr = yy_bp; \
-	yyleng = (int) (yy_cp - yy_bp); \
-	yy_hold_char = *yy_cp; \
+	(yytext_ptr) = yy_bp; \
+	yyleng = (size_t) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
 	*yy_cp = '\0'; \
-	yy_c_buf_p = yy_cp;
+	(yy_c_buf_p) = yy_cp;
 
-#define YY_NUM_RULES 51
-#define YY_END_OF_BUFFER 52
-static yyconst short int yy_accept[248] =
+#define YY_NUM_RULES 53
+#define YY_END_OF_BUFFER 54
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static yyconst flex_int16_t yy_accept[261] =
     {   0,
-        0,    0,   52,   50,   49,   46,   50,   48,   45,   50,
-        1,   50,   50,   50,   50,   50,   50,   50,   50,   50,
-       50,   50,   50,   50,   50,   50,   50,   49,    0,   44,
-       48,   47,    0,    1,    2,    2,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,   27,    0,
-       29,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,   47,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,   28,    0,
-        0,    0,    0,    0,   36,    0,    0,    0,    0,    0,
-       43,    0,    0,    0,    0,    0,    0,    0,    0,   16,
-
-        0,   18,    0,    0,   21,    0,    0,    0,    0,   34,
-        0,    0,    0,   39,   41,   42,    3,    0,    0,    0,
-        0,   10,    0,   12,    0,   17,   19,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    4,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,   23,
-        0,    0,   26,    0,    0,    0,   35,   37,   38,    0,
-        0,    0,    8,    9,   11,    0,    0,    0,    0,    0,
+        0,    0,   54,   52,   51,   48,   52,   50,   47,   52,
+        1,   52,   52,   52,   52,   52,   52,   52,   52,   52,
+       52,   52,   52,   52,   52,   52,   52,   51,    0,   46,
+       50,   49,    0,    1,    2,    2,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,   29,
+        0,   31,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,   49,    0,    0,    0,    0,    0,
         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,   20,    0,   24,    0,   30,    0,   33,    0,    0,
-        0,    0,   14,    0,    0,    0,    0,    0,    0,    0,
+        0,   30,    0,    0,    0,    0,    0,   38,    0,    0,
+        0,    0,    0,    0,   45,    0,    0,    0,    0,    0,
 
-        0,    0,   13,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,   15,   22,   25,    0,   32,    0,    0,    0,
-        0,   31,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    7,   40,    5,
-        0,    0,    0,    0,    0,    6,    0
+        0,    0,    0,   17,    0,   19,    0,    0,    0,   23,
+        0,    0,    0,    0,   36,    0,    0,    0,    0,   41,
+       43,   44,    3,    0,    0,    0,    0,   10,    0,   12,
+        0,   18,    0,   21,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,   16,    0,    0,    0,    4,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,   25,    0,
+        0,   28,    0,    0,    0,   37,   39,   40,    0,    0,
+        0,    8,    9,   11,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,   22,    0,   26,    0,   32,    0,   35,    0,
+
+        0,    0,    0,   14,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,   13,    0,   20,    0,    0,    0,
+        0,    0,    0,    0,    0,   15,   24,   27,    0,   34,
+        0,    0,    0,    0,   33,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        7,   42,    5,    0,    0,    0,    0,    0,    6,    0
     } ;
 
-static yyconst int yy_ec[256] =
+static yyconst flex_int32_t yy_ec[256] =
     {   0,
         1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
@@ -350,7 +436,7 @@
         1,    1,    1,    1,    1
     } ;
 
-static yyconst int yy_meta[33] =
+static yyconst flex_int32_t yy_meta[33] =
     {   0,
         1,    1,    2,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
@@ -358,145 +444,154 @@
         1,    1
     } ;
 
-static yyconst short int yy_base[251] =
+static yyconst flex_int16_t yy_base[264] =
     {   0,
-        0,    0,  259,  260,  256,  260,  253,    0,  260,  248,
-       26,   13,  231,   21,   27,  228,  230,  228,  240,  226,
-       24,   22,   24,  221,   38,  221,  232,  244,  241,  260,
-        0,    0,  235,    0,  260,  216,  215,  230,  223,  217,
-       40,  207,  216,  215,  211,  206,  206,  213,  260,  215,
-      260,  215,  203,   37,  203,  213,  215,  199,  202,  194,
-      207,  194,    0,   51,  194,  209,   47,  189,  206,  205,
-      202,  191,  186,  197,  182,  195,  182,  187,  260,  181,
-      193,  195,  189,  188,  260,  174,  184,  185,  184,  172,
-      260,  175,   49,  177,  184,  177,  164,  160,  165,  260,
-
-      175,  260,  164,  162,  260,   50,  161,  171,  169,  260,
-      173,  154,  167,  154,  260,  260,  153,  164,  154,  154,
-      153,  260,  154,  164,  154,  260,  260,  142,   45,  145,
-      141,  145,  149,  144,  147,  137,  137,  135,  134,  260,
-      140,  133,  144,  144,  129,   54,  131,  144,  124,  260,
-      129,  140,  260,  137,  122,  128,  260,  260,  260,  137,
-      136,  119,  260,  260,  260,  126,  120,  115,  121,  125,
-      118,  119,  123,  127,  121,  113,  102,  123,  115,  100,
-      111,  260,  103,  260,  113,  260,   55,  260,  102,  116,
-       60,  107,  260,  100,   99,  109,  102,   96,  109,   91,
-
-      102,  105,  260,   92,   92,   85,   95,   80,   94,   98,
-       87,   85,  260,  260,  260,   88,  260,   81,   82,   92,
-       77,  260,   75,   75,   67,   77,   75,   75,   85,   79,
-       82,   77,   64,   63,   61,   61,   75,  260,  260,  260,
-       63,   59,   62,   67,   54,  260,  260,   79,   78,   41
+        0,    0,  272,  273,  269,  273,  266,    0,  273,  261,
+       26,   13,  244,   21,   27,  241,  243,  241,  253,  239,
+       24,   22,   24,   30,   38,  235,  246,  258,  255,  273,
+        0,    0,  249,    0,  273,  230,  229,  244,  237,  231,
+       47,  221,  230,  229,  223,  224,  219,  219,  226,  273,
+      228,  273,  228,  216,   46,  216,  226,  226,  227,  211,
+      214,  206,  219,  206,    0,   58,  206,  221,   30,  201,
+      218,  217,  214,  203,  198,  209,  210,  193,  206,  193,
+      198,  273,  192,  204,  206,  200,  199,  273,  194,  184,
+      194,  195,  194,  182,  273,  185,   48,  187,  194,  187,
+
+      174,  170,  175,  273,  185,  273,  184,  173,  171,  273,
+       57,  170,  180,  178,  273,  182,  167,  162,  175,  162,
+      273,  273,  161,  172,  162,  162,  161,  273,  162,  172,
+      162,  273,  170,  273,  149,   52,  152,  148,  152,  156,
+      151,  154,  144,  273,  144,  142,  141,  273,  147,  140,
+      151,  151,  136,   58,  138,  148,  150,  130,  273,  135,
+      146,  273,  143,  128,  134,  273,  273,  273,  143,  142,
+      125,  273,  273,  273,  132,  126,  121,  124,  126,  130,
+      123,  124,  128,  132,  126,  118,  107,  128,  120,  105,
+      116,  103,  273,  107,  273,  117,  273,   59,  273,  106,
+
+      120,   56,  111,  273,  104,  104,  102,  112,  105,   99,
+      112,   94,  105,  108,  273,   95,  273,   95,   88,   98,
+       83,   97,  101,   90,   88,  273,  273,  273,   91,  273,
+       84,   85,   95,   80,  273,   78,   78,   70,   80,   78,
+       78,   88,   82,   85,   80,   67,   66,   64,   64,   79,
+      273,  273,  273,   67,   63,   66,   71,   55,  273,  273,
+       80,   65,   60
     } ;
 
-static yyconst short int yy_def[251] =
+static yyconst flex_int16_t yy_def[264] =
     {   0,
-      247,    1,  247,  247,  247,  247,  248,  249,  247,  247,
-      247,  247,  247,  247,  247,  247,  247,  247,  247,  247,
-      247,  247,  247,  247,  247,  247,  247,  247,  248,  247,
-      249,  250,  247,   11,  247,  247,  247,  247,  247,  247,
-      247,  247,  247,  247,  247,  247,  247,  247,  247,  247,
-      247,  247,  247,  247,  247,  247,  247,  247,  247,  247,
-      247,  247,  250,   11,  247,  247,  247,  247,  247,  247,
-      247,  247,  247,  247,  247,  247,  247,  247,  247,  247,
-      247,  247,  247,  247,  247,  247,  247,  247,  247,  247,
-      247,  247,  247,  247,  247,  247,  247,  247,  247,  247,
-
-      247,  247,  247,  247,  247,  247,  247,  247,  247,  247,
-      247,  247,  247,  247,  247,  247,  247,  247,  247,  247,
-      247,  247,  247,  247,  247,  247,  247,  247,  247,  247,
-      247,  247,  247,  247,  247,  247,  247,  247,  247,  247,
-      247,  247,  247,  247,  247,  247,  247,  247,  247,  247,
-      247,  247,  247,  247,  247,  247,  247,  247,  247,  247,
-      247,  247,  247,  247,  247,  247,  247,  247,  247,  247,
-      247,  247,  247,  247,  247,  247,  247,  247,  247,  247,
-      247,  247,  247,  247,  247,  247,  247,  247,  247,  247,
-      247,  247,  247,  247,  247,  247,  247,  247,  247,  247,
-
-      247,  247,  247,  247,  247,  247,  247,  247,  247,  247,
-      247,  247,  247,  247,  247,  247,  247,  247,  247,  247,
-      247,  247,  247,  247,  247,  247,  247,  247,  247,  247,
-      247,  247,  247,  247,  247,  247,  247,  247,  247,  247,
-      247,  247,  247,  247,  247,  247,    0,  247,  247,  247
+      260,    1,  260,  260,  260,  260,  261,  262,  260,  260,
+      260,  260,  260,  260,  260,  260,  260,  260,  260,  260,
+      260,  260,  260,  260,  260,  260,  260,  260,  261,  260,
+      262,  263,  260,   11,  260,  260,  260,  260,  260,  260,
+      260,  260,  260,  260,  260,  260,  260,  260,  260,  260,
+      260,  260,  260,  260,  260,  260,  260,  260,  260,  260,
+      260,  260,  260,  260,  263,   11,  260,  260,  260,  260,
+      260,  260,  260,  260,  260,  260,  260,  260,  260,  260,
+      260,  260,  260,  260,  260,  260,  260,  260,  260,  260,
+      260,  260,  260,  260,  260,  260,  260,  260,  260,  260,
+
+      260,  260,  260,  260,  260,  260,  260,  260,  260,  260,
+      260,  260,  260,  260,  260,  260,  260,  260,  260,  260,
+      260,  260,  260,  260,  260,  260,  260,  260,  260,  260,
+      260,  260,  260,  260,  260,  260,  260,  260,  260,  260,
+      260,  260,  260,  260,  260,  260,  260,  260,  260,  260,
+      260,  260,  260,  260,  260,  260,  260,  260,  260,  260,
+      260,  260,  260,  260,  260,  260,  260,  260,  260,  260,
+      260,  260,  260,  260,  260,  260,  260,  260,  260,  260,
+      260,  260,  260,  260,  260,  260,  260,  260,  260,  260,
+      260,  260,  260,  260,  260,  260,  260,  260,  260,  260,
+
+      260,  260,  260,  260,  260,  260,  260,  260,  260,  260,
+      260,  260,  260,  260,  260,  260,  260,  260,  260,  260,
+      260,  260,  260,  260,  260,  260,  260,  260,  260,  260,
+      260,  260,  260,  260,  260,  260,  260,  260,  260,  260,
+      260,  260,  260,  260,  260,  260,  260,  260,  260,  260,
+      260,  260,  260,  260,  260,  260,  260,  260,  260,    0,
+      260,  260,  260
     } ;
 
-static yyconst short int yy_nxt[293] =
+static yyconst flex_int16_t yy_nxt[306] =
     {   0,
         4,    5,    6,    7,    8,    9,    4,   10,   11,    4,
        12,    4,   13,   14,    4,   15,   16,    4,   17,    4,
        18,   19,   20,   21,   22,   23,   24,   25,   26,    4,
-        4,   27,   33,   38,   34,   41,   53,   43,   55,   50,
-       54,   63,   39,   35,   42,   44,   51,   36,   58,   56,
-       82,   68,   35,   52,   37,   69,   59,  247,   94,   64,
-       70,   83,  118,   60,  129,  130,   71,  149,   95,  119,
-      150,  166,  197,  201,  167,  198,  131,  132,   31,   29,
-      246,  245,  244,  243,  242,  241,  202,  240,  239,  238,
-      237,  236,  235,  234,  233,  232,  231,  230,  229,  228,
-
-      227,  226,  225,  224,  223,  222,  221,  220,  219,  218,
-      217,  216,  215,  214,  213,  212,  211,  210,  209,  208,
-      207,  206,  205,  204,  203,  200,  199,  196,  195,  194,
-      193,  192,  191,  190,  189,  188,  187,  186,  185,  184,
-      183,  182,  181,  180,  179,  178,  177,  176,  175,  174,
-      173,  172,  171,  170,  169,  168,  165,  164,  163,  162,
-      161,  160,  159,  158,  157,  156,  155,  154,  153,  152,
-      151,  148,  147,  146,  145,  144,  143,  142,  141,  140,
-      139,  138,  137,  136,  135,  134,  133,  128,  127,  126,
-      125,  124,  123,  122,  121,  120,  117,  116,  115,  114,
-
-      113,  112,  111,  110,  109,  108,  107,  106,  105,  104,
-      103,  102,  101,  100,   99,   98,   97,   96,   93,   92,
-       91,   90,   89,   88,   87,   86,   85,   84,   81,   80,
-       79,   78,   77,   76,   75,   74,   73,   72,   67,   66,
-       65,   35,   35,   64,   30,   28,   62,   61,   57,   49,
-       48,   47,   46,   45,   40,   32,   30,   28,  247,    3,
-      247,  247,  247,  247,  247,  247,  247,  247,  247,  247,
-      247,  247,  247,  247,  247,  247,  247,  247,  247,  247,
-      247,  247,  247,  247,  247,  247,  247,  247,  247,  247,
-      247,  247
+        4,   27,   33,   38,   34,   41,   54,   43,   56,   51,
+       55,   98,   39,   35,   42,   44,   52,   36,   60,   57,
+       45,   99,   35,   53,   37,   58,   61,   59,   70,   85,
+       65,  124,   71,   62,  260,   31,   66,   72,  125,  213,
+       86,  136,  137,   73,  158,  175,  209,  159,  176,  210,
+       29,  259,  214,  138,  139,  258,  257,  256,  255,  254,
+      253,  252,  251,  250,  249,  248,  247,  246,  245,  244,
+
+      243,  242,  241,  240,  239,  238,  237,  236,  235,  234,
+      233,  232,  231,  230,  229,  228,  227,  226,  225,  224,
+      223,  222,  221,  220,  219,  218,  217,  216,  215,  212,
+      211,  208,  207,  206,  205,  204,  203,  202,  201,  200,
+      199,  198,  197,  196,  195,  194,  193,  192,  191,  190,
+      189,  188,  187,  186,  185,  184,  183,  182,  181,  180,
+      179,  178,  177,  174,  173,  172,  171,  170,  169,  168,
+      167,  166,  165,  164,  163,  162,  161,  160,  157,  156,
+      155,  154,  153,  152,  151,  150,  149,  148,  147,  146,
+      145,  144,  143,  142,  141,  140,  135,  134,  133,  132,
+
+      131,  130,  129,  128,  127,  126,  123,  122,  121,  120,
+      119,  118,  117,  116,  115,  114,  113,  112,  111,  110,
+      109,  108,  107,  106,  105,  104,  103,  102,  101,  100,
+       97,   96,   95,   94,   93,   92,   91,   90,   89,   88,
+       87,   84,   83,   82,   81,   80,   79,   78,   77,   76,
+       75,   74,   69,   68,   67,   35,   35,   66,   30,   28,
+       64,   63,   50,   49,   48,   47,   46,   40,   32,   30,
+       28,  260,    3,  260,  260,  260,  260,  260,  260,  260,
+      260,  260,  260,  260,  260,  260,  260,  260,  260,  260,
+      260,  260,  260,  260,  260,  260,  260,  260,  260,  260,
 
+      260,  260,  260,  260,  260
     } ;
 
-static yyconst short int yy_chk[293] =
+static yyconst flex_int16_t yy_chk[306] =
     {   0,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,   11,   12,   11,   14,   22,   15,   23,   21,
-       22,  250,   12,   11,   14,   15,   21,   11,   25,   23,
-       54,   41,   11,   21,   11,   41,   25,   64,   67,   64,
-       41,   54,   93,   25,  106,  106,   41,  129,   67,   93,
-      129,  146,  187,  191,  146,  187,  106,  106,  249,  248,
-      245,  244,  243,  242,  241,  237,  191,  236,  235,  234,
-      233,  232,  231,  230,  229,  228,  227,  226,  225,  224,
-
-      223,  221,  220,  219,  218,  216,  212,  211,  210,  209,
-      208,  207,  206,  205,  204,  202,  201,  200,  199,  198,
-      197,  196,  195,  194,  192,  190,  189,  185,  183,  181,
-      180,  179,  178,  177,  176,  175,  174,  173,  172,  171,
-      170,  169,  168,  167,  166,  162,  161,  160,  156,  155,
-      154,  152,  151,  149,  148,  147,  145,  144,  143,  142,
-      141,  139,  138,  137,  136,  135,  134,  133,  132,  131,
-      130,  128,  125,  124,  123,  121,  120,  119,  118,  117,
-      114,  113,  112,  111,  109,  108,  107,  104,  103,  101,
-       99,   98,   97,   96,   95,   94,   92,   90,   89,   88,
-
-       87,   86,   84,   83,   82,   81,   80,   78,   77,   76,
-       75,   74,   73,   72,   71,   70,   69,   68,   66,   65,
-       62,   61,   60,   59,   58,   57,   56,   55,   53,   52,
-       50,   48,   47,   46,   45,   44,   43,   42,   40,   39,
-       38,   37,   36,   33,   29,   28,   27,   26,   24,   20,
-       19,   18,   17,   16,   13,   10,    7,    5,    3,  247,
-      247,  247,  247,  247,  247,  247,  247,  247,  247,  247,
-      247,  247,  247,  247,  247,  247,  247,  247,  247,  247,
-      247,  247,  247,  247,  247,  247,  247,  247,  247,  247,
-      247,  247
+       22,   69,   12,   11,   14,   15,   21,   11,   25,   23,
+       15,   69,   11,   21,   11,   24,   25,   24,   41,   55,
+      263,   97,   41,   25,   66,  262,   66,   41,   97,  202,
+       55,  111,  111,   41,  136,  154,  198,  136,  154,  198,
+      261,  258,  202,  111,  111,  257,  256,  255,  254,  250,
+      249,  248,  247,  246,  245,  244,  243,  242,  241,  240,
+
+      239,  238,  237,  236,  234,  233,  232,  231,  229,  225,
+      224,  223,  222,  221,  220,  219,  218,  216,  214,  213,
+      212,  211,  210,  209,  208,  207,  206,  205,  203,  201,
+      200,  196,  194,  192,  191,  190,  189,  188,  187,  186,
+      185,  184,  183,  182,  181,  180,  179,  178,  177,  176,
+      175,  171,  170,  169,  165,  164,  163,  161,  160,  158,
+      157,  156,  155,  153,  152,  151,  150,  149,  147,  146,
+      145,  143,  142,  141,  140,  139,  138,  137,  135,  133,
+      131,  130,  129,  127,  126,  125,  124,  123,  120,  119,
+      118,  117,  116,  114,  113,  112,  109,  108,  107,  105,
+
+      103,  102,  101,  100,   99,   98,   96,   94,   93,   92,
+       91,   90,   89,   87,   86,   85,   84,   83,   81,   80,
+       79,   78,   77,   76,   75,   74,   73,   72,   71,   70,
+       68,   67,   64,   63,   62,   61,   60,   59,   58,   57,
+       56,   54,   53,   51,   49,   48,   47,   46,   45,   44,
+       43,   42,   40,   39,   38,   37,   36,   33,   29,   28,
+       27,   26,   20,   19,   18,   17,   16,   13,   10,    7,
+        5,    3,  260,  260,  260,  260,  260,  260,  260,  260,
+      260,  260,  260,  260,  260,  260,  260,  260,  260,  260,
+      260,  260,  260,  260,  260,  260,  260,  260,  260,  260,
 
+      260,  260,  260,  260,  260
     } ;
 
 static yy_state_type yy_last_accepting_state;
 static char *yy_last_accepting_cpos;
 
+extern int yy_flex_debug;
+int yy_flex_debug = 0;
+
 /* The intent behind this definition is that it'll catch
  * any uses of REJECT which flex missed.
  */
@@ -506,7 +601,6 @@
 #define YY_RESTORE_YY_MORE_OFFSET
 char *yytext;
 #line 1 "cfgparser2.l"
-#define INITIAL 0
 /*
  *  Alarm Pinger (c) 2002 Jacek Konieczny <jajcus@pld.org.pl>
  *
@@ -535,7 +629,52 @@
 #define LOCINC yylloc.last_column+=yyleng
 extern YYLTYPE yylloc;
 
-#line 539 "lex.yy.c"
+#line 633 "lex.yy.c"
+
+#define INITIAL 0
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+static int yy_init_globals (void );
+
+/* Accessor methods to globals.
+   These are made visible to non-reentrant scanners for convenience. */
+
+int yylex_destroy (void );
+
+int yyget_debug (void );
+
+void yyset_debug (int debug_flag  );
+
+YY_EXTRA_TYPE yyget_extra (void );
+
+void yyset_extra (YY_EXTRA_TYPE user_defined  );
+
+FILE *yyget_in (void );
+
+void yyset_in  (FILE * in_str  );
+
+FILE *yyget_out (void );
+
+void yyset_out  (FILE * out_str  );
+
+yy_size_t yyget_leng (void );
+
+char *yyget_text (void );
+
+int yyget_lineno (void );
+
+void yyset_lineno (int line_number  );
 
 /* Macros after this point can all be overridden by user definitions in
  * section 1.
@@ -543,65 +682,30 @@
 
 #ifndef YY_SKIP_YYWRAP
 #ifdef __cplusplus
-extern "C" int yywrap YY_PROTO(( void ));
+extern "C" int yywrap (void );
 #else
-extern int yywrap YY_PROTO(( void ));
-#endif
+extern int yywrap (void );
 #endif
-
-#ifndef YY_NO_UNPUT
-static void yyunput YY_PROTO(( int c, char *buf_ptr ));
 #endif
 
+    static void yyunput (int c,char *buf_ptr  );
+    
 #ifndef yytext_ptr
-static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));
+static void yy_flex_strncpy (char *,yyconst char *,int );
 #endif
 
 #ifdef YY_NEED_STRLEN
-static int yy_flex_strlen YY_PROTO(( yyconst char * ));
+static int yy_flex_strlen (yyconst char * );
 #endif
 
 #ifndef YY_NO_INPUT
-#ifdef __cplusplus
-static int yyinput YY_PROTO(( void ));
-#else
-static int input YY_PROTO(( void ));
-#endif
-#endif
-
-#if YY_STACK_USED
-static int yy_start_stack_ptr = 0;
-static int yy_start_stack_depth = 0;
-static int *yy_start_stack = 0;
-#ifndef YY_NO_PUSH_STATE
-static void yy_push_state YY_PROTO(( int new_state ));
-#endif
-#ifndef YY_NO_POP_STATE
-static void yy_pop_state YY_PROTO(( void ));
-#endif
-#ifndef YY_NO_TOP_STATE
-static int yy_top_state YY_PROTO(( void ));
-#endif
 
+#ifdef __cplusplus
+static int yyinput (void );
 #else
-#define YY_NO_PUSH_STATE 1
-#define YY_NO_POP_STATE 1
-#define YY_NO_TOP_STATE 1
+static int input (void );
 #endif
 
-#ifdef YY_MALLOC_DECL
-YY_MALLOC_DECL
-#else
-#if __STDC__
-#ifndef __cplusplus
-#include <stdlib.h>
-#endif
-#else
-/* Just try to get by without declaring the routines.  This will fail
- * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
- * or sizeof(void*) != sizeof(int).
- */
-#endif
 #endif
 
 /* Amount of stuff to slurp up with each read. */
@@ -610,12 +714,11 @@
 #endif
 
 /* Copy whatever the last rule matched to the standard output. */
-
 #ifndef ECHO
 /* This used to be an fputs(), but since the string might contain NUL's,
  * we now use fwrite().
  */
-#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
+#define ECHO do { if (fwrite( yytext, yyleng, 1, yyout )) {} } while (0)
 #endif
 
 /* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
@@ -623,9 +726,10 @@
  */
 #ifndef YY_INPUT
 #define YY_INPUT(buf,result,max_size) \
-	if ( yy_current_buffer->yy_is_interactive ) \
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
 		{ \
-		int c = '*', n; \
+		int c = '*'; \
+		size_t n; \
 		for ( n = 0; n < max_size && \
 			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
 			buf[n] = (char) c; \
@@ -635,9 +739,22 @@
 			YY_FATAL_ERROR( "input in flex scanner failed" ); \
 		result = n; \
 		} \
-	else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \
-		  && ferror( yyin ) ) \
-		YY_FATAL_ERROR( "input in flex scanner failed" );
+	else \
+		{ \
+		errno=0; \
+		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
+			{ \
+			if( errno != EINTR) \
+				{ \
+				YY_FATAL_ERROR( "input in flex scanner failed" ); \
+				break; \
+				} \
+			errno=0; \
+			clearerr(yyin); \
+			} \
+		}\
+\
+
 #endif
 
 /* No semi-colon after return; correct usage is to write "yyterminate();" -
@@ -658,12 +775,18 @@
 #define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
 #endif
 
+/* end tables serialization structures and prototypes */
+
 /* Default declaration of generated scanner - a define so the user can
  * easily add parameters.
  */
 #ifndef YY_DECL
-#define YY_DECL int yylex YY_PROTO(( void ))
-#endif
+#define YY_DECL_IS_OURS 1
+
+extern int yylex (void);
+
+#define YY_DECL int yylex (void)
+#endif /* !YY_DECL */
 
 /* Code executed at the beginning of each rule, after yytext and yyleng
  * have been set up.
@@ -680,27 +803,29 @@
 #define YY_RULE_SETUP \
 	YY_USER_ACTION
 
+/** The main scanner function which does all the work.
+ */
 YY_DECL
-	{
+{
 	register yy_state_type yy_current_state;
-	register char *yy_cp = NULL, *yy_bp = NULL;
+	register char *yy_cp, *yy_bp;
 	register int yy_act;
-
+    
 #line 37 "cfgparser2.l"
 
 
-#line 693 "lex.yy.c"
+#line 818 "lex.yy.c"
 
-	if ( yy_init )
+	if ( !(yy_init) )
 		{
-		yy_init = 0;
+		(yy_init) = 1;
 
 #ifdef YY_USER_INIT
 		YY_USER_INIT;
 #endif
 
-		if ( ! yy_start )
-			yy_start = 1;	/* first start state */
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
 
 		if ( ! yyin )
 			yyin = stdin;
@@ -708,68 +833,68 @@
 		if ( ! yyout )
 			yyout = stdout;
 
-		if ( ! yy_current_buffer )
-			yy_current_buffer =
-				yy_create_buffer( yyin, YY_BUF_SIZE );
+		if ( ! YY_CURRENT_BUFFER ) {
+			yyensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				yy_create_buffer(yyin,YY_BUF_SIZE );
+		}
 
-		yy_load_buffer_state();
+		yy_load_buffer_state( );
 		}
 
 	while ( 1 )		/* loops until end-of-file is reached */
 		{
-		yy_cp = yy_c_buf_p;
+		yy_cp = (yy_c_buf_p);
 
 		/* Support of yytext. */
-		*yy_cp = yy_hold_char;
+		*yy_cp = (yy_hold_char);
 
 		/* yy_bp points to the position in yy_ch_buf of the start of
 		 * the current run.
 		 */
 		yy_bp = yy_cp;
 
-		yy_current_state = yy_start;
+		yy_current_state = (yy_start);
 yy_match:
 		do
 			{
 			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
 			if ( yy_accept[yy_current_state] )
 				{
-				yy_last_accepting_state = yy_current_state;
-				yy_last_accepting_cpos = yy_cp;
+				(yy_last_accepting_state) = yy_current_state;
+				(yy_last_accepting_cpos) = yy_cp;
 				}
 			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
 				{
 				yy_current_state = (int) yy_def[yy_current_state];
-				if ( yy_current_state >= 248 )
+				if ( yy_current_state >= 261 )
 					yy_c = yy_meta[(unsigned int) yy_c];
 				}
 			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
 			++yy_cp;
 			}
-		while ( yy_base[yy_current_state] != 260 );
+		while ( yy_base[yy_current_state] != 273 );
 
 yy_find_action:
 		yy_act = yy_accept[yy_current_state];
 		if ( yy_act == 0 )
 			{ /* have to back up */
-			yy_cp = yy_last_accepting_cpos;
-			yy_current_state = yy_last_accepting_state;
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
 			yy_act = yy_accept[yy_current_state];
 			}
 
 		YY_DO_BEFORE_ACTION;
 
-
 do_action:	/* This label is used only to access EOF actions. */
 
-
 		switch ( yy_act )
 	{ /* beginning of action switch */
 			case 0: /* must back up */
 			/* undo the effects of YY_DO_BEFORE_ACTION */
-			*yy_cp = yy_hold_char;
-			yy_cp = yy_last_accepting_cpos;
-			yy_current_state = yy_last_accepting_state;
+			*yy_cp = (yy_hold_char);
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
 			goto yy_find_action;
 
 case 1:
@@ -879,213 +1004,224 @@
 case 16:
 YY_RULE_SETUP
 #line 85 "cfgparser2.l"
-{ LOC; LOCINC; return DOWN; }
+{ LOC; LOCINC; return SRCIP; }
 	YY_BREAK
 case 17:
 YY_RULE_SETUP
 #line 86 "cfgparser2.l"
-{ LOC; LOCINC; return FALSE; }
+{ LOC; LOCINC; return DOWN; }
 	YY_BREAK
 case 18:
 YY_RULE_SETUP
 #line 87 "cfgparser2.l"
-{ LOC; LOCINC; return FILE_; }
+{ LOC; LOCINC; return FALSE; }
 	YY_BREAK
 case 19:
 YY_RULE_SETUP
 #line 88 "cfgparser2.l"
-{ LOC; LOCINC; return GROUP; }
+{ LOC; LOCINC; return FILE_; }
 	YY_BREAK
 case 20:
 YY_RULE_SETUP
 #line 89 "cfgparser2.l"
-{ LOC; LOCINC; return INTERVAL; }
+{ LOC; LOCINC; return FORCE_DOWN; }
 	YY_BREAK
 case 21:
 YY_RULE_SETUP
 #line 90 "cfgparser2.l"
-{ LOC; LOCINC; return LOSS; }
+{ LOC; LOCINC; return GROUP; }
 	YY_BREAK
 case 22:
 YY_RULE_SETUP
 #line 91 "cfgparser2.l"
-{ LOC; LOCINC; return MAILENVFROM; }
+{ LOC; LOCINC; return INTERVAL; }
 	YY_BREAK
 case 23:
 YY_RULE_SETUP
 #line 92 "cfgparser2.l"
-{ LOC; LOCINC; return MAILER; }
+{ LOC; LOCINC; return LOSS; }
 	YY_BREAK
 case 24:
 YY_RULE_SETUP
 #line 93 "cfgparser2.l"
-{ LOC; LOCINC; return MAILFROM; }
+{ LOC; LOCINC; return MAILENVFROM; }
 	YY_BREAK
 case 25:
 YY_RULE_SETUP
 #line 94 "cfgparser2.l"
-{ LOC; LOCINC; return MAILSUBJECT; }
+{ LOC; LOCINC; return MAILER; }
 	YY_BREAK
 case 26:
 YY_RULE_SETUP
 #line 95 "cfgparser2.l"
-{ LOC; LOCINC; return MAILTO; }
+{ LOC; LOCINC; return MAILFROM; }
 	YY_BREAK
 case 27:
 YY_RULE_SETUP
 #line 96 "cfgparser2.l"
-{ LOC; LOCINC; return NO; }
+{ LOC; LOCINC; return MAILSUBJECT; }
 	YY_BREAK
 case 28:
 YY_RULE_SETUP
 #line 97 "cfgparser2.l"
-{ LOC; LOCINC; return OFF; }
+{ LOC; LOCINC; return MAILTO; }
 	YY_BREAK
 case 29:
 YY_RULE_SETUP
 #line 98 "cfgparser2.l"
-{ LOC; LOCINC; return ON; }
+{ LOC; LOCINC; return NO; }
 	YY_BREAK
 case 30:
 YY_RULE_SETUP
 #line 99 "cfgparser2.l"
-{ LOC; LOCINC; return OVERRIDE; }
+{ LOC; LOCINC; return OFF; }
 	YY_BREAK
 case 31:
 YY_RULE_SETUP
 #line 100 "cfgparser2.l"
-{ LOC; LOCINC; return PERCENT_HIGH; }
+{ LOC; LOCINC; return ON; }
 	YY_BREAK
 case 32:
 YY_RULE_SETUP
 #line 101 "cfgparser2.l"
-{ LOC; LOCINC; return PERCENT_LOW; }
+{ LOC; LOCINC; return OVERRIDE; }
 	YY_BREAK
 case 33:
 YY_RULE_SETUP
 #line 102 "cfgparser2.l"
-{ LOC; LOCINC; return PID_FILE; }
+{ LOC; LOCINC; return PERCENT_HIGH; }
 	YY_BREAK
 case 34:
 YY_RULE_SETUP
 #line 103 "cfgparser2.l"
-{ LOC; LOCINC; return PIPE; }
+{ LOC; LOCINC; return PERCENT_LOW; }
 	YY_BREAK
 case 35:
 YY_RULE_SETUP
 #line 104 "cfgparser2.l"
-{ LOC; LOCINC; return REPEAT; }
+{ LOC; LOCINC; return PID_FILE; }
 	YY_BREAK
 case 36:
 YY_RULE_SETUP
 #line 105 "cfgparser2.l"
-{ LOC; LOCINC; return RRD; }
+{ LOC; LOCINC; return PIPE; }
 	YY_BREAK
 case 37:
 YY_RULE_SETUP
 #line 106 "cfgparser2.l"
-{ LOC; LOCINC; return STATUS; }
+{ LOC; LOCINC; return REPEAT; }
 	YY_BREAK
 case 38:
 YY_RULE_SETUP
 #line 107 "cfgparser2.l"
-{ LOC; LOCINC; return TARGET; }
+{ LOC; LOCINC; return RRD; }
 	YY_BREAK
 case 39:
 YY_RULE_SETUP
 #line 108 "cfgparser2.l"
-{ LOC; LOCINC; return TIME_; }
+{ LOC; LOCINC; return STATUS; }
 	YY_BREAK
 case 40:
 YY_RULE_SETUP
 #line 109 "cfgparser2.l"
-{ LOC; LOCINC; return TIMESTAMP_FORMAT; }
+{ LOC; LOCINC; return TARGET; }
 	YY_BREAK
 case 41:
 YY_RULE_SETUP
 #line 110 "cfgparser2.l"
-{ LOC; LOCINC; return TRUE; }
+{ LOC; LOCINC; return TIME_; }
 	YY_BREAK
 case 42:
 YY_RULE_SETUP
 #line 111 "cfgparser2.l"
-{ LOC; LOCINC; return USER; }
+{ LOC; LOCINC; return TIMESTAMP_FORMAT; }
 	YY_BREAK
 case 43:
 YY_RULE_SETUP
 #line 112 "cfgparser2.l"
-{ LOC; LOCINC; return YES; }
+{ LOC; LOCINC; return TRUE; }
 	YY_BREAK
 case 44:
 YY_RULE_SETUP
-#line 114 "cfgparser2.l"
-{ LOC; LOCINC; yytext[yyleng-1]='\000'; yylval.s=yytext+1; return STRING; }
+#line 113 "cfgparser2.l"
+{ LOC; LOCINC; return USER; }
 	YY_BREAK
 case 45:
 YY_RULE_SETUP
-#line 116 "cfgparser2.l"
-{ LOC; LOCINC; return yytext[0]; }
+#line 114 "cfgparser2.l"
+{ LOC; LOCINC; return YES; }
 	YY_BREAK
 case 46:
 YY_RULE_SETUP
-#line 117 "cfgparser2.l"
-{ LOC; yylloc.last_line++; yylloc.last_column=0; return '\n'; }
+#line 116 "cfgparser2.l"
+{ LOC; LOCINC; yytext[yyleng-1]='\000'; yylval.s=yytext+1; return STRING; }
 	YY_BREAK
 case 47:
 YY_RULE_SETUP
-#line 119 "cfgparser2.l"
-{ LOC; LOCINC; } 
+#line 118 "cfgparser2.l"
+{ LOC; LOCINC; return yytext[0]; }
 	YY_BREAK
 case 48:
+/* rule 48 can match eol */
 YY_RULE_SETUP
-#line 120 "cfgparser2.l"
-{ LOC; LOCINC; }
+#line 119 "cfgparser2.l"
+{ LOC; yylloc.last_line++; yylloc.last_column=0; return '\n'; }
 	YY_BREAK
 case 49:
 YY_RULE_SETUP
+#line 121 "cfgparser2.l"
+{ LOC; LOCINC; } 
+	YY_BREAK
+case 50:
+YY_RULE_SETUP
 #line 122 "cfgparser2.l"
 { LOC; LOCINC; }
 	YY_BREAK
-case 50:
+case 51:
 YY_RULE_SETUP
 #line 124 "cfgparser2.l"
+{ LOC; LOCINC; }
+	YY_BREAK
+case 52:
+YY_RULE_SETUP
+#line 126 "cfgparser2.l"
 { LOC; LOCINC; yylval.s=yytext; 
 		  logit("Unexpected character: '%c'", yytext[0]);
 		  return ERROR;
 		}
 	YY_BREAK
-case 51:
+case 53:
 YY_RULE_SETUP
-#line 129 "cfgparser2.l"
+#line 131 "cfgparser2.l"
 ECHO;
 	YY_BREAK
-#line 1063 "lex.yy.c"
+#line 1199 "lex.yy.c"
 case YY_STATE_EOF(INITIAL):
 	yyterminate();
 
 	case YY_END_OF_BUFFER:
 		{
 		/* Amount of text matched not including the EOB char. */
-		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
 
 		/* Undo the effects of YY_DO_BEFORE_ACTION. */
-		*yy_cp = yy_hold_char;
+		*yy_cp = (yy_hold_char);
 		YY_RESTORE_YY_MORE_OFFSET
 
-		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
 			{
 			/* We're scanning a new file or input source.  It's
 			 * possible that this happened because the user
 			 * just pointed yyin at a new source and called
 			 * yylex().  If so, then we have to assure
-			 * consistency between yy_current_buffer and our
+			 * consistency between YY_CURRENT_BUFFER and our
 			 * globals.  Here is the right place to do so, because
 			 * this is the first action (other than possibly a
 			 * back-up) that will match for the new input source.
 			 */
-			yy_n_chars = yy_current_buffer->yy_n_chars;
-			yy_current_buffer->yy_input_file = yyin;
-			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
 			}
 
 		/* Note that here we test for yy_c_buf_p "<=" to the position
@@ -1095,13 +1231,13 @@
 		 * end-of-buffer state).  Contrast this with the test
 		 * in input().
 		 */
-		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
 			{ /* This was really a NUL. */
 			yy_state_type yy_next_state;
 
-			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
 
-			yy_current_state = yy_get_previous_state();
+			yy_current_state = yy_get_previous_state(  );
 
 			/* Okay, we're now positioned to make the NUL
 			 * transition.  We couldn't have
@@ -1114,30 +1250,30 @@
 
 			yy_next_state = yy_try_NUL_trans( yy_current_state );
 
-			yy_bp = yytext_ptr + YY_MORE_ADJ;
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
 
 			if ( yy_next_state )
 				{
 				/* Consume the NUL. */
-				yy_cp = ++yy_c_buf_p;
+				yy_cp = ++(yy_c_buf_p);
 				yy_current_state = yy_next_state;
 				goto yy_match;
 				}
 
 			else
 				{
-				yy_cp = yy_c_buf_p;
+				yy_cp = (yy_c_buf_p);
 				goto yy_find_action;
 				}
 			}
 
-		else switch ( yy_get_next_buffer() )
+		else switch ( yy_get_next_buffer(  ) )
 			{
 			case EOB_ACT_END_OF_FILE:
 				{
-				yy_did_buffer_switch_on_eof = 0;
+				(yy_did_buffer_switch_on_eof) = 0;
 
-				if ( yywrap() )
+				if ( yywrap( ) )
 					{
 					/* Note: because we've taken care in
 					 * yy_get_next_buffer() to have set up
@@ -1148,7 +1284,7 @@
 					 * YY_NULL, it'll still work - another
 					 * YY_NULL will get returned.
 					 */
-					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
 
 					yy_act = YY_STATE_EOF(YY_START);
 					goto do_action;
@@ -1156,30 +1292,30 @@
 
 				else
 					{
-					if ( ! yy_did_buffer_switch_on_eof )
+					if ( ! (yy_did_buffer_switch_on_eof) )
 						YY_NEW_FILE;
 					}
 				break;
 				}
 
 			case EOB_ACT_CONTINUE_SCAN:
-				yy_c_buf_p =
-					yytext_ptr + yy_amount_of_matched_text;
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
 
-				yy_current_state = yy_get_previous_state();
+				yy_current_state = yy_get_previous_state(  );
 
-				yy_cp = yy_c_buf_p;
-				yy_bp = yytext_ptr + YY_MORE_ADJ;
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
 				goto yy_match;
 
 			case EOB_ACT_LAST_MATCH:
-				yy_c_buf_p =
-				&yy_current_buffer->yy_ch_buf[yy_n_chars];
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
 
-				yy_current_state = yy_get_previous_state();
+				yy_current_state = yy_get_previous_state(  );
 
-				yy_cp = yy_c_buf_p;
-				yy_bp = yytext_ptr + YY_MORE_ADJ;
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
 				goto yy_find_action;
 			}
 		break;
@@ -1190,8 +1326,7 @@
 			"fatal flex scanner internal error--no action found" );
 	} /* end of action switch */
 		} /* end of scanning one token */
-	} /* end of yylex */
-
+} /* end of yylex */
 
 /* yy_get_next_buffer - try to read in a new buffer
  *
@@ -1200,21 +1335,20 @@
  *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
  *	EOB_ACT_END_OF_FILE - end of file
  */
-
-static int yy_get_next_buffer()
-	{
-	register char *dest = yy_current_buffer->yy_ch_buf;
-	register char *source = yytext_ptr;
+static int yy_get_next_buffer (void)
+{
+    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	register char *source = (yytext_ptr);
 	register int number_to_move, i;
 	int ret_val;
 
-	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
 		YY_FATAL_ERROR(
 		"fatal flex scanner internal error--end of buffer missed" );
 
-	if ( yy_current_buffer->yy_fill_buffer == 0 )
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
 		{ /* Don't try to fill the buffer, so this is an EOF. */
-		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
 			{
 			/* We matched a single character, the EOB, so
 			 * treat this as a final EOF.
@@ -1234,38 +1368,34 @@
 	/* Try to read more data. */
 
 	/* First move last chars to start of buffer. */
-	number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
 
 	for ( i = 0; i < number_to_move; ++i )
 		*(dest++) = *(source++);
 
-	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
 		/* don't do the read, it's not guaranteed to return an EOF,
 		 * just force an EOF
 		 */
-		yy_current_buffer->yy_n_chars = yy_n_chars = 0;
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
 
 	else
 		{
-		int num_to_read =
-			yy_current_buffer->yy_buf_size - number_to_move - 1;
+			yy_size_t num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
 
 		while ( num_to_read <= 0 )
 			{ /* Not enough room in the buffer - grow it. */
-#ifdef YY_USES_REJECT
-			YY_FATAL_ERROR(
-"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
-#else
 
 			/* just a shorter name for the current buffer */
-			YY_BUFFER_STATE b = yy_current_buffer;
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;
 
 			int yy_c_buf_p_offset =
-				(int) (yy_c_buf_p - b->yy_ch_buf);
+				(int) ((yy_c_buf_p) - b->yy_ch_buf);
 
 			if ( b->yy_is_our_buffer )
 				{
-				int new_size = b->yy_buf_size * 2;
+				yy_size_t new_size = b->yy_buf_size * 2;
 
 				if ( new_size <= 0 )
 					b->yy_buf_size += b->yy_buf_size / 8;
@@ -1274,8 +1404,7 @@
 
 				b->yy_ch_buf = (char *)
 					/* Include room in for 2 EOB chars. */
-					yy_flex_realloc( (void *) b->yy_ch_buf,
-							 b->yy_buf_size + 2 );
+					yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
 				}
 			else
 				/* Can't grow it, we don't own it. */
@@ -1285,35 +1414,35 @@
 				YY_FATAL_ERROR(
 				"fatal error - scanner input buffer overflow" );
 
-			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];
+			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
 
-			num_to_read = yy_current_buffer->yy_buf_size -
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
 						number_to_move - 1;
-#endif
+
 			}
 
 		if ( num_to_read > YY_READ_BUF_SIZE )
 			num_to_read = YY_READ_BUF_SIZE;
 
 		/* Read in more data. */
-		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
-			yy_n_chars, num_to_read );
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), num_to_read );
 
-		yy_current_buffer->yy_n_chars = yy_n_chars;
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
 		}
 
-	if ( yy_n_chars == 0 )
+	if ( (yy_n_chars) == 0 )
 		{
 		if ( number_to_move == YY_MORE_ADJ )
 			{
 			ret_val = EOB_ACT_END_OF_FILE;
-			yyrestart( yyin );
+			yyrestart(yyin  );
 			}
 
 		else
 			{
 			ret_val = EOB_ACT_LAST_MATCH;
-			yy_current_buffer->yy_buffer_status =
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
 				YY_BUFFER_EOF_PENDING;
 			}
 		}
@@ -1321,152 +1450,145 @@
 	else
 		ret_val = EOB_ACT_CONTINUE_SCAN;
 
-	yy_n_chars += number_to_move;
-	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
-	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
+	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+		/* Extend the array by 50%, plus the number we really need. */
+		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
+		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
+		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
+	}
 
-	yytext_ptr = &yy_current_buffer->yy_ch_buf[0];
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
 
-	return ret_val;
-	}
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
 
+	return ret_val;
+}
 
 /* yy_get_previous_state - get the state just before the EOB char was reached */
 
-static yy_state_type yy_get_previous_state()
-	{
+    static yy_state_type yy_get_previous_state (void)
+{
 	register yy_state_type yy_current_state;
 	register char *yy_cp;
+    
+	yy_current_state = (yy_start);
 
-	yy_current_state = yy_start;
-
-	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
 		{
 		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
 		if ( yy_accept[yy_current_state] )
 			{
-			yy_last_accepting_state = yy_current_state;
-			yy_last_accepting_cpos = yy_cp;
+			(yy_last_accepting_state) = yy_current_state;
+			(yy_last_accepting_cpos) = yy_cp;
 			}
 		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
 			{
 			yy_current_state = (int) yy_def[yy_current_state];
-			if ( yy_current_state >= 248 )
+			if ( yy_current_state >= 261 )
 				yy_c = yy_meta[(unsigned int) yy_c];
 			}
 		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
 		}
 
 	return yy_current_state;
-	}
-
+}
 
 /* yy_try_NUL_trans - try to make a transition on the NUL character
  *
  * synopsis
  *	next_state = yy_try_NUL_trans( current_state );
  */
-
-#ifdef YY_USE_PROTOS
-static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
-#else
-static yy_state_type yy_try_NUL_trans( yy_current_state )
-yy_state_type yy_current_state;
-#endif
-	{
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+{
 	register int yy_is_jam;
-	register char *yy_cp = yy_c_buf_p;
+    	register char *yy_cp = (yy_c_buf_p);
 
 	register YY_CHAR yy_c = 1;
 	if ( yy_accept[yy_current_state] )
 		{
-		yy_last_accepting_state = yy_current_state;
-		yy_last_accepting_cpos = yy_cp;
+		(yy_last_accepting_state) = yy_current_state;
+		(yy_last_accepting_cpos) = yy_cp;
 		}
 	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
 		{
 		yy_current_state = (int) yy_def[yy_current_state];
-		if ( yy_current_state >= 248 )
+		if ( yy_current_state >= 261 )
 			yy_c = yy_meta[(unsigned int) yy_c];
 		}
 	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-	yy_is_jam = (yy_current_state == 247);
-
-	return yy_is_jam ? 0 : yy_current_state;
-	}
+	yy_is_jam = (yy_current_state == 260);
 
+		return yy_is_jam ? 0 : yy_current_state;
+}
 
-#ifndef YY_NO_UNPUT
-#ifdef YY_USE_PROTOS
-static void yyunput( int c, register char *yy_bp )
-#else
-static void yyunput( c, yy_bp )
-int c;
-register char *yy_bp;
-#endif
-	{
-	register char *yy_cp = yy_c_buf_p;
+    static void yyunput (int c, register char * yy_bp )
+{
+	register char *yy_cp;
+    
+    yy_cp = (yy_c_buf_p);
 
 	/* undo effects of setting up yytext */
-	*yy_cp = yy_hold_char;
+	*yy_cp = (yy_hold_char);
 
-	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
+	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
 		{ /* need to shift things up to make room */
 		/* +2 for EOB chars. */
-		register int number_to_move = yy_n_chars + 2;
-		register char *dest = &yy_current_buffer->yy_ch_buf[
-					yy_current_buffer->yy_buf_size + 2];
+		register yy_size_t number_to_move = (yy_n_chars) + 2;
+		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
+					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
 		register char *source =
-				&yy_current_buffer->yy_ch_buf[number_to_move];
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
 
-		while ( source > yy_current_buffer->yy_ch_buf )
+		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
 			*--dest = *--source;
 
 		yy_cp += (int) (dest - source);
 		yy_bp += (int) (dest - source);
-		yy_current_buffer->yy_n_chars =
-			yy_n_chars = yy_current_buffer->yy_buf_size;
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
 
-		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
+		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
 			YY_FATAL_ERROR( "flex scanner push-back overflow" );
 		}
 
 	*--yy_cp = (char) c;
 
+	(yytext_ptr) = yy_bp;
+	(yy_hold_char) = *yy_cp;
+	(yy_c_buf_p) = yy_cp;
+}
 
-	yytext_ptr = yy_bp;
-	yy_hold_char = *yy_cp;
-	yy_c_buf_p = yy_cp;
-	}
-#endif	/* ifndef YY_NO_UNPUT */
-
-
+#ifndef YY_NO_INPUT
 #ifdef __cplusplus
-static int yyinput()
+    static int yyinput (void)
 #else
-static int input()
+    static int input  (void)
 #endif
-	{
-	int c;
 
-	*yy_c_buf_p = yy_hold_char;
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
 
-	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
 		{
 		/* yy_c_buf_p now points to the character we want to return.
 		 * If this occurs *before* the EOB characters, then it's a
 		 * valid NUL; if not, then we've hit the end of the buffer.
 		 */
-		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
 			/* This was really a NUL. */
-			*yy_c_buf_p = '\0';
+			*(yy_c_buf_p) = '\0';
 
 		else
 			{ /* need more input */
-			int offset = yy_c_buf_p - yytext_ptr;
-			++yy_c_buf_p;
+			yy_size_t offset = (yy_c_buf_p) - (yytext_ptr);
+			++(yy_c_buf_p);
 
-			switch ( yy_get_next_buffer() )
+			switch ( yy_get_next_buffer(  ) )
 				{
 				case EOB_ACT_LAST_MATCH:
 					/* This happens because yy_g_n_b()
@@ -1480,16 +1602,16 @@
 					 */
 
 					/* Reset buffer status. */
-					yyrestart( yyin );
+					yyrestart(yyin );
 
-					/* fall through */
+					/*FALLTHROUGH*/
 
 				case EOB_ACT_END_OF_FILE:
 					{
-					if ( yywrap() )
+					if ( yywrap( ) )
 						return EOF;
 
-					if ( ! yy_did_buffer_switch_on_eof )
+					if ( ! (yy_did_buffer_switch_on_eof) )
 						YY_NEW_FILE;
 #ifdef __cplusplus
 					return yyinput();
@@ -1499,90 +1621,92 @@
 					}
 
 				case EOB_ACT_CONTINUE_SCAN:
-					yy_c_buf_p = yytext_ptr + offset;
+					(yy_c_buf_p) = (yytext_ptr) + offset;
 					break;
 				}
 			}
 		}
 
-	c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */
-	*yy_c_buf_p = '\0';	/* preserve yytext */
-	yy_hold_char = *++yy_c_buf_p;
-
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve yytext */
+	(yy_hold_char) = *++(yy_c_buf_p);
 
 	return c;
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yyrestart( FILE *input_file )
-#else
-void yyrestart( input_file )
-FILE *input_file;
-#endif
-	{
-	if ( ! yy_current_buffer )
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
+}
+#endif	/* ifndef YY_NO_INPUT */
 
-	yy_init_buffer( yy_current_buffer, input_file );
-	yy_load_buffer_state();
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
-#else
-void yy_switch_to_buffer( new_buffer )
-YY_BUFFER_STATE new_buffer;
-#endif
-	{
-	if ( yy_current_buffer == new_buffer )
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void yyrestart  (FILE * input_file )
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        yyensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            yy_create_buffer(yyin,YY_BUF_SIZE );
+	}
+
+	yy_init_buffer(YY_CURRENT_BUFFER,input_file );
+	yy_load_buffer_state( );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		yypop_buffer_state();
+	 *		yypush_buffer_state(new_buffer);
+     */
+	yyensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
 		return;
 
-	if ( yy_current_buffer )
+	if ( YY_CURRENT_BUFFER )
 		{
 		/* Flush out information for old buffer. */
-		*yy_c_buf_p = yy_hold_char;
-		yy_current_buffer->yy_buf_pos = yy_c_buf_p;
-		yy_current_buffer->yy_n_chars = yy_n_chars;
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
 		}
 
-	yy_current_buffer = new_buffer;
-	yy_load_buffer_state();
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	yy_load_buffer_state( );
 
 	/* We don't actually know whether we did this switch during
 	 * EOF (yywrap()) processing, but the only time this flag
 	 * is looked at is after yywrap() is called, so it's safe
 	 * to go ahead and always set it.
 	 */
-	yy_did_buffer_switch_on_eof = 1;
-	}
-
+	(yy_did_buffer_switch_on_eof) = 1;
+}
 
-#ifdef YY_USE_PROTOS
-void yy_load_buffer_state( void )
-#else
-void yy_load_buffer_state()
-#endif
-	{
-	yy_n_chars = yy_current_buffer->yy_n_chars;
-	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
-	yyin = yy_current_buffer->yy_input_file;
-	yy_hold_char = *yy_c_buf_p;
-	}
-
-
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
-#else
-YY_BUFFER_STATE yy_create_buffer( file, size )
-FILE *file;
-int size;
-#endif
-	{
+static void yy_load_buffer_state  (void)
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
+{
 	YY_BUFFER_STATE b;
-
-	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
+    
+	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
 	if ( ! b )
 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
 
@@ -1591,75 +1715,71 @@
 	/* yy_ch_buf has to be 2 characters longer than the size given because
 	 * we need to put in 2 end-of-buffer characters.
 	 */
-	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
+	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );
 	if ( ! b->yy_ch_buf )
 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
 
 	b->yy_is_our_buffer = 1;
 
-	yy_init_buffer( b, file );
+	yy_init_buffer(b,file );
 
 	return b;
-	}
-
+}
 
-#ifdef YY_USE_PROTOS
-void yy_delete_buffer( YY_BUFFER_STATE b )
-#else
-void yy_delete_buffer( b )
-YY_BUFFER_STATE b;
-#endif
-	{
+/** Destroy the buffer.
+ * @param b a buffer created with yy_create_buffer()
+ * 
+ */
+    void yy_delete_buffer (YY_BUFFER_STATE  b )
+{
+    
 	if ( ! b )
 		return;
 
-	if ( b == yy_current_buffer )
-		yy_current_buffer = (YY_BUFFER_STATE) 0;
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
 
 	if ( b->yy_is_our_buffer )
-		yy_flex_free( (void *) b->yy_ch_buf );
-
-	yy_flex_free( (void *) b );
-	}
-
+		yyfree((void *) b->yy_ch_buf  );
 
+	yyfree((void *) b  );
+}
 
-#ifdef YY_USE_PROTOS
-void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
-#else
-void yy_init_buffer( b, file )
-YY_BUFFER_STATE b;
-FILE *file;
-#endif
-
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a yyrestart() or at EOF.
+ */
+    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
 
-	{
-	yy_flush_buffer( b );
+{
+	int oerrno = errno;
+    
+	yy_flush_buffer(b );
 
 	b->yy_input_file = file;
 	b->yy_fill_buffer = 1;
 
-#if YY_ALWAYS_INTERACTIVE
-	b->yy_is_interactive = 1;
-#else
-#if YY_NEVER_INTERACTIVE
-	b->yy_is_interactive = 0;
-#else
-	b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
-#endif
-#endif
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_flush_buffer( YY_BUFFER_STATE b )
-#else
-void yy_flush_buffer( b )
-YY_BUFFER_STATE b;
-#endif
-
-	{
-	if ( ! b )
+    /* If b is the current buffer, then yy_init_buffer was _probably_
+     * called from yyrestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
+    
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+    void yy_flush_buffer (YY_BUFFER_STATE  b )
+{
+    	if ( ! b )
 		return;
 
 	b->yy_n_chars = 0;
@@ -1676,29 +1796,125 @@
 	b->yy_at_bol = 1;
 	b->yy_buffer_status = YY_BUFFER_NEW;
 
-	if ( b == yy_current_buffer )
-		yy_load_buffer_state();
+	if ( b == YY_CURRENT_BUFFER )
+		yy_load_buffer_state( );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
+{
+    	if (new_buffer == NULL)
+		return;
+
+	yyensure_buffer_stack();
+
+	/* This block is copied from yy_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from yy_switch_to_buffer. */
+	yy_load_buffer_state( );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+void yypop_buffer_state (void)
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	yy_delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		yy_load_buffer_state( );
+		(yy_did_buffer_switch_on_eof) = 1;
+	}
+}
+
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void yyensure_buffer_stack (void)
+{
+	yy_size_t num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+		num_to_alloc = 1;
+		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+								  
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+				
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
 	}
 
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
 
-#ifndef YY_NO_SCAN_BUFFER
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )
-#else
-YY_BUFFER_STATE yy_scan_buffer( base, size )
-char *base;
-yy_size_t size;
-#endif
-	{
-	YY_BUFFER_STATE b;
+		/* Increase the buffer to prepare for a possible push. */
+		int grow_size = 8 /* arbitrary grow size */;
 
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
+
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object. 
+ */
+YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
 	if ( size < 2 ||
 	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
 	     base[size-1] != YY_END_OF_BUFFER_CHAR )
 		/* They forgot to leave room for the EOB's. */
 		return 0;
 
-	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
+	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
 	if ( ! b )
 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
 
@@ -1712,56 +1928,51 @@
 	b->yy_fill_buffer = 0;
 	b->yy_buffer_status = YY_BUFFER_NEW;
 
-	yy_switch_to_buffer( b );
+	yy_switch_to_buffer(b  );
 
 	return b;
-	}
-#endif
-
-
-#ifndef YY_NO_SCAN_STRING
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_string( yyconst char *yy_str )
-#else
-YY_BUFFER_STATE yy_scan_string( yy_str )
-yyconst char *yy_str;
-#endif
-	{
-	int len;
-	for ( len = 0; yy_str[len]; ++len )
-		;
-
-	return yy_scan_bytes( yy_str, len );
-	}
-#endif
-
+}
 
-#ifndef YY_NO_SCAN_BYTES
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )
-#else
-YY_BUFFER_STATE yy_scan_bytes( bytes, len )
-yyconst char *bytes;
-int len;
-#endif
-	{
+/** Setup the input buffer state to scan a string. The next call to yylex() will
+ * scan from a @e copy of @a str.
+ * @param yystr a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       yy_scan_bytes() instead.
+ */
+YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
+{
+    
+	return yy_scan_bytes(yystr,strlen(yystr) );
+}
+
+/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
+ * scan from a @e copy of @a bytes.
+ * @param yybytes the byte buffer to scan
+ * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len )
+{
 	YY_BUFFER_STATE b;
 	char *buf;
 	yy_size_t n;
-	int i;
-
+	yy_size_t i;
+    
 	/* Get memory for full buffer, including space for trailing EOB's. */
-	n = len + 2;
-	buf = (char *) yy_flex_alloc( n );
+	n = _yybytes_len + 2;
+	buf = (char *) yyalloc(n  );
 	if ( ! buf )
 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
 
-	for ( i = 0; i < len; ++i )
-		buf[i] = bytes[i];
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
 
-	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
 
-	b = yy_scan_buffer( buf, n );
+	b = yy_scan_buffer(buf,n );
 	if ( ! b )
 		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
 
@@ -1771,78 +1982,17 @@
 	b->yy_is_our_buffer = 1;
 
 	return b;
-	}
-#endif
-
-
-#ifndef YY_NO_PUSH_STATE
-#ifdef YY_USE_PROTOS
-static void yy_push_state( int new_state )
-#else
-static void yy_push_state( new_state )
-int new_state;
-#endif
-	{
-	if ( yy_start_stack_ptr >= yy_start_stack_depth )
-		{
-		yy_size_t new_size;
-
-		yy_start_stack_depth += YY_START_STACK_INCR;
-		new_size = yy_start_stack_depth * sizeof( int );
-
-		if ( ! yy_start_stack )
-			yy_start_stack = (int *) yy_flex_alloc( new_size );
-
-		else
-			yy_start_stack = (int *) yy_flex_realloc(
-					(void *) yy_start_stack, new_size );
-
-		if ( ! yy_start_stack )
-			YY_FATAL_ERROR(
-			"out of memory expanding start-condition stack" );
-		}
-
-	yy_start_stack[yy_start_stack_ptr++] = YY_START;
-
-	BEGIN(new_state);
-	}
-#endif
-
-
-#ifndef YY_NO_POP_STATE
-static void yy_pop_state()
-	{
-	if ( --yy_start_stack_ptr < 0 )
-		YY_FATAL_ERROR( "start-condition stack underflow" );
-
-	BEGIN(yy_start_stack[yy_start_stack_ptr]);
-	}
-#endif
-
-
-#ifndef YY_NO_TOP_STATE
-static int yy_top_state()
-	{
-	return yy_start_stack[yy_start_stack_ptr - 1];
-	}
-#endif
+}
 
 #ifndef YY_EXIT_FAILURE
 #define YY_EXIT_FAILURE 2
 #endif
 
-#ifdef YY_USE_PROTOS
-static void yy_fatal_error( yyconst char msg[] )
-#else
-static void yy_fatal_error( msg )
-char msg[];
-#endif
-	{
-	(void) fprintf( stderr, "%s\n", msg );
+static void yy_fatal_error (yyconst char* msg )
+{
+    	(void) fprintf( stderr, "%s\n", msg );
 	exit( YY_EXIT_FAILURE );
-	}
-
-
+}
 
 /* Redefine yyless() so it works in section 3 code. */
 
@@ -1851,68 +2001,177 @@
 	do \
 		{ \
 		/* Undo effects of setting up yytext. */ \
-		yytext[yyleng] = yy_hold_char; \
-		yy_c_buf_p = yytext + n; \
-		yy_hold_char = *yy_c_buf_p; \
-		*yy_c_buf_p = '\0'; \
-		yyleng = n; \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		yytext[yyleng] = (yy_hold_char); \
+		(yy_c_buf_p) = yytext + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		yyleng = yyless_macro_arg; \
 		} \
 	while ( 0 )
 
+/* Accessor  methods (get/set functions) to struct members. */
+
+/** Get the current line number.
+ * 
+ */
+int yyget_lineno  (void)
+{
+        
+    return yylineno;
+}
+
+/** Get the input stream.
+ * 
+ */
+FILE *yyget_in  (void)
+{
+        return yyin;
+}
+
+/** Get the output stream.
+ * 
+ */
+FILE *yyget_out  (void)
+{
+        return yyout;
+}
 
-/* Internal utility routines. */
+/** Get the length of the current token.
+ * 
+ */
+yy_size_t yyget_leng  (void)
+{
+        return yyleng;
+}
+
+/** Get the current token.
+ * 
+ */
+
+char *yyget_text  (void)
+{
+        return yytext;
+}
+
+/** Set the current line number.
+ * @param line_number
+ * 
+ */
+void yyset_lineno (int  line_number )
+{
+    
+    yylineno = line_number;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param in_str A readable stream.
+ * 
+ * @see yy_switch_to_buffer
+ */
+void yyset_in (FILE *  in_str )
+{
+        yyin = in_str ;
+}
+
+void yyset_out (FILE *  out_str )
+{
+        yyout = out_str ;
+}
+
+int yyget_debug  (void)
+{
+        return yy_flex_debug;
+}
+
+void yyset_debug (int  bdebug )
+{
+        yy_flex_debug = bdebug ;
+}
+
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from yylex_destroy(), so don't allocate here.
+     */
+
+    (yy_buffer_stack) = 0;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = (char *) 0;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    yyin = stdin;
+    yyout = stdout;
+#else
+    yyin = (FILE *) 0;
+    yyout = (FILE *) 0;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * yylex_init()
+     */
+    return 0;
+}
+
+/* yylex_destroy is for both reentrant and non-reentrant scanners. */
+int yylex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		yy_delete_buffer(YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		yypop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	yyfree((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * yylex() is called, initialization will occur. */
+    yy_init_globals( );
+
+    return 0;
+}
+
+/*
+ * Internal utility routines.
+ */
 
 #ifndef yytext_ptr
-#ifdef YY_USE_PROTOS
-static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )
-#else
-static void yy_flex_strncpy( s1, s2, n )
-char *s1;
-yyconst char *s2;
-int n;
-#endif
-	{
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+{
 	register int i;
 	for ( i = 0; i < n; ++i )
 		s1[i] = s2[i];
-	}
+}
 #endif
 
 #ifdef YY_NEED_STRLEN
-#ifdef YY_USE_PROTOS
-static int yy_flex_strlen( yyconst char *s )
-#else
-static int yy_flex_strlen( s )
-yyconst char *s;
-#endif
-	{
+static int yy_flex_strlen (yyconst char * s )
+{
 	register int n;
 	for ( n = 0; s[n]; ++n )
 		;
 
 	return n;
-	}
+}
 #endif
 
-
-#ifdef YY_USE_PROTOS
-static void *yy_flex_alloc( yy_size_t size )
-#else
-static void *yy_flex_alloc( size )
-yy_size_t size;
-#endif
-	{
+void *yyalloc (yy_size_t  size )
+{
 	return (void *) malloc( size );
-	}
+}
 
-#ifdef YY_USE_PROTOS
-static void *yy_flex_realloc( void *ptr, yy_size_t size )
-#else
-static void *yy_flex_realloc( ptr, size )
-void *ptr;
-yy_size_t size;
-#endif
-	{
+void *yyrealloc  (void * ptr, yy_size_t  size )
+{
 	/* The cast to (char *) in the following accommodates both
 	 * implementations that use char* generic pointers, and those
 	 * that use void* generic pointers.  It works with the latter
@@ -1921,29 +2180,21 @@
 	 * as though doing an assignment.
 	 */
 	return (void *) realloc( (char *) ptr, size );
-	}
+}
 
-#ifdef YY_USE_PROTOS
-static void yy_flex_free( void *ptr )
-#else
-static void yy_flex_free( ptr )
-void *ptr;
-#endif
-	{
-	free( ptr );
-	}
+void yyfree (void * ptr )
+{
+	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
+}
+
+#define YYTABLES_NAME "yytables"
+
+#line 131 "cfgparser2.l"
 
-#if YY_MAIN
-int main()
-	{
-	yylex();
-	return 0;
-	}
-#endif
-#line 129 "cfgparser2.l"
 
 
 void *p=yyunput;
 /* 
  vi: ft=lex 
 */
+
diff -ruN ../apinger-0.6.1-patched/src/cfgparser2.l ./src/cfgparser2.l
--- ../apinger-0.6.1-patched/src/cfgparser2.l	2014-01-06 10:06:42.671168484 -0200
+++ ./src/cfgparser2.l	2014-01-06 12:12:44.542000299 -0200
@@ -86,6 +86,7 @@
 down		{ LOC; LOCINC; return DOWN; }
 false		{ LOC; LOCINC; return FALSE; }
 file		{ LOC; LOCINC; return FILE_; }
+force_down	{ LOC; LOCINC; return FORCE_DOWN; }
 group		{ LOC; LOCINC; return GROUP; }
 interval	{ LOC; LOCINC; return INTERVAL; }
 loss		{ LOC; LOCINC; return LOSS; }
diff -ruN ../apinger-0.6.1-patched/src/conf.c ./src/conf.c
--- ../apinger-0.6.1-patched/src/conf.c	2014-01-06 10:07:04.810469520 -0200
+++ ./src/conf.c	2014-01-06 16:51:01.097200873 -0200
@@ -187,6 +187,8 @@
 				t->avg_loss_delay_samples=cur_config.target_defaults.avg_loss_delay_samples;
 			if (t->rrd_filename==NULL)
 				t->rrd_filename=cur_config.target_defaults.rrd_filename;
+			if (t->force_down==NULL)
+				t->force_down=0;
 			for(al=t->alarms;al && al->next;al=al->next);
 			if (t->alarms_override==0){
 				if (al)
diff -ruN ../apinger-0.6.1-patched/src/conf.h ./src/conf.h
--- ../apinger-0.6.1-patched/src/conf.h	2014-01-06 10:07:04.810469520 -0200
+++ ./src/conf.h	2014-01-06 12:03:47.904292594 -0200
@@ -73,6 +73,7 @@
 	char *name;
 	char *description;
 	char *srcip;
+	int force_down;
 	int interval;
 	int avg_delay_samples;
 	int avg_loss_delay_samples;

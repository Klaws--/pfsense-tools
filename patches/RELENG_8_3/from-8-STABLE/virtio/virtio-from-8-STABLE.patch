 sys/dev/virtio/balloon/virtio_balloon.c |  570 +++++++
 sys/dev/virtio/balloon/virtio_balloon.h |   62 +
 sys/dev/virtio/block/virtio_blk.c       | 1238 ++++++++++++++
 sys/dev/virtio/block/virtio_blk.h       |  117 ++
 sys/dev/virtio/network/if_vtnet.c       | 2746 +++++++++++++++++++++++++++++++
 sys/dev/virtio/network/if_vtnetvar.h    |  241 +++
 sys/dev/virtio/network/virtio_net.h     |  159 ++
 sys/dev/virtio/pci/virtio_pci.c         | 1262 ++++++++++++++
 sys/dev/virtio/pci/virtio_pci.h         |   87 +
 sys/dev/virtio/scsi/virtio_scsi.c       | 2351 ++++++++++++++++++++++++++
 sys/dev/virtio/scsi/virtio_scsi.h       |  152 ++
 sys/dev/virtio/scsi/virtio_scsivar.h    |  221 +++
 sys/dev/virtio/virtio.c                 |  277 ++++
 sys/dev/virtio/virtio.h                 |  185 +++
 sys/dev/virtio/virtio_bus_if.m          |   92 ++
 sys/dev/virtio/virtio_if.m              |   43 +
 sys/dev/virtio/virtio_ring.h            |  165 ++
 sys/dev/virtio/virtqueue.c              |  803 +++++++++
 sys/dev/virtio/virtqueue.h              |   93 ++
 sys/modules/Makefile                    |    3 +
 sys/modules/virtio/Makefile             |   28 +
 sys/modules/virtio/balloon/Makefile     |   36 +
 sys/modules/virtio/block/Makefile       |   36 +
 sys/modules/virtio/network/Makefile     |   36 +
 sys/modules/virtio/pci/Makefile         |   36 +
 sys/modules/virtio/scsi/Makefile        |   36 +
 sys/modules/virtio/virtio/Makefile      |   38 +
 27 files changed, 11113 insertions(+)

diff --git a/sys/dev/virtio/balloon/virtio_balloon.c b/sys/dev/virtio/balloon/virtio_balloon.c
new file mode 100644
index 0000000..9b45459
--- /dev/null
+++ b/sys/dev/virtio/balloon/virtio_balloon.c
@@ -0,0 +1,570 @@
+/*-
+ * Copyright (c) 2011, Bryan Venteicher <bryanv@daemoninthecloset.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice unmodified, this list of conditions, and the following
+ *    disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* Driver for VirtIO memory balloon devices. */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/kernel.h>
+#include <sys/endian.h>
+#include <sys/kthread.h>
+#include <sys/malloc.h>
+#include <sys/module.h>
+#include <sys/sglist.h>
+#include <sys/sysctl.h>
+#include <sys/lock.h>
+#include <sys/mutex.h>
+#include <sys/queue.h>
+
+#include <vm/vm.h>
+#include <vm/vm_page.h>
+
+#include <machine/bus.h>
+#include <machine/resource.h>
+#include <sys/bus.h>
+#include <sys/rman.h>
+
+#include <dev/virtio/virtio.h>
+#include <dev/virtio/virtqueue.h>
+#include <dev/virtio/balloon/virtio_balloon.h>
+
+#include "virtio_if.h"
+
+struct vtballoon_softc {
+	device_t		 vtballoon_dev;
+	struct mtx		 vtballoon_mtx;
+	uint64_t		 vtballoon_features;
+	uint32_t		 vtballoon_flags;
+#define VTBALLOON_FLAG_DETACH	 0x01
+
+	struct virtqueue	*vtballoon_inflate_vq;
+	struct virtqueue	*vtballoon_deflate_vq;
+
+	uint32_t		 vtballoon_desired_npages;
+	uint32_t		 vtballoon_current_npages;
+	TAILQ_HEAD(,vm_page)	 vtballoon_pages;
+
+	struct proc		*vtballoon_kproc;
+	uint32_t		*vtballoon_page_frames;
+	int			 vtballoon_timeout;
+};
+
+static struct virtio_feature_desc vtballoon_feature_desc[] = {
+	{ VIRTIO_BALLOON_F_MUST_TELL_HOST,	"MustTellHost"	},
+	{ VIRTIO_BALLOON_F_STATS_VQ,		"StatsVq"	},
+
+	{ 0, NULL }
+};
+
+static int	vtballoon_probe(device_t);
+static int	vtballoon_attach(device_t);
+static int	vtballoon_detach(device_t);
+static int	vtballoon_config_change(device_t);
+
+static void	vtballoon_negotiate_features(struct vtballoon_softc *);
+static int	vtballoon_alloc_virtqueues(struct vtballoon_softc *);
+
+static int	vtballoon_vq_intr(void *);
+
+static void	vtballoon_inflate(struct vtballoon_softc *, int);
+static void	vtballoon_deflate(struct vtballoon_softc *, int);
+
+static void	vtballoon_send_page_frames(struct vtballoon_softc *,
+		    struct virtqueue *, int);
+
+static void	vtballoon_pop(struct vtballoon_softc *);
+static void	vtballoon_stop(struct vtballoon_softc *);
+
+static vm_page_t
+		vtballoon_alloc_page(struct vtballoon_softc *);
+static void	vtballoon_free_page(struct vtballoon_softc *, vm_page_t);
+
+static int	vtballoon_sleep(struct vtballoon_softc *);
+static void	vtballoon_thread(void *);
+static void	vtballoon_add_sysctl(struct vtballoon_softc *);
+
+/* Features desired/implemented by this driver. */
+#define VTBALLOON_FEATURES		0
+
+/* Timeout between retries when the balloon needs inflating. */
+#define VTBALLOON_LOWMEM_TIMEOUT	hz
+
+/*
+ * Maximum number of pages we'll request to inflate or deflate
+ * the balloon in one virtqueue request. Both Linux and NetBSD
+ * have settled on 256, doing up to 1MB at a time.
+ */
+#define VTBALLOON_PAGES_PER_REQUEST	256
+
+/* Must be able to fix all pages frames in one page (segment). */
+CTASSERT(VTBALLOON_PAGES_PER_REQUEST * sizeof(uint32_t) <= PAGE_SIZE);
+
+#define VTBALLOON_MTX(_sc)		&(_sc)->vtballoon_mtx
+#define VTBALLOON_LOCK_INIT(_sc, _name)	mtx_init(VTBALLOON_MTX((_sc)), _name, \
+					    "VirtIO Balloon Lock", MTX_SPIN)
+#define VTBALLOON_LOCK(_sc)		mtx_lock_spin(VTBALLOON_MTX((_sc)))
+#define VTBALLOON_UNLOCK(_sc)		mtx_unlock_spin(VTBALLOON_MTX((_sc)))
+#define VTBALLOON_LOCK_DESTROY(_sc)	mtx_destroy(VTBALLOON_MTX((_sc)))
+
+static device_method_t vtballoon_methods[] = {
+	/* Device methods. */
+	DEVMETHOD(device_probe,		vtballoon_probe),
+	DEVMETHOD(device_attach,	vtballoon_attach),
+	DEVMETHOD(device_detach,	vtballoon_detach),
+
+	/* VirtIO methods. */
+	DEVMETHOD(virtio_config_change, vtballoon_config_change),
+
+	DEVMETHOD_END
+};
+
+static driver_t vtballoon_driver = {
+	"vtballoon",
+	vtballoon_methods,
+	sizeof(struct vtballoon_softc)
+};
+static devclass_t vtballoon_devclass;
+
+DRIVER_MODULE(virtio_balloon, virtio_pci, vtballoon_driver,
+    vtballoon_devclass, 0, 0);
+MODULE_VERSION(virtio_balloon, 1);
+MODULE_DEPEND(virtio_balloon, virtio, 1, 1, 1);
+
+static int
+vtballoon_probe(device_t dev)
+{
+
+	if (virtio_get_device_type(dev) != VIRTIO_ID_BALLOON)
+		return (ENXIO);
+
+	device_set_desc(dev, "VirtIO Balloon Adapter");
+
+	return (BUS_PROBE_DEFAULT);
+}
+
+static int
+vtballoon_attach(device_t dev)
+{
+	struct vtballoon_softc *sc;
+	int error;
+
+	sc = device_get_softc(dev);
+	sc->vtballoon_dev = dev;
+
+	VTBALLOON_LOCK_INIT(sc, device_get_nameunit(dev));
+	TAILQ_INIT(&sc->vtballoon_pages);
+
+	vtballoon_add_sysctl(sc);
+
+	virtio_set_feature_desc(dev, vtballoon_feature_desc);
+	vtballoon_negotiate_features(sc);
+
+	sc->vtballoon_page_frames = malloc(VTBALLOON_PAGES_PER_REQUEST *
+	    sizeof(uint32_t), M_DEVBUF, M_NOWAIT | M_ZERO);
+	if (sc->vtballoon_page_frames == NULL) {
+		error = ENOMEM;
+		device_printf(dev,
+		    "cannot allocate page frame request array\n");
+		goto fail;
+	}
+
+	error = vtballoon_alloc_virtqueues(sc);
+	if (error) {
+		device_printf(dev, "cannot allocate virtqueues\n");
+		goto fail;
+	}
+
+	error = virtio_setup_intr(dev, INTR_TYPE_MISC);
+	if (error) {
+		device_printf(dev, "cannot setup virtqueue interrupts\n");
+		goto fail;
+	}
+
+	error = kproc_create(vtballoon_thread, sc, &sc->vtballoon_kproc,
+	    0, 0, "virtio_balloon");
+	if (error) {
+		device_printf(dev, "cannot create balloon kproc\n");
+		goto fail;
+	}
+
+	virtqueue_enable_intr(sc->vtballoon_inflate_vq);
+	virtqueue_enable_intr(sc->vtballoon_deflate_vq);
+
+fail:
+	if (error)
+		vtballoon_detach(dev);
+
+	return (error);
+}
+
+static int
+vtballoon_detach(device_t dev)
+{
+	struct vtballoon_softc *sc;
+
+	sc = device_get_softc(dev);
+
+	if (sc->vtballoon_kproc != NULL) {
+		VTBALLOON_LOCK(sc);
+		sc->vtballoon_flags |= VTBALLOON_FLAG_DETACH;
+		wakeup_one(sc);
+		msleep_spin(sc->vtballoon_kproc, VTBALLOON_MTX(sc),
+		    "vtbdth", 0);
+		VTBALLOON_UNLOCK(sc);
+
+		sc->vtballoon_kproc = NULL;
+	}
+
+	if (device_is_attached(dev)) {
+		vtballoon_pop(sc);
+		vtballoon_stop(sc);
+	}
+
+	if (sc->vtballoon_page_frames != NULL) {
+		free(sc->vtballoon_page_frames, M_DEVBUF);
+		sc->vtballoon_page_frames = NULL;
+	}
+
+	VTBALLOON_LOCK_DESTROY(sc);
+
+	return (0);
+}
+
+static int
+vtballoon_config_change(device_t dev)
+{
+	struct vtballoon_softc *sc;
+
+	sc = device_get_softc(dev);
+
+	VTBALLOON_LOCK(sc);
+	wakeup_one(sc);
+	VTBALLOON_UNLOCK(sc);
+
+	return (1);
+}
+
+static void
+vtballoon_negotiate_features(struct vtballoon_softc *sc)
+{
+	device_t dev;
+	uint64_t features;
+
+	dev = sc->vtballoon_dev;
+	features = virtio_negotiate_features(dev, VTBALLOON_FEATURES);
+	sc->vtballoon_features = features;
+}
+
+static int
+vtballoon_alloc_virtqueues(struct vtballoon_softc *sc)
+{
+	device_t dev;
+	struct vq_alloc_info vq_info[2];
+	int nvqs;
+
+	dev = sc->vtballoon_dev;
+	nvqs = 2;
+
+	VQ_ALLOC_INFO_INIT(&vq_info[0], 0, vtballoon_vq_intr, sc,
+	    &sc->vtballoon_inflate_vq, "%s inflate", device_get_nameunit(dev));
+
+	VQ_ALLOC_INFO_INIT(&vq_info[1], 0, vtballoon_vq_intr, sc,
+	    &sc->vtballoon_deflate_vq, "%s deflate", device_get_nameunit(dev));
+
+	return (virtio_alloc_virtqueues(dev, 0, nvqs, vq_info));
+}
+
+static int
+vtballoon_vq_intr(void *xsc)
+{
+	struct vtballoon_softc *sc;
+
+	sc = xsc;
+
+	VTBALLOON_LOCK(sc);
+	wakeup_one(sc);
+	VTBALLOON_UNLOCK(sc);
+
+	return (1);
+}
+
+static void
+vtballoon_inflate(struct vtballoon_softc *sc, int npages)
+{
+	struct virtqueue *vq;
+	vm_page_t m;
+	int i;
+
+	vq = sc->vtballoon_inflate_vq;
+	m = NULL;
+
+	if (npages > VTBALLOON_PAGES_PER_REQUEST)
+		npages = VTBALLOON_PAGES_PER_REQUEST;
+	KASSERT(npages > 0, ("balloon doesn't need inflating?"));
+
+	for (i = 0; i < npages; i++) {
+		if ((m = vtballoon_alloc_page(sc)) == NULL)
+			break;
+
+		sc->vtballoon_page_frames[i] =
+		    VM_PAGE_TO_PHYS(m) >> VIRTIO_BALLOON_PFN_SHIFT;
+
+		KASSERT(m->queue == PQ_NONE, ("allocated page on queue"));
+		TAILQ_INSERT_TAIL(&sc->vtballoon_pages, m, pageq);
+	}
+
+	if (i > 0)
+		vtballoon_send_page_frames(sc, vq, i);
+
+	if (m == NULL)
+		sc->vtballoon_timeout = VTBALLOON_LOWMEM_TIMEOUT;
+}
+
+static void
+vtballoon_deflate(struct vtballoon_softc *sc, int npages)
+{
+	TAILQ_HEAD(, vm_page) free_pages;
+	struct virtqueue *vq;
+	vm_page_t m;
+	int i;
+
+	vq = sc->vtballoon_deflate_vq;
+	TAILQ_INIT(&free_pages);
+
+	if (npages > VTBALLOON_PAGES_PER_REQUEST)
+		npages = VTBALLOON_PAGES_PER_REQUEST;
+	KASSERT(npages > 0, ("balloon doesn't need deflating?"));
+
+	for (i = 0; i < npages; i++) {
+		m = TAILQ_FIRST(&sc->vtballoon_pages);
+		KASSERT(m != NULL, ("no more pages to deflate"));
+
+		sc->vtballoon_page_frames[i] =
+		    VM_PAGE_TO_PHYS(m) >> VIRTIO_BALLOON_PFN_SHIFT;
+
+		TAILQ_REMOVE(&sc->vtballoon_pages, m, pageq);
+		TAILQ_INSERT_TAIL(&free_pages, m, pageq);
+	}
+
+	if (i > 0) {
+		/* Always tell host first before freeing the pages. */
+		vtballoon_send_page_frames(sc, vq, i);
+
+		while ((m = TAILQ_FIRST(&free_pages)) != NULL) {
+			TAILQ_REMOVE(&free_pages, m, pageq);
+			vtballoon_free_page(sc, m);
+		}
+	}
+
+	KASSERT((TAILQ_EMPTY(&sc->vtballoon_pages) &&
+	    sc->vtballoon_current_npages == 0) ||
+	    (!TAILQ_EMPTY(&sc->vtballoon_pages) &&
+	    sc->vtballoon_current_npages != 0), ("balloon empty?"));
+}
+
+static void
+vtballoon_send_page_frames(struct vtballoon_softc *sc, struct virtqueue *vq,
+    int npages)
+{
+	struct sglist sg;
+	struct sglist_seg segs[1];
+	void *c;
+	int error;
+
+	sglist_init(&sg, 1, segs);
+
+	error = sglist_append(&sg, sc->vtballoon_page_frames,
+	    npages * sizeof(uint32_t));
+	KASSERT(error == 0, ("error adding page frames to sglist"));
+
+	error = virtqueue_enqueue(vq, vq, &sg, 1, 0);
+	KASSERT(error == 0, ("error enqueuing page frames to virtqueue"));
+	virtqueue_notify(vq);
+
+	/*
+	 * Inflate and deflate operations are done synchronously. The
+	 * interrupt handler will wake us up.
+	 */
+	VTBALLOON_LOCK(sc);
+	while ((c = virtqueue_dequeue(vq, NULL)) == NULL)
+		msleep_spin(sc, VTBALLOON_MTX(sc), "vtbspf", 0);
+	VTBALLOON_UNLOCK(sc);
+
+	KASSERT(c == vq, ("unexpected balloon operation response"));
+}
+
+static void
+vtballoon_pop(struct vtballoon_softc *sc)
+{
+
+	while (!TAILQ_EMPTY(&sc->vtballoon_pages))
+		vtballoon_deflate(sc, sc->vtballoon_current_npages);
+}
+
+static void
+vtballoon_stop(struct vtballoon_softc *sc)
+{
+
+	virtqueue_disable_intr(sc->vtballoon_inflate_vq);
+	virtqueue_disable_intr(sc->vtballoon_deflate_vq);
+
+	virtio_stop(sc->vtballoon_dev);
+}
+
+static vm_page_t
+vtballoon_alloc_page(struct vtballoon_softc *sc)
+{
+	vm_page_t m;
+
+	m = vm_page_alloc(NULL, 0, VM_ALLOC_NORMAL | VM_ALLOC_WIRED |
+	    VM_ALLOC_NOOBJ);
+	if (m != NULL)
+		sc->vtballoon_current_npages++;
+
+	return (m);
+}
+
+static void
+vtballoon_free_page(struct vtballoon_softc *sc, vm_page_t m)
+{
+
+	vm_page_unwire(m, 0);
+	vm_page_free(m);
+	sc->vtballoon_current_npages--;
+}
+
+static uint32_t
+vtballoon_desired_size(struct vtballoon_softc *sc)
+{
+	uint32_t desired;
+
+	desired = virtio_read_dev_config_4(sc->vtballoon_dev,
+	    offsetof(struct virtio_balloon_config, num_pages));
+
+	return (le32toh(desired));
+}
+
+static void
+vtballoon_update_size(struct vtballoon_softc *sc)
+{
+
+	virtio_write_dev_config_4(sc->vtballoon_dev,
+	    offsetof(struct virtio_balloon_config, actual),
+	    htole32(sc->vtballoon_current_npages));
+}
+
+static int
+vtballoon_sleep(struct vtballoon_softc *sc)
+{
+	int rc, timeout;
+	uint32_t current, desired;
+
+	rc = 0;
+	current = sc->vtballoon_current_npages;
+
+	VTBALLOON_LOCK(sc);
+	for (;;) {
+		if (sc->vtballoon_flags & VTBALLOON_FLAG_DETACH) {
+			rc = 1;
+			break;
+		}
+
+		desired = vtballoon_desired_size(sc);
+		sc->vtballoon_desired_npages = desired;
+
+		/*
+		 * If given, use non-zero timeout on the first time through
+		 * the loop. On subsequent times, timeout will be zero so
+		 * we will reevaluate the desired size of the balloon and
+		 * break out to retry if needed.
+		 */
+		timeout = sc->vtballoon_timeout;
+		sc->vtballoon_timeout = 0;
+
+		if (current > desired)
+			break;
+		if (current < desired && timeout == 0)
+			break;
+
+		msleep_spin(sc, VTBALLOON_MTX(sc), "vtbslp", timeout);
+	}
+	VTBALLOON_UNLOCK(sc);
+
+	return (rc);
+}
+
+static void
+vtballoon_thread(void *xsc)
+{
+	struct vtballoon_softc *sc;
+	uint32_t current, desired;
+
+	sc = xsc;
+
+	for (;;) {
+		if (vtballoon_sleep(sc) != 0)
+			break;
+
+		current = sc->vtballoon_current_npages;
+		desired = sc->vtballoon_desired_npages;
+
+		if (desired != current) {
+			if (desired > current)
+				vtballoon_inflate(sc, desired - current);
+			else
+				vtballoon_deflate(sc, current - desired);
+
+			vtballoon_update_size(sc);
+		}
+	}
+
+	kproc_exit(0);
+}
+
+static void
+vtballoon_add_sysctl(struct vtballoon_softc *sc)
+{
+	device_t dev;
+	struct sysctl_ctx_list *ctx;
+	struct sysctl_oid *tree;
+	struct sysctl_oid_list *child;
+
+	dev = sc->vtballoon_dev;
+	ctx = device_get_sysctl_ctx(dev);
+	tree = device_get_sysctl_tree(dev);
+	child = SYSCTL_CHILDREN(tree);
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "desired",
+	    CTLFLAG_RD, &sc->vtballoon_desired_npages, sizeof(uint32_t),
+	    "Desired balloon size in pages");
+
+	SYSCTL_ADD_UINT(ctx, child, OID_AUTO, "current",
+	    CTLFLAG_RD, &sc->vtballoon_current_npages, sizeof(uint32_t),
+	    "Current balloon size in pages");
+}
diff --git a/sys/dev/virtio/balloon/virtio_balloon.h b/sys/dev/virtio/balloon/virtio_balloon.h
new file mode 100644
index 0000000..f143341
--- /dev/null
+++ b/sys/dev/virtio/balloon/virtio_balloon.h
@@ -0,0 +1,62 @@
+/*-
+ * This header is BSD licensed so anyone can use the definitions to implement
+ * compatible drivers/servers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of IBM nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL IBM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+
+#ifndef _VIRTIO_BALLOON_H
+#define _VIRTIO_BALLOON_H
+
+/* Feature bits. */
+#define VIRTIO_BALLOON_F_MUST_TELL_HOST	0x1 /* Tell before reclaiming pages */
+#define VIRTIO_BALLOON_F_STATS_VQ	0x2 /* Memory stats virtqueue */
+
+/* Size of a PFN in the balloon interface. */
+#define VIRTIO_BALLOON_PFN_SHIFT 12
+
+struct virtio_balloon_config {
+	/* Number of pages host wants Guest to give up. */
+	uint32_t num_pages;
+
+	/* Number of pages we've actually got in balloon. */
+	uint32_t actual;
+};
+
+#define VIRTIO_BALLOON_S_SWAP_IN  0   /* Amount of memory swapped in */
+#define VIRTIO_BALLOON_S_SWAP_OUT 1   /* Amount of memory swapped out */
+#define VIRTIO_BALLOON_S_MAJFLT   2   /* Number of major faults */
+#define VIRTIO_BALLOON_S_MINFLT   3   /* Number of minor faults */
+#define VIRTIO_BALLOON_S_MEMFREE  4   /* Total amount of free memory */
+#define VIRTIO_BALLOON_S_MEMTOT   5   /* Total amount of memory */
+#define VIRTIO_BALLOON_S_NR       6
+
+struct virtio_balloon_stat {
+	uint16_t tag;
+	uint64_t val;
+} __packed;
+
+#endif /* _VIRTIO_BALLOON_H */
diff --git a/sys/dev/virtio/block/virtio_blk.c b/sys/dev/virtio/block/virtio_blk.c
new file mode 100644
index 0000000..21d7703
--- /dev/null
+++ b/sys/dev/virtio/block/virtio_blk.c
@@ -0,0 +1,1238 @@
+/*-
+ * Copyright (c) 2011, Bryan Venteicher <bryanv@daemoninthecloset.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice unmodified, this list of conditions, and the following
+ *    disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* Driver for VirtIO block devices. */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/kernel.h>
+#include <sys/bio.h>
+#include <sys/malloc.h>
+#include <sys/module.h>
+#include <sys/sglist.h>
+#include <sys/lock.h>
+#include <sys/mutex.h>
+#include <sys/queue.h>
+#include <sys/taskqueue.h>
+
+#include <geom/geom_disk.h>
+
+#include <machine/bus.h>
+#include <machine/resource.h>
+#include <sys/bus.h>
+#include <sys/rman.h>
+
+#include <dev/virtio/virtio.h>
+#include <dev/virtio/virtqueue.h>
+#include <dev/virtio/block/virtio_blk.h>
+
+#include "virtio_if.h"
+
+struct vtblk_request {
+	struct virtio_blk_outhdr	 vbr_hdr;
+	struct bio			*vbr_bp;
+	uint8_t				 vbr_ack;
+
+	TAILQ_ENTRY(vtblk_request)	 vbr_link;
+};
+
+struct vtblk_softc {
+	device_t		 vtblk_dev;
+	struct mtx		 vtblk_mtx;
+	uint64_t		 vtblk_features;
+	uint32_t		 vtblk_flags;
+#define VTBLK_FLAG_INDIRECT	0x0001
+#define VTBLK_FLAG_READONLY	0x0002
+#define VTBLK_FLAG_DETACH	0x0004
+#define VTBLK_FLAG_SUSPEND	0x0008
+#define VTBLK_FLAG_DUMPING	0x0010
+#define VTBLK_FLAG_BARRIER	0x0020
+
+	struct virtqueue	*vtblk_vq;
+	struct sglist		*vtblk_sglist;
+	struct disk		*vtblk_disk;
+
+	struct bio_queue_head	 vtblk_bioq;
+	TAILQ_HEAD(, vtblk_request)
+				 vtblk_req_free;
+	TAILQ_HEAD(, vtblk_request)
+				 vtblk_req_ready;
+	struct vtblk_request	*vtblk_req_ordered;
+
+	struct taskqueue	*vtblk_tq;
+	struct task		 vtblk_intr_task;
+
+	int			 vtblk_max_nsegs;
+	int			 vtblk_request_count;
+
+	struct vtblk_request	 vtblk_dump_request;
+};
+
+static struct virtio_feature_desc vtblk_feature_desc[] = {
+	{ VIRTIO_BLK_F_BARRIER,		"HostBarrier"	},
+	{ VIRTIO_BLK_F_SIZE_MAX,	"MaxSegSize"	},
+	{ VIRTIO_BLK_F_SEG_MAX,		"MaxNumSegs"	},
+	{ VIRTIO_BLK_F_GEOMETRY,	"DiskGeometry"	},
+	{ VIRTIO_BLK_F_RO,		"ReadOnly"	},
+	{ VIRTIO_BLK_F_BLK_SIZE,	"BlockSize"	},
+	{ VIRTIO_BLK_F_SCSI,		"SCSICmds"	},
+	{ VIRTIO_BLK_F_FLUSH,		"FlushCmd"	},
+	{ VIRTIO_BLK_F_TOPOLOGY,	"Topology"	},
+
+	{ 0, NULL }
+};
+
+static int	vtblk_modevent(module_t, int, void *);
+
+static int	vtblk_probe(device_t);
+static int	vtblk_attach(device_t);
+static int	vtblk_detach(device_t);
+static int	vtblk_suspend(device_t);
+static int	vtblk_resume(device_t);
+static int	vtblk_shutdown(device_t);
+
+static int	vtblk_open(struct disk *);
+static int	vtblk_close(struct disk *);
+static int	vtblk_ioctl(struct disk *, u_long, void *, int,
+		    struct thread *);
+static int	vtblk_dump(void *, void *, vm_offset_t, off_t, size_t);
+static void	vtblk_strategy(struct bio *);
+
+static void	vtblk_negotiate_features(struct vtblk_softc *);
+static int	vtblk_maximum_segments(struct vtblk_softc *,
+		    struct virtio_blk_config *);
+static int	vtblk_alloc_virtqueue(struct vtblk_softc *);
+static void	vtblk_alloc_disk(struct vtblk_softc *,
+		    struct virtio_blk_config *);
+static void	vtblk_create_disk(struct vtblk_softc *);
+
+static int	vtblk_quiesce(struct vtblk_softc *);
+static void	vtblk_startio(struct vtblk_softc *);
+static struct vtblk_request * vtblk_bio_request(struct vtblk_softc *);
+static int	vtblk_execute_request(struct vtblk_softc *,
+		    struct vtblk_request *);
+
+static int	vtblk_vq_intr(void *);
+static void	vtblk_intr_task(void *, int);
+
+static void	vtblk_stop(struct vtblk_softc *);
+
+static void	vtblk_get_ident(struct vtblk_softc *);
+static void	vtblk_prepare_dump(struct vtblk_softc *);
+static int	vtblk_write_dump(struct vtblk_softc *, void *, off_t, size_t);
+static int	vtblk_flush_dump(struct vtblk_softc *);
+static int	vtblk_poll_request(struct vtblk_softc *,
+		    struct vtblk_request *);
+
+static void	vtblk_finish_completed(struct vtblk_softc *);
+static void	vtblk_drain_vq(struct vtblk_softc *, int);
+static void	vtblk_drain(struct vtblk_softc *);
+
+static int	vtblk_alloc_requests(struct vtblk_softc *);
+static void	vtblk_free_requests(struct vtblk_softc *);
+static struct vtblk_request * vtblk_dequeue_request(struct vtblk_softc *);
+static void	vtblk_enqueue_request(struct vtblk_softc *,
+		    struct vtblk_request *);
+
+static struct vtblk_request * vtblk_dequeue_ready(struct vtblk_softc *);
+static void	vtblk_enqueue_ready(struct vtblk_softc *,
+		    struct vtblk_request *);
+
+static int	vtblk_request_error(struct vtblk_request *);
+static void	vtblk_finish_bio(struct bio *, int);
+
+/* Tunables. */
+static int vtblk_no_ident = 0;
+TUNABLE_INT("hw.vtblk.no_ident", &vtblk_no_ident);
+
+/* Features desired/implemented by this driver. */
+#define VTBLK_FEATURES \
+    (VIRTIO_BLK_F_BARRIER		| \
+     VIRTIO_BLK_F_SIZE_MAX		| \
+     VIRTIO_BLK_F_SEG_MAX		| \
+     VIRTIO_BLK_F_GEOMETRY		| \
+     VIRTIO_BLK_F_RO			| \
+     VIRTIO_BLK_F_BLK_SIZE		| \
+     VIRTIO_BLK_F_FLUSH			| \
+     VIRTIO_RING_F_INDIRECT_DESC)
+
+#define VTBLK_MTX(_sc)		&(_sc)->vtblk_mtx
+#define VTBLK_LOCK_INIT(_sc, _name) \
+				mtx_init(VTBLK_MTX((_sc)), (_name), \
+				    "VTBLK Lock", MTX_DEF)
+#define VTBLK_LOCK(_sc)		mtx_lock(VTBLK_MTX((_sc)))
+#define VTBLK_UNLOCK(_sc)	mtx_unlock(VTBLK_MTX((_sc)))
+#define VTBLK_LOCK_DESTROY(_sc)	mtx_destroy(VTBLK_MTX((_sc)))
+#define VTBLK_LOCK_ASSERT(_sc)	mtx_assert(VTBLK_MTX((_sc)), MA_OWNED)
+#define VTBLK_LOCK_ASSERT_NOTOWNED(_sc) \
+				mtx_assert(VTBLK_MTX((_sc)), MA_NOTOWNED)
+
+#define VTBLK_DISK_NAME		"vtbd"
+#define VTBLK_QUIESCE_TIMEOUT	(30 * hz)
+
+/*
+ * Each block request uses at least two segments - one for the header
+ * and one for the status.
+ */
+#define VTBLK_MIN_SEGMENTS	2
+
+static device_method_t vtblk_methods[] = {
+	/* Device methods. */
+	DEVMETHOD(device_probe,		vtblk_probe),
+	DEVMETHOD(device_attach,	vtblk_attach),
+	DEVMETHOD(device_detach,	vtblk_detach),
+	DEVMETHOD(device_suspend,	vtblk_suspend),
+	DEVMETHOD(device_resume,	vtblk_resume),
+	DEVMETHOD(device_shutdown,	vtblk_shutdown),
+
+	DEVMETHOD_END
+};
+
+static driver_t vtblk_driver = {
+	"vtblk",
+	vtblk_methods,
+	sizeof(struct vtblk_softc)
+};
+static devclass_t vtblk_devclass;
+
+DRIVER_MODULE(virtio_blk, virtio_pci, vtblk_driver, vtblk_devclass,
+    vtblk_modevent, 0);
+MODULE_VERSION(virtio_blk, 1);
+MODULE_DEPEND(virtio_blk, virtio, 1, 1, 1);
+
+static int
+vtblk_modevent(module_t mod, int type, void *unused)
+{
+	int error;
+
+	error = 0;
+
+	switch (type) {
+	case MOD_LOAD:
+	case MOD_QUIESCE:
+	case MOD_UNLOAD:
+	case MOD_SHUTDOWN:
+		break;
+	default:
+		error = EOPNOTSUPP;
+		break;
+	}
+
+	return (error);
+}
+
+static int
+vtblk_probe(device_t dev)
+{
+
+	if (virtio_get_device_type(dev) != VIRTIO_ID_BLOCK)
+		return (ENXIO);
+
+	device_set_desc(dev, "VirtIO Block Adapter");
+
+	return (BUS_PROBE_DEFAULT);
+}
+
+static int
+vtblk_attach(device_t dev)
+{
+	struct vtblk_softc *sc;
+	struct virtio_blk_config blkcfg;
+	int error;
+
+	sc = device_get_softc(dev);
+	sc->vtblk_dev = dev;
+
+	VTBLK_LOCK_INIT(sc, device_get_nameunit(dev));
+
+	bioq_init(&sc->vtblk_bioq);
+	TAILQ_INIT(&sc->vtblk_req_free);
+	TAILQ_INIT(&sc->vtblk_req_ready);
+
+	virtio_set_feature_desc(dev, vtblk_feature_desc);
+	vtblk_negotiate_features(sc);
+
+	if (virtio_with_feature(dev, VIRTIO_RING_F_INDIRECT_DESC))
+		sc->vtblk_flags |= VTBLK_FLAG_INDIRECT;
+	if (virtio_with_feature(dev, VIRTIO_BLK_F_RO))
+		sc->vtblk_flags |= VTBLK_FLAG_READONLY;
+	if (virtio_with_feature(dev, VIRTIO_BLK_F_BARRIER))
+		sc->vtblk_flags |= VTBLK_FLAG_BARRIER;
+
+	/* Get local copy of config. */
+	virtio_read_device_config(dev, 0, &blkcfg,
+	    sizeof(struct virtio_blk_config));
+
+	/*
+	 * With the current sglist(9) implementation, it is not easy
+	 * for us to support a maximum segment size as adjacent
+	 * segments are coalesced. For now, just make sure it's larger
+	 * than the maximum supported transfer size.
+	 */
+	if (virtio_with_feature(dev, VIRTIO_BLK_F_SIZE_MAX)) {
+		if (blkcfg.size_max < MAXPHYS) {
+			error = ENOTSUP;
+			device_printf(dev, "host requires unsupported "
+			    "maximum segment size feature\n");
+			goto fail;
+		}
+	}
+
+	sc->vtblk_max_nsegs = vtblk_maximum_segments(sc, &blkcfg);
+	if (sc->vtblk_max_nsegs <= VTBLK_MIN_SEGMENTS) {
+		error = EINVAL;
+		device_printf(dev, "fewer than minimum number of segments "
+		    "allowed: %d\n", sc->vtblk_max_nsegs);
+		goto fail;
+	}
+
+	sc->vtblk_sglist = sglist_alloc(sc->vtblk_max_nsegs, M_NOWAIT);
+	if (sc->vtblk_sglist == NULL) {
+		error = ENOMEM;
+		device_printf(dev, "cannot allocate sglist\n");
+		goto fail;
+	}
+
+	error = vtblk_alloc_virtqueue(sc);
+	if (error) {
+		device_printf(dev, "cannot allocate virtqueue\n");
+		goto fail;
+	}
+
+	error = vtblk_alloc_requests(sc);
+	if (error) {
+		device_printf(dev, "cannot preallocate requests\n");
+		goto fail;
+	}
+
+	vtblk_alloc_disk(sc, &blkcfg);
+
+	TASK_INIT(&sc->vtblk_intr_task, 0, vtblk_intr_task, sc);
+	sc->vtblk_tq = taskqueue_create_fast("vtblk_taskq", M_NOWAIT,
+	    taskqueue_thread_enqueue, &sc->vtblk_tq);
+	if (sc->vtblk_tq == NULL) {
+		error = ENOMEM;
+		device_printf(dev, "cannot allocate taskqueue\n");
+		goto fail;
+	}
+
+	error = virtio_setup_intr(dev, INTR_TYPE_BIO | INTR_ENTROPY);
+	if (error) {
+		device_printf(dev, "cannot setup virtqueue interrupt\n");
+		goto fail;
+	}
+
+	taskqueue_start_threads(&sc->vtblk_tq, 1, PI_DISK, "%s taskq",
+	    device_get_nameunit(dev));
+
+	vtblk_create_disk(sc);
+
+	virtqueue_enable_intr(sc->vtblk_vq);
+
+fail:
+	if (error)
+		vtblk_detach(dev);
+
+	return (error);
+}
+
+static int
+vtblk_detach(device_t dev)
+{
+	struct vtblk_softc *sc;
+
+	sc = device_get_softc(dev);
+
+	VTBLK_LOCK(sc);
+	sc->vtblk_flags |= VTBLK_FLAG_DETACH;
+	if (device_is_attached(dev))
+		vtblk_stop(sc);
+	VTBLK_UNLOCK(sc);
+
+	if (sc->vtblk_tq != NULL) {
+		taskqueue_drain(sc->vtblk_tq, &sc->vtblk_intr_task);
+		taskqueue_free(sc->vtblk_tq);
+		sc->vtblk_tq = NULL;
+	}
+
+	vtblk_drain(sc);
+
+	if (sc->vtblk_disk != NULL) {
+		disk_destroy(sc->vtblk_disk);
+		sc->vtblk_disk = NULL;
+	}
+
+	if (sc->vtblk_sglist != NULL) {
+		sglist_free(sc->vtblk_sglist);
+		sc->vtblk_sglist = NULL;
+	}
+
+	VTBLK_LOCK_DESTROY(sc);
+
+	return (0);
+}
+
+static int
+vtblk_suspend(device_t dev)
+{
+	struct vtblk_softc *sc;
+	int error;
+
+	sc = device_get_softc(dev);
+
+	VTBLK_LOCK(sc);
+	sc->vtblk_flags |= VTBLK_FLAG_SUSPEND;
+	/* XXX BMV: virtio_stop(), etc needed here? */
+	error = vtblk_quiesce(sc);
+	if (error)
+		sc->vtblk_flags &= ~VTBLK_FLAG_SUSPEND;
+	VTBLK_UNLOCK(sc);
+
+	return (error);
+}
+
+static int
+vtblk_resume(device_t dev)
+{
+	struct vtblk_softc *sc;
+
+	sc = device_get_softc(dev);
+
+	VTBLK_LOCK(sc);
+	/* XXX BMV: virtio_reinit(), etc needed here? */
+	sc->vtblk_flags &= ~VTBLK_FLAG_SUSPEND;
+	vtblk_startio(sc);
+	VTBLK_UNLOCK(sc);
+
+	return (0);
+}
+
+static int
+vtblk_shutdown(device_t dev)
+{
+
+	return (0);
+}
+
+static int
+vtblk_open(struct disk *dp)
+{
+	struct vtblk_softc *sc;
+
+	if ((sc = dp->d_drv1) == NULL)
+		return (ENXIO);
+
+	return (sc->vtblk_flags & VTBLK_FLAG_DETACH ? ENXIO : 0);
+}
+
+static int
+vtblk_close(struct disk *dp)
+{
+	struct vtblk_softc *sc;
+
+	if ((sc = dp->d_drv1) == NULL)
+		return (ENXIO);
+
+	return (0);
+}
+
+static int
+vtblk_ioctl(struct disk *dp, u_long cmd, void *addr, int flag,
+    struct thread *td)
+{
+	struct vtblk_softc *sc;
+
+	if ((sc = dp->d_drv1) == NULL)
+		return (ENXIO);
+
+	return (ENOTTY);
+}
+
+static int
+vtblk_dump(void *arg, void *virtual, vm_offset_t physical, off_t offset,
+    size_t length)
+{
+	struct disk *dp;
+	struct vtblk_softc *sc;
+	int error;
+
+	dp = arg;
+
+	if ((sc = dp->d_drv1) == NULL)
+		return (ENXIO);
+
+	VTBLK_LOCK(sc);
+
+	if ((sc->vtblk_flags & VTBLK_FLAG_DUMPING) == 0) {
+		vtblk_prepare_dump(sc);
+		sc->vtblk_flags |= VTBLK_FLAG_DUMPING;
+	}
+
+	if (length > 0)
+		error = vtblk_write_dump(sc, virtual, offset, length);
+	else if (virtual == NULL && offset == 0)
+		error = vtblk_flush_dump(sc);
+	else {
+		error = EINVAL;
+		sc->vtblk_flags &= ~VTBLK_FLAG_DUMPING;
+	}
+
+	VTBLK_UNLOCK(sc);
+
+	return (error);
+}
+
+static void
+vtblk_strategy(struct bio *bp)
+{
+	struct vtblk_softc *sc;
+
+	if ((sc = bp->bio_disk->d_drv1) == NULL) {
+		vtblk_finish_bio(bp, EINVAL);
+		return;
+	}
+
+	/*
+	 * Fail any write if RO. Unfortunately, there does not seem to
+	 * be a better way to report our readonly'ness to GEOM above.
+	 */
+	if (sc->vtblk_flags & VTBLK_FLAG_READONLY &&
+	    (bp->bio_cmd == BIO_WRITE || bp->bio_cmd == BIO_FLUSH)) {
+		vtblk_finish_bio(bp, EROFS);
+		return;
+	}
+
+#ifdef INVARIANTS
+	/*
+	 * Prevent read/write buffers spanning too many segments from
+	 * getting into the queue. This should only trip if d_maxsize
+	 * was incorrectly set.
+	 */
+	if (bp->bio_cmd == BIO_READ || bp->bio_cmd == BIO_WRITE) {
+		int nsegs, max_nsegs;
+
+		nsegs = sglist_count(bp->bio_data, bp->bio_bcount);
+		max_nsegs = sc->vtblk_max_nsegs - VTBLK_MIN_SEGMENTS;
+
+		KASSERT(nsegs <= max_nsegs,
+		    ("bio %p spanned too many segments: %d, max: %d",
+		    bp, nsegs, max_nsegs));
+	}
+#endif
+
+	VTBLK_LOCK(sc);
+	if (sc->vtblk_flags & VTBLK_FLAG_DETACH)
+		vtblk_finish_bio(bp, ENXIO);
+	else {
+		bioq_disksort(&sc->vtblk_bioq, bp);
+
+		if ((sc->vtblk_flags & VTBLK_FLAG_SUSPEND) == 0)
+			vtblk_startio(sc);
+	}
+	VTBLK_UNLOCK(sc);
+}
+
+static void
+vtblk_negotiate_features(struct vtblk_softc *sc)
+{
+	device_t dev;
+	uint64_t features;
+
+	dev = sc->vtblk_dev;
+	features = VTBLK_FEATURES;
+
+	sc->vtblk_features = virtio_negotiate_features(dev, features);
+}
+
+static int
+vtblk_maximum_segments(struct vtblk_softc *sc,
+    struct virtio_blk_config *blkcfg)
+{
+	device_t dev;
+	int nsegs;
+
+	dev = sc->vtblk_dev;
+	nsegs = VTBLK_MIN_SEGMENTS;
+
+	if (virtio_with_feature(dev, VIRTIO_BLK_F_SEG_MAX)) {
+		nsegs += MIN(blkcfg->seg_max, MAXPHYS / PAGE_SIZE + 1);
+		if (sc->vtblk_flags & VTBLK_FLAG_INDIRECT)
+			nsegs = MIN(nsegs, VIRTIO_MAX_INDIRECT);
+	} else
+		nsegs += 1;
+
+	return (nsegs);
+}
+
+static int
+vtblk_alloc_virtqueue(struct vtblk_softc *sc)
+{
+	device_t dev;
+	struct vq_alloc_info vq_info;
+
+	dev = sc->vtblk_dev;
+
+	VQ_ALLOC_INFO_INIT(&vq_info, sc->vtblk_max_nsegs,
+	    vtblk_vq_intr, sc, &sc->vtblk_vq,
+	    "%s request", device_get_nameunit(dev));
+
+	return (virtio_alloc_virtqueues(dev, 0, 1, &vq_info));
+}
+
+static void
+vtblk_alloc_disk(struct vtblk_softc *sc, struct virtio_blk_config *blkcfg)
+{
+	device_t dev;
+	struct disk *dp;
+
+	dev = sc->vtblk_dev;
+
+	sc->vtblk_disk = dp = disk_alloc();
+	dp->d_open = vtblk_open;
+	dp->d_close = vtblk_close;
+	dp->d_ioctl = vtblk_ioctl;
+	dp->d_strategy = vtblk_strategy;
+	dp->d_name = VTBLK_DISK_NAME;
+	dp->d_unit = device_get_unit(dev);
+	dp->d_drv1 = sc;
+
+	if ((sc->vtblk_flags & VTBLK_FLAG_READONLY) == 0)
+		dp->d_dump = vtblk_dump;
+
+	/* Capacity is always in 512-byte units. */
+	dp->d_mediasize = blkcfg->capacity * 512;
+
+	if (virtio_with_feature(dev, VIRTIO_BLK_F_BLK_SIZE))
+		dp->d_sectorsize = blkcfg->blk_size;
+	else
+		dp->d_sectorsize = 512;
+
+	/*
+	 * The VirtIO maximum I/O size is given in terms of segments.
+	 * However, FreeBSD limits I/O size by logical buffer size, not
+	 * by physically contiguous pages. Therefore, we have to assume
+	 * no pages are contiguous. This may impose an artificially low
+	 * maximum I/O size. But in practice, since QEMU advertises 128
+	 * segments, this gives us a maximum IO size of 125 * PAGE_SIZE,
+	 * which is typically greater than MAXPHYS. Eventually we should
+	 * just advertise MAXPHYS and split buffers that are too big.
+	 *
+	 * Note we must subtract one additional segment in case of non
+	 * page aligned buffers.
+	 */
+	dp->d_maxsize = (sc->vtblk_max_nsegs - VTBLK_MIN_SEGMENTS - 1) *
+	    PAGE_SIZE;
+	if (dp->d_maxsize < PAGE_SIZE)
+		dp->d_maxsize = PAGE_SIZE; /* XXX */
+
+	if (virtio_with_feature(dev, VIRTIO_BLK_F_GEOMETRY)) {
+		dp->d_fwsectors = blkcfg->geometry.sectors;
+		dp->d_fwheads = blkcfg->geometry.heads;
+	}
+
+	if (virtio_with_feature(dev, VIRTIO_BLK_F_FLUSH))
+		dp->d_flags |= DISKFLAG_CANFLUSHCACHE;
+}
+
+static void
+vtblk_create_disk(struct vtblk_softc *sc)
+{
+	struct disk *dp;
+
+	dp = sc->vtblk_disk;
+
+	/*
+	 * Retrieving the identification string must be done after
+	 * the virtqueue interrupt is setup otherwise it will hang.
+	 */
+	vtblk_get_ident(sc);
+
+	device_printf(sc->vtblk_dev, "%juMB (%ju %u byte sectors)\n",
+	    (uintmax_t) dp->d_mediasize >> 20,
+	    (uintmax_t) dp->d_mediasize / dp->d_sectorsize,
+	    dp->d_sectorsize);
+
+	disk_create(dp, DISK_VERSION);
+}
+
+static int
+vtblk_quiesce(struct vtblk_softc *sc)
+{
+	int error;
+
+	error = 0;
+
+	VTBLK_LOCK_ASSERT(sc);
+
+	while (!virtqueue_empty(sc->vtblk_vq)) {
+		if (mtx_sleep(&sc->vtblk_vq, VTBLK_MTX(sc), PRIBIO, "vtblkq",
+		    VTBLK_QUIESCE_TIMEOUT) == EWOULDBLOCK) {
+			error = EBUSY;
+			break;
+		}
+	}
+
+	return (error);
+}
+
+static void
+vtblk_startio(struct vtblk_softc *sc)
+{
+	struct virtqueue *vq;
+	struct vtblk_request *req;
+	int enq;
+
+	vq = sc->vtblk_vq;
+	enq = 0;
+
+	VTBLK_LOCK_ASSERT(sc);
+
+	while (!virtqueue_full(vq)) {
+		if ((req = vtblk_dequeue_ready(sc)) == NULL)
+			req = vtblk_bio_request(sc);
+		if (req == NULL)
+			break;
+
+		if (vtblk_execute_request(sc, req) != 0) {
+			vtblk_enqueue_ready(sc, req);
+			break;
+		}
+
+		enq++;
+	}
+
+	if (enq > 0)
+		virtqueue_notify(vq);
+}
+
+static struct vtblk_request *
+vtblk_bio_request(struct vtblk_softc *sc)
+{
+	struct bio_queue_head *bioq;
+	struct vtblk_request *req;
+	struct bio *bp;
+
+	bioq = &sc->vtblk_bioq;
+
+	if (bioq_first(bioq) == NULL)
+		return (NULL);
+
+	req = vtblk_dequeue_request(sc);
+	if (req == NULL)
+		return (NULL);
+
+	bp = bioq_takefirst(bioq);
+	req->vbr_bp = bp;
+	req->vbr_ack = -1;
+	req->vbr_hdr.ioprio = 1;
+
+	switch (bp->bio_cmd) {
+	case BIO_FLUSH:
+		req->vbr_hdr.type = VIRTIO_BLK_T_FLUSH;
+		break;
+	case BIO_READ:
+		req->vbr_hdr.type = VIRTIO_BLK_T_IN;
+		req->vbr_hdr.sector = bp->bio_offset / 512;
+		break;
+	case BIO_WRITE:
+		req->vbr_hdr.type = VIRTIO_BLK_T_OUT;
+		req->vbr_hdr.sector = bp->bio_offset / 512;
+		break;
+	default:
+		panic("%s: bio with unhandled cmd: %d", __FUNCTION__,
+		    bp->bio_cmd);
+	}
+
+	return (req);
+}
+
+static int
+vtblk_execute_request(struct vtblk_softc *sc, struct vtblk_request *req)
+{
+	struct virtqueue *vq;
+	struct sglist *sg;
+	struct bio *bp;
+	int ordered, readable, writable, error;
+
+	vq = sc->vtblk_vq;
+	sg = sc->vtblk_sglist;
+	bp = req->vbr_bp;
+	ordered = 0;
+	writable = 0;
+
+	VTBLK_LOCK_ASSERT(sc);
+
+	/*
+	 * Wait until the ordered request completes before
+	 * executing subsequent requests.
+	 */
+	if (sc->vtblk_req_ordered != NULL)
+		return (EBUSY);
+
+	if (bp->bio_flags & BIO_ORDERED) {
+		if ((sc->vtblk_flags & VTBLK_FLAG_BARRIER) == 0) {
+			/*
+			 * This request will be executed once all
+			 * the in-flight requests are completed.
+			 */
+			if (!virtqueue_empty(vq))
+				return (EBUSY);
+			ordered = 1;
+		} else
+			req->vbr_hdr.type |= VIRTIO_BLK_T_BARRIER;
+	}
+
+	sglist_reset(sg);
+
+	sglist_append(sg, &req->vbr_hdr, sizeof(struct virtio_blk_outhdr));
+
+	if (bp->bio_cmd == BIO_READ || bp->bio_cmd == BIO_WRITE) {
+		error = sglist_append(sg, bp->bio_data, bp->bio_bcount);
+		if (error || sg->sg_nseg == sg->sg_maxseg)
+			panic("%s: data buffer too big bio:%p error:%d",
+			    __FUNCTION__, bp, error);
+
+		/* BIO_READ means the host writes into our buffer. */
+		if (bp->bio_cmd == BIO_READ)
+			writable = sg->sg_nseg - 1;
+	}
+
+	writable++;
+	sglist_append(sg, &req->vbr_ack, sizeof(uint8_t));
+	readable = sg->sg_nseg - writable;
+
+	error = virtqueue_enqueue(vq, req, sg, readable, writable);
+	if (error == 0 && ordered)
+		sc->vtblk_req_ordered = req;
+
+	return (error);
+}
+
+static int
+vtblk_vq_intr(void *xsc)
+{
+	struct vtblk_softc *sc;
+
+	sc = xsc;
+
+	virtqueue_disable_intr(sc->vtblk_vq);
+	taskqueue_enqueue_fast(sc->vtblk_tq, &sc->vtblk_intr_task);
+
+	return (1);
+}
+
+static void
+vtblk_intr_task(void *arg, int pending)
+{
+	struct vtblk_softc *sc;
+	struct virtqueue *vq;
+
+	sc = arg;
+	vq = sc->vtblk_vq;
+
+	VTBLK_LOCK(sc);
+	if (sc->vtblk_flags & VTBLK_FLAG_DETACH) {
+		VTBLK_UNLOCK(sc);
+		return;
+	}
+
+	vtblk_finish_completed(sc);
+
+	if ((sc->vtblk_flags & VTBLK_FLAG_SUSPEND) == 0)
+		vtblk_startio(sc);
+	else
+		wakeup(&sc->vtblk_vq);
+
+	if (virtqueue_enable_intr(vq) != 0) {
+		virtqueue_disable_intr(vq);
+		VTBLK_UNLOCK(sc);
+		taskqueue_enqueue_fast(sc->vtblk_tq,
+		    &sc->vtblk_intr_task);
+		return;
+	}
+
+	VTBLK_UNLOCK(sc);
+}
+
+static void
+vtblk_stop(struct vtblk_softc *sc)
+{
+
+	virtqueue_disable_intr(sc->vtblk_vq);
+	virtio_stop(sc->vtblk_dev);
+}
+
+static void
+vtblk_get_ident(struct vtblk_softc *sc)
+{
+	struct bio buf;
+	struct disk *dp;
+	struct vtblk_request *req;
+	int len, error;
+
+	dp = sc->vtblk_disk;
+	len = MIN(VIRTIO_BLK_ID_BYTES, DISK_IDENT_SIZE);
+
+	if (vtblk_no_ident != 0)
+		return;
+
+	req = vtblk_dequeue_request(sc);
+	if (req == NULL)
+		return;
+
+	req->vbr_ack = -1;
+	req->vbr_hdr.type = VIRTIO_BLK_T_GET_ID;
+	req->vbr_hdr.ioprio = 1;
+	req->vbr_hdr.sector = 0;
+
+	req->vbr_bp = &buf;
+	bzero(&buf, sizeof(struct bio));
+
+	buf.bio_cmd = BIO_READ;
+	buf.bio_data = dp->d_ident;
+	buf.bio_bcount = len;
+
+	VTBLK_LOCK(sc);
+	error = vtblk_poll_request(sc, req);
+	VTBLK_UNLOCK(sc);
+
+	vtblk_enqueue_request(sc, req);
+
+	if (error) {
+		device_printf(sc->vtblk_dev,
+		    "error getting device identifier: %d\n", error);
+	}
+}
+
+static void
+vtblk_prepare_dump(struct vtblk_softc *sc)
+{
+	device_t dev;
+	struct virtqueue *vq;
+
+	dev = sc->vtblk_dev;
+	vq = sc->vtblk_vq;
+
+	vtblk_stop(sc);
+
+	/*
+	 * Drain all requests caught in-flight in the virtqueue,
+	 * skipping biodone(). When dumping, only one request is
+	 * outstanding at a time, and we just poll the virtqueue
+	 * for the response.
+	 */
+	vtblk_drain_vq(sc, 1);
+
+	if (virtio_reinit(dev, sc->vtblk_features) != 0)
+		panic("cannot reinit VirtIO block device during dump");
+
+	virtqueue_disable_intr(vq);
+	virtio_reinit_complete(dev);
+}
+
+static int
+vtblk_write_dump(struct vtblk_softc *sc, void *virtual, off_t offset,
+    size_t length)
+{
+	struct bio buf;
+	struct vtblk_request *req;
+
+	req = &sc->vtblk_dump_request;
+	req->vbr_ack = -1;
+	req->vbr_hdr.type = VIRTIO_BLK_T_OUT;
+	req->vbr_hdr.ioprio = 1;
+	req->vbr_hdr.sector = offset / 512;
+
+	req->vbr_bp = &buf;
+	bzero(&buf, sizeof(struct bio));
+
+	buf.bio_cmd = BIO_WRITE;
+	buf.bio_data = virtual;
+	buf.bio_bcount = length;
+
+	return (vtblk_poll_request(sc, req));
+}
+
+static int
+vtblk_flush_dump(struct vtblk_softc *sc)
+{
+	struct bio buf;
+	struct vtblk_request *req;
+
+	req = &sc->vtblk_dump_request;
+	req->vbr_ack = -1;
+	req->vbr_hdr.type = VIRTIO_BLK_T_FLUSH;
+	req->vbr_hdr.ioprio = 1;
+	req->vbr_hdr.sector = 0;
+
+	req->vbr_bp = &buf;
+	bzero(&buf, sizeof(struct bio));
+
+	buf.bio_cmd = BIO_FLUSH;
+
+	return (vtblk_poll_request(sc, req));
+}
+
+static int
+vtblk_poll_request(struct vtblk_softc *sc, struct vtblk_request *req)
+{
+	struct virtqueue *vq;
+	struct vtblk_request *r;
+	int error;
+
+	vq = sc->vtblk_vq;
+
+	if (!virtqueue_empty(vq))
+		return (EBUSY);
+
+	error = vtblk_execute_request(sc, req);
+	if (error)
+		return (error);
+
+	virtqueue_notify(vq);
+
+	r = virtqueue_poll(vq, NULL);
+	KASSERT(r == req, ("unexpected request response: %p/%p", r, req));
+
+	error = vtblk_request_error(req);
+	if (error && bootverbose) {
+		device_printf(sc->vtblk_dev,
+		    "%s: IO error: %d\n", __FUNCTION__, error);
+	}
+
+	return (error);
+}
+
+static void
+vtblk_finish_completed(struct vtblk_softc *sc)
+{
+	struct vtblk_request *req;
+	struct bio *bp;
+	int error;
+
+	while ((req = virtqueue_dequeue(sc->vtblk_vq, NULL)) != NULL) {
+		bp = req->vbr_bp;
+
+		if (sc->vtblk_req_ordered != NULL) {
+			/* This should be the only outstanding request. */
+			MPASS(sc->vtblk_req_ordered == req);
+			sc->vtblk_req_ordered = NULL;
+		}
+
+		error = vtblk_request_error(req);
+		if (error)
+			disk_err(bp, "hard error", -1, 1);
+
+		vtblk_finish_bio(bp, error);
+		vtblk_enqueue_request(sc, req);
+	}
+}
+
+static void
+vtblk_drain_vq(struct vtblk_softc *sc, int skip_done)
+{
+	struct virtqueue *vq;
+	struct vtblk_request *req;
+	int last;
+
+	vq = sc->vtblk_vq;
+	last = 0;
+
+	while ((req = virtqueue_drain(vq, &last)) != NULL) {
+		if (!skip_done)
+			vtblk_finish_bio(req->vbr_bp, ENXIO);
+
+		vtblk_enqueue_request(sc, req);
+	}
+
+	sc->vtblk_req_ordered = NULL;
+	KASSERT(virtqueue_empty(vq), ("virtqueue not empty"));
+}
+
+static void
+vtblk_drain(struct vtblk_softc *sc)
+{
+	struct bio_queue_head *bioq;
+	struct vtblk_request *req;
+	struct bio *bp;
+
+	bioq = &sc->vtblk_bioq;
+
+	if (sc->vtblk_vq != NULL) {
+		vtblk_finish_completed(sc);
+		vtblk_drain_vq(sc, 0);
+	}
+
+	while ((req = vtblk_dequeue_ready(sc)) != NULL) {
+		vtblk_finish_bio(req->vbr_bp, ENXIO);
+		vtblk_enqueue_request(sc, req);
+	}
+
+	while (bioq_first(bioq) != NULL) {
+		bp = bioq_takefirst(bioq);
+		vtblk_finish_bio(bp, ENXIO);
+	}
+
+	vtblk_free_requests(sc);
+}
+
+#ifdef INVARIANTS
+static void
+vtblk_request_invariants(struct vtblk_request *req)
+{
+	int hdr_nsegs, ack_nsegs;
+
+	hdr_nsegs = sglist_count(&req->vbr_hdr, sizeof(req->vbr_hdr));
+	ack_nsegs = sglist_count(&req->vbr_ack, sizeof(req->vbr_ack));
+
+	KASSERT(hdr_nsegs == 1, ("request header crossed page boundary"));
+	KASSERT(ack_nsegs == 1, ("request ack crossed page boundary"));
+}
+#endif
+
+static int
+vtblk_alloc_requests(struct vtblk_softc *sc)
+{
+	struct vtblk_request *req;
+	int i, nreqs;
+
+	nreqs = virtqueue_size(sc->vtblk_vq);
+
+	/*
+	 * Preallocate sufficient requests to keep the virtqueue full. Each
+	 * request consumes VTBLK_MIN_SEGMENTS or more descriptors so reduce
+	 * the number allocated when indirect descriptors are not available.
+	 */
+	if ((sc->vtblk_flags & VTBLK_FLAG_INDIRECT) == 0)
+		nreqs /= VTBLK_MIN_SEGMENTS;
+
+	for (i = 0; i < nreqs; i++) {
+		req = malloc(sizeof(struct vtblk_request), M_DEVBUF, M_NOWAIT);
+		if (req == NULL)
+			return (ENOMEM);
+
+#ifdef INVARIANTS
+		vtblk_request_invariants(req);
+#endif
+
+		sc->vtblk_request_count++;
+		vtblk_enqueue_request(sc, req);
+	}
+
+	return (0);
+}
+
+static void
+vtblk_free_requests(struct vtblk_softc *sc)
+{
+	struct vtblk_request *req;
+
+	KASSERT(TAILQ_EMPTY(&sc->vtblk_req_ready),
+	    ("ready requests left on queue"));
+
+	while ((req = vtblk_dequeue_request(sc)) != NULL) {
+		sc->vtblk_request_count--;
+		free(req, M_DEVBUF);
+	}
+
+	KASSERT(sc->vtblk_request_count == 0,
+	    ("leaked requests: %d", sc->vtblk_request_count));
+}
+
+static struct vtblk_request *
+vtblk_dequeue_request(struct vtblk_softc *sc)
+{
+	struct vtblk_request *req;
+
+	req = TAILQ_FIRST(&sc->vtblk_req_free);
+	if (req != NULL)
+		TAILQ_REMOVE(&sc->vtblk_req_free, req, vbr_link);
+
+	return (req);
+}
+
+static void
+vtblk_enqueue_request(struct vtblk_softc *sc, struct vtblk_request *req)
+{
+
+	bzero(req, sizeof(struct vtblk_request));
+	TAILQ_INSERT_HEAD(&sc->vtblk_req_free, req, vbr_link);
+}
+
+static struct vtblk_request *
+vtblk_dequeue_ready(struct vtblk_softc *sc)
+{
+	struct vtblk_request *req;
+
+	req = TAILQ_FIRST(&sc->vtblk_req_ready);
+	if (req != NULL)
+		TAILQ_REMOVE(&sc->vtblk_req_ready, req, vbr_link);
+
+	return (req);
+}
+
+static void
+vtblk_enqueue_ready(struct vtblk_softc *sc, struct vtblk_request *req)
+{
+
+	TAILQ_INSERT_HEAD(&sc->vtblk_req_ready, req, vbr_link);
+}
+
+static int
+vtblk_request_error(struct vtblk_request *req)
+{
+	int error;
+
+	switch (req->vbr_ack) {
+	case VIRTIO_BLK_S_OK:
+		error = 0;
+		break;
+	case VIRTIO_BLK_S_UNSUPP:
+		error = ENOTSUP;
+		break;
+	default:
+		error = EIO;
+		break;
+	}
+
+	return (error);
+}
+
+static void
+vtblk_finish_bio(struct bio *bp, int error)
+{
+
+	if (error) {
+		bp->bio_resid = bp->bio_bcount;
+		bp->bio_error = error;
+		bp->bio_flags |= BIO_ERROR;
+	}
+
+	biodone(bp);
+}
diff --git a/sys/dev/virtio/block/virtio_blk.h b/sys/dev/virtio/block/virtio_blk.h
new file mode 100644
index 0000000..fdac9e5
--- /dev/null
+++ b/sys/dev/virtio/block/virtio_blk.h
@@ -0,0 +1,117 @@
+/*-
+ * This header is BSD licensed so anyone can use the definitions to implement
+ * compatible drivers/servers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of IBM nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ *  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL IBM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+
+#ifndef _VIRTIO_BLK_H
+#define _VIRTIO_BLK_H
+
+/* Feature bits */
+#define VIRTIO_BLK_F_BARRIER	0x0001	/* Does host support barriers? */
+#define VIRTIO_BLK_F_SIZE_MAX	0x0002	/* Indicates maximum segment size */
+#define VIRTIO_BLK_F_SEG_MAX	0x0004	/* Indicates maximum # of segments */
+#define VIRTIO_BLK_F_GEOMETRY	0x0010	/* Legacy geometry available  */
+#define VIRTIO_BLK_F_RO		0x0020	/* Disk is read-only */
+#define VIRTIO_BLK_F_BLK_SIZE	0x0040	/* Block size of disk is available*/
+#define VIRTIO_BLK_F_SCSI	0x0080	/* Supports scsi command passthru */
+#define VIRTIO_BLK_F_FLUSH	0x0200	/* Cache flush command support */
+#define VIRTIO_BLK_F_TOPOLOGY	0x0400	/* Topology information is available */
+
+#define VIRTIO_BLK_ID_BYTES	20	/* ID string length */
+
+struct virtio_blk_config {
+	/* The capacity (in 512-byte sectors). */
+	uint64_t capacity;
+	/* The maximum segment size (if VIRTIO_BLK_F_SIZE_MAX) */
+	uint32_t size_max;
+	/* The maximum number of segments (if VIRTIO_BLK_F_SEG_MAX) */
+	uint32_t seg_max;
+	/* geometry the device (if VIRTIO_BLK_F_GEOMETRY) */
+	struct virtio_blk_geometry {
+		uint16_t cylinders;
+		uint8_t heads;
+		uint8_t sectors;
+	} geometry;
+
+	/* block size of device (if VIRTIO_BLK_F_BLK_SIZE) */
+	uint32_t blk_size;
+} __packed;
+
+/*
+ * Command types
+ *
+ * Usage is a bit tricky as some bits are used as flags and some are not.
+ *
+ * Rules:
+ *   VIRTIO_BLK_T_OUT may be combined with VIRTIO_BLK_T_SCSI_CMD or
+ *   VIRTIO_BLK_T_BARRIER.  VIRTIO_BLK_T_FLUSH is a command of its own
+ *   and may not be combined with any of the other flags.
+ */
+
+/* These two define direction. */
+#define VIRTIO_BLK_T_IN		0
+#define VIRTIO_BLK_T_OUT	1
+
+/* This bit says it's a scsi command, not an actual read or write. */
+#define VIRTIO_BLK_T_SCSI_CMD	2
+
+/* Cache flush command */
+#define VIRTIO_BLK_T_FLUSH	4
+
+/* Get device ID command */
+#define VIRTIO_BLK_T_GET_ID	8
+
+/* Barrier before this op. */
+#define VIRTIO_BLK_T_BARRIER	0x80000000
+
+/* ID string length */
+#define VIRTIO_BLK_ID_BYTES	20
+
+/* This is the first element of the read scatter-gather list. */
+struct virtio_blk_outhdr {
+	/* VIRTIO_BLK_T* */
+	uint32_t type;
+	/* io priority. */
+	uint32_t ioprio;
+	/* Sector (ie. 512 byte offset) */
+	uint64_t sector;
+};
+
+struct virtio_scsi_inhdr {
+	uint32_t errors;
+	uint32_t data_len;
+	uint32_t sense_len;
+	uint32_t residual;
+};
+
+/* And this is the final byte of the write scatter-gather list. */
+#define VIRTIO_BLK_S_OK		0
+#define VIRTIO_BLK_S_IOERR	1
+#define VIRTIO_BLK_S_UNSUPP	2
+
+#endif /* _VIRTIO_BLK_H */
diff --git a/sys/dev/virtio/network/if_vtnet.c b/sys/dev/virtio/network/if_vtnet.c
new file mode 100644
index 0000000..d6fcac6d
--- /dev/null
+++ b/sys/dev/virtio/network/if_vtnet.c
@@ -0,0 +1,2746 @@
+/*-
+ * Copyright (c) 2011, Bryan Venteicher <bryanv@daemoninthecloset.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice unmodified, this list of conditions, and the following
+ *    disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* Driver for VirtIO network devices. */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#ifdef HAVE_KERNEL_OPTION_HEADERS
+#include "opt_device_polling.h"
+#endif
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/kernel.h>
+#include <sys/sockio.h>
+#include <sys/mbuf.h>
+#include <sys/malloc.h>
+#include <sys/module.h>
+#include <sys/socket.h>
+#include <sys/sysctl.h>
+#include <sys/taskqueue.h>
+#include <sys/random.h>
+#include <sys/sglist.h>
+#include <sys/lock.h>
+#include <sys/mutex.h>
+
+#include <vm/uma.h>
+
+#include <net/ethernet.h>
+#include <net/if.h>
+#include <net/if_arp.h>
+#include <net/if_dl.h>
+#include <net/if_types.h>
+#include <net/if_media.h>
+#include <net/if_vlan_var.h>
+
+#include <net/bpf.h>
+
+#include <netinet/in_systm.h>
+#include <netinet/in.h>
+#include <netinet/ip.h>
+#include <netinet/ip6.h>
+#include <netinet/udp.h>
+#include <netinet/tcp.h>
+#include <netinet/sctp.h>
+
+#include <machine/bus.h>
+#include <machine/resource.h>
+#include <sys/bus.h>
+#include <sys/rman.h>
+
+#include <dev/virtio/virtio.h>
+#include <dev/virtio/virtqueue.h>
+#include <dev/virtio/network/virtio_net.h>
+#include <dev/virtio/network/if_vtnetvar.h>
+
+#include "virtio_if.h"
+
+static int	vtnet_modevent(module_t, int, void *);
+
+static int	vtnet_probe(device_t);
+static int	vtnet_attach(device_t);
+static int	vtnet_detach(device_t);
+static int	vtnet_suspend(device_t);
+static int	vtnet_resume(device_t);
+static int	vtnet_shutdown(device_t);
+static int	vtnet_config_change(device_t);
+
+static void	vtnet_negotiate_features(struct vtnet_softc *);
+static int	vtnet_alloc_virtqueues(struct vtnet_softc *);
+static void	vtnet_get_hwaddr(struct vtnet_softc *);
+static void	vtnet_set_hwaddr(struct vtnet_softc *);
+static int	vtnet_is_link_up(struct vtnet_softc *);
+static void	vtnet_update_link_status(struct vtnet_softc *);
+static void	vtnet_watchdog(struct vtnet_softc *);
+static void	vtnet_config_change_task(void *, int);
+static int	vtnet_change_mtu(struct vtnet_softc *, int);
+static int	vtnet_ioctl(struct ifnet *, u_long, caddr_t);
+
+static int	vtnet_init_rx_vq(struct vtnet_softc *);
+static void	vtnet_free_rx_mbufs(struct vtnet_softc *);
+static void	vtnet_free_tx_mbufs(struct vtnet_softc *);
+static void	vtnet_free_ctrl_vq(struct vtnet_softc *);
+
+#ifdef DEVICE_POLLING
+static poll_handler_t vtnet_poll;
+#endif
+
+static struct mbuf * vtnet_alloc_rxbuf(struct vtnet_softc *, int,
+		    struct mbuf **);
+static int	vtnet_replace_rxbuf(struct vtnet_softc *,
+		    struct mbuf *, int);
+static int	vtnet_newbuf(struct vtnet_softc *);
+static void	vtnet_discard_merged_rxbuf(struct vtnet_softc *, int);
+static void	vtnet_discard_rxbuf(struct vtnet_softc *, struct mbuf *);
+static int	vtnet_enqueue_rxbuf(struct vtnet_softc *, struct mbuf *);
+static void	vtnet_vlan_tag_remove(struct mbuf *);
+static int	vtnet_rx_csum(struct vtnet_softc *, struct mbuf *,
+		    struct virtio_net_hdr *);
+static int	vtnet_rxeof_merged(struct vtnet_softc *, struct mbuf *, int);
+static int	vtnet_rxeof(struct vtnet_softc *, int, int *);
+static void	vtnet_rx_intr_task(void *, int);
+static int	vtnet_rx_vq_intr(void *);
+
+static void	vtnet_txeof(struct vtnet_softc *);
+static struct mbuf * vtnet_tx_offload(struct vtnet_softc *, struct mbuf *,
+		    struct virtio_net_hdr *);
+static int	vtnet_enqueue_txbuf(struct vtnet_softc *, struct mbuf **,
+		    struct vtnet_tx_header *);
+static int	vtnet_encap(struct vtnet_softc *, struct mbuf **);
+static void	vtnet_start_locked(struct ifnet *);
+static void	vtnet_start(struct ifnet *);
+static void	vtnet_tick(void *);
+static void	vtnet_tx_intr_task(void *, int);
+static int	vtnet_tx_vq_intr(void *);
+
+static void	vtnet_stop(struct vtnet_softc *);
+static int	vtnet_reinit(struct vtnet_softc *);
+static void	vtnet_init_locked(struct vtnet_softc *);
+static void	vtnet_init(void *);
+
+static void	vtnet_exec_ctrl_cmd(struct vtnet_softc *, void *,
+		    struct sglist *, int, int);
+
+static void	vtnet_rx_filter(struct vtnet_softc *sc);
+static int	vtnet_ctrl_rx_cmd(struct vtnet_softc *, int, int);
+static int	vtnet_set_promisc(struct vtnet_softc *, int);
+static int	vtnet_set_allmulti(struct vtnet_softc *, int);
+static void	vtnet_rx_filter_mac(struct vtnet_softc *);
+
+static int	vtnet_exec_vlan_filter(struct vtnet_softc *, int, uint16_t);
+static void	vtnet_rx_filter_vlan(struct vtnet_softc *);
+static void	vtnet_set_vlan_filter(struct vtnet_softc *, int, uint16_t);
+static void	vtnet_register_vlan(void *, struct ifnet *, uint16_t);
+static void	vtnet_unregister_vlan(void *, struct ifnet *, uint16_t);
+
+static int	vtnet_ifmedia_upd(struct ifnet *);
+static void	vtnet_ifmedia_sts(struct ifnet *, struct ifmediareq *);
+
+static void	vtnet_add_statistics(struct vtnet_softc *);
+
+static int	vtnet_enable_rx_intr(struct vtnet_softc *);
+static int	vtnet_enable_tx_intr(struct vtnet_softc *);
+static void	vtnet_disable_rx_intr(struct vtnet_softc *);
+static void	vtnet_disable_tx_intr(struct vtnet_softc *);
+
+/* Tunables. */
+static int vtnet_csum_disable = 0;
+TUNABLE_INT("hw.vtnet.csum_disable", &vtnet_csum_disable);
+static int vtnet_tso_disable = 0;
+TUNABLE_INT("hw.vtnet.tso_disable", &vtnet_tso_disable);
+static int vtnet_lro_disable = 0;
+TUNABLE_INT("hw.vtnet.lro_disable", &vtnet_lro_disable);
+
+/*
+ * Reducing the number of transmit completed interrupts can
+ * improve performance. To do so, the define below keeps the
+ * Tx vq interrupt disabled and adds calls to vtnet_txeof()
+ * in the start and watchdog paths. The price to pay for this
+ * is the m_free'ing of transmitted mbufs may be delayed until
+ * the watchdog fires.
+ */
+#define VTNET_TX_INTR_MODERATION
+
+static uma_zone_t vtnet_tx_header_zone;
+
+static struct virtio_feature_desc vtnet_feature_desc[] = {
+	{ VIRTIO_NET_F_CSUM,		"TxChecksum"	},
+	{ VIRTIO_NET_F_GUEST_CSUM,	"RxChecksum"	},
+	{ VIRTIO_NET_F_MAC,		"MacAddress"	},
+	{ VIRTIO_NET_F_GSO,		"TxAllGSO"	},
+	{ VIRTIO_NET_F_GUEST_TSO4,	"RxTSOv4"	},
+	{ VIRTIO_NET_F_GUEST_TSO6,	"RxTSOv6"	},
+	{ VIRTIO_NET_F_GUEST_ECN,	"RxECN"		},
+	{ VIRTIO_NET_F_GUEST_UFO,	"RxUFO"		},
+	{ VIRTIO_NET_F_HOST_TSO4,	"TxTSOv4"	},
+	{ VIRTIO_NET_F_HOST_TSO6,	"TxTSOv6"	},
+	{ VIRTIO_NET_F_HOST_ECN,	"TxTSOECN"	},
+	{ VIRTIO_NET_F_HOST_UFO,	"TxUFO"		},
+	{ VIRTIO_NET_F_MRG_RXBUF,	"MrgRxBuf"	},
+	{ VIRTIO_NET_F_STATUS,		"Status"	},
+	{ VIRTIO_NET_F_CTRL_VQ,		"ControlVq"	},
+	{ VIRTIO_NET_F_CTRL_RX,		"RxMode"	},
+	{ VIRTIO_NET_F_CTRL_VLAN,	"VLanFilter"	},
+	{ VIRTIO_NET_F_CTRL_RX_EXTRA,	"RxModeExtra"	},
+
+	{ 0, NULL }
+};
+
+static device_method_t vtnet_methods[] = {
+	/* Device methods. */
+	DEVMETHOD(device_probe,		vtnet_probe),
+	DEVMETHOD(device_attach,	vtnet_attach),
+	DEVMETHOD(device_detach,	vtnet_detach),
+	DEVMETHOD(device_suspend,	vtnet_suspend),
+	DEVMETHOD(device_resume,	vtnet_resume),
+	DEVMETHOD(device_shutdown,	vtnet_shutdown),
+
+	/* VirtIO methods. */
+	DEVMETHOD(virtio_config_change, vtnet_config_change),
+
+	DEVMETHOD_END
+};
+
+static driver_t vtnet_driver = {
+	"vtnet",
+	vtnet_methods,
+	sizeof(struct vtnet_softc)
+};
+static devclass_t vtnet_devclass;
+
+DRIVER_MODULE(vtnet, virtio_pci, vtnet_driver, vtnet_devclass,
+    vtnet_modevent, 0);
+MODULE_VERSION(vtnet, 1);
+MODULE_DEPEND(vtnet, virtio, 1, 1, 1);
+
+static int
+vtnet_modevent(module_t mod, int type, void *unused)
+{
+	int error;
+
+	error = 0;
+
+	switch (type) {
+	case MOD_LOAD:
+		vtnet_tx_header_zone = uma_zcreate("vtnet_tx_hdr",
+		    sizeof(struct vtnet_tx_header),
+		    NULL, NULL, NULL, NULL, 0, 0);
+		break;
+	case MOD_QUIESCE:
+	case MOD_UNLOAD:
+		if (uma_zone_get_cur(vtnet_tx_header_zone) > 0)
+			error = EBUSY;
+		else if (type == MOD_UNLOAD) {
+			uma_zdestroy(vtnet_tx_header_zone);
+			vtnet_tx_header_zone = NULL;
+		}
+		break;
+	case MOD_SHUTDOWN:
+		break;
+	default:
+		error = EOPNOTSUPP;
+		break;
+	}
+
+	return (error);
+}
+
+static int
+vtnet_probe(device_t dev)
+{
+
+	if (virtio_get_device_type(dev) != VIRTIO_ID_NETWORK)
+		return (ENXIO);
+
+	device_set_desc(dev, "VirtIO Networking Adapter");
+
+	return (BUS_PROBE_DEFAULT);
+}
+
+static int
+vtnet_attach(device_t dev)
+{
+	struct vtnet_softc *sc;
+	struct ifnet *ifp;
+	int tx_size, error;
+
+	sc = device_get_softc(dev);
+	sc->vtnet_dev = dev;
+
+	VTNET_LOCK_INIT(sc);
+	callout_init_mtx(&sc->vtnet_tick_ch, VTNET_MTX(sc), 0);
+
+	ifmedia_init(&sc->vtnet_media, IFM_IMASK, vtnet_ifmedia_upd,
+	    vtnet_ifmedia_sts);
+	ifmedia_add(&sc->vtnet_media, VTNET_MEDIATYPE, 0, NULL);
+	ifmedia_set(&sc->vtnet_media, VTNET_MEDIATYPE);
+
+	vtnet_add_statistics(sc);
+
+	virtio_set_feature_desc(dev, vtnet_feature_desc);
+	vtnet_negotiate_features(sc);
+
+	if (virtio_with_feature(dev, VIRTIO_NET_F_MRG_RXBUF)) {
+		sc->vtnet_flags |= VTNET_FLAG_MRG_RXBUFS;
+		sc->vtnet_hdr_size = sizeof(struct virtio_net_hdr_mrg_rxbuf);
+	} else
+		sc->vtnet_hdr_size = sizeof(struct virtio_net_hdr);
+
+	sc->vtnet_rx_mbuf_size = MCLBYTES;
+	sc->vtnet_rx_mbuf_count = VTNET_NEEDED_RX_MBUFS(sc);
+
+	if (virtio_with_feature(dev, VIRTIO_NET_F_CTRL_VQ)) {
+		sc->vtnet_flags |= VTNET_FLAG_CTRL_VQ;
+
+		if (virtio_with_feature(dev, VIRTIO_NET_F_CTRL_RX)) {
+			sc->vtnet_mac_filter = malloc(
+			    sizeof(struct vtnet_mac_filter), M_DEVBUF,
+			    M_NOWAIT | M_ZERO);
+			if (sc->vtnet_mac_filter == NULL) {
+				device_printf(dev,
+				    "cannot allocate mac filter table\n");
+				error = ENOMEM;
+				goto fail;
+			}
+
+			sc->vtnet_flags |= VTNET_FLAG_CTRL_RX;
+		}
+
+		if (virtio_with_feature(dev, VIRTIO_NET_F_CTRL_VLAN))
+			sc->vtnet_flags |= VTNET_FLAG_VLAN_FILTER;
+	}
+
+	vtnet_get_hwaddr(sc);
+
+	error = vtnet_alloc_virtqueues(sc);
+	if (error) {
+		device_printf(dev, "cannot allocate virtqueues\n");
+		goto fail;
+	}
+
+	ifp = sc->vtnet_ifp = if_alloc(IFT_ETHER);
+	if (ifp == NULL) {
+		device_printf(dev, "cannot allocate ifnet structure\n");
+		error = ENOSPC;
+		goto fail;
+	}
+
+	ifp->if_softc = sc;
+	if_initname(ifp, device_get_name(dev), device_get_unit(dev));
+	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
+	ifp->if_init = vtnet_init;
+	ifp->if_start = vtnet_start;
+	ifp->if_ioctl = vtnet_ioctl;
+
+	sc->vtnet_rx_size = virtqueue_size(sc->vtnet_rx_vq);
+	sc->vtnet_rx_process_limit = sc->vtnet_rx_size;
+
+	tx_size = virtqueue_size(sc->vtnet_tx_vq);
+	sc->vtnet_tx_size = tx_size;
+	IFQ_SET_MAXLEN(&ifp->if_snd, tx_size - 1);
+	ifp->if_snd.ifq_drv_maxlen = tx_size - 1;
+	IFQ_SET_READY(&ifp->if_snd);
+
+	ether_ifattach(ifp, sc->vtnet_hwaddr);
+
+	if (virtio_with_feature(dev, VIRTIO_NET_F_STATUS))
+		ifp->if_capabilities |= IFCAP_LINKSTATE;
+
+	/* Tell the upper layer(s) we support long frames. */
+	ifp->if_data.ifi_hdrlen = sizeof(struct ether_vlan_header);
+	ifp->if_capabilities |= IFCAP_JUMBO_MTU | IFCAP_VLAN_MTU;
+
+	if (virtio_with_feature(dev, VIRTIO_NET_F_CSUM)) {
+		ifp->if_capabilities |= IFCAP_TXCSUM;
+
+		if (virtio_with_feature(dev, VIRTIO_NET_F_HOST_TSO4))
+			ifp->if_capabilities |= IFCAP_TSO4;
+		if (virtio_with_feature(dev, VIRTIO_NET_F_HOST_TSO6))
+			ifp->if_capabilities |= IFCAP_TSO6;
+		if (ifp->if_capabilities & IFCAP_TSO)
+			ifp->if_capabilities |= IFCAP_VLAN_HWTSO;
+
+		if (virtio_with_feature(dev, VIRTIO_NET_F_HOST_ECN))
+			sc->vtnet_flags |= VTNET_FLAG_TSO_ECN;
+	}
+
+	if (virtio_with_feature(dev, VIRTIO_NET_F_GUEST_CSUM)) {
+		ifp->if_capabilities |= IFCAP_RXCSUM;
+
+		if (virtio_with_feature(dev, VIRTIO_NET_F_GUEST_TSO4) ||
+		    virtio_with_feature(dev, VIRTIO_NET_F_GUEST_TSO6))
+			ifp->if_capabilities |= IFCAP_LRO;
+	}
+
+	if (ifp->if_capabilities & IFCAP_HWCSUM) {
+		/*
+		 * VirtIO does not support VLAN tagging, but we can fake
+		 * it by inserting and removing the 802.1Q header during
+		 * transmit and receive. We are then able to do checksum
+		 * offloading of VLAN frames.
+		 */
+		ifp->if_capabilities |=
+		    IFCAP_VLAN_HWTAGGING | IFCAP_VLAN_HWCSUM;
+	}
+
+	ifp->if_capenable = ifp->if_capabilities;
+
+	/*
+	 * Capabilities after here are not enabled by default.
+	 */
+
+	if (sc->vtnet_flags & VTNET_FLAG_VLAN_FILTER) {
+		ifp->if_capabilities |= IFCAP_VLAN_HWFILTER;
+
+		sc->vtnet_vlan_attach = EVENTHANDLER_REGISTER(vlan_config,
+		    vtnet_register_vlan, sc, EVENTHANDLER_PRI_FIRST);
+		sc->vtnet_vlan_detach = EVENTHANDLER_REGISTER(vlan_unconfig,
+		    vtnet_unregister_vlan, sc, EVENTHANDLER_PRI_FIRST);
+	}
+
+#ifdef DEVICE_POLLING
+	ifp->if_capabilities |= IFCAP_POLLING;
+#endif
+
+	TASK_INIT(&sc->vtnet_rx_intr_task, 0, vtnet_rx_intr_task, sc);
+	TASK_INIT(&sc->vtnet_tx_intr_task, 0, vtnet_tx_intr_task, sc);
+	TASK_INIT(&sc->vtnet_cfgchg_task, 0, vtnet_config_change_task, sc);
+
+	sc->vtnet_tq = taskqueue_create_fast("vtnet_taskq", M_NOWAIT,
+	    taskqueue_thread_enqueue, &sc->vtnet_tq);
+	if (sc->vtnet_tq == NULL) {
+		error = ENOMEM;
+		device_printf(dev, "cannot allocate taskqueue\n");
+		ether_ifdetach(ifp);
+		goto fail;
+	}
+
+	error = virtio_setup_intr(dev, INTR_TYPE_NET);
+	if (error) {
+		device_printf(dev, "cannot setup virtqueue interrupts\n");
+		ether_ifdetach(ifp);
+		goto fail;
+	}
+
+	taskqueue_start_threads(&sc->vtnet_tq, 1, PI_NET, "%s taskq",
+	    device_get_nameunit(dev));
+
+	/*
+	 * Device defaults to promiscuous mode for backwards
+	 * compatibility. Turn it off if possible.
+	 */
+	if (sc->vtnet_flags & VTNET_FLAG_CTRL_RX) {
+		VTNET_LOCK(sc);
+		if (vtnet_set_promisc(sc, 0) != 0) {
+			ifp->if_flags |= IFF_PROMISC;
+			device_printf(dev,
+			    "cannot disable promiscuous mode\n");
+		}
+		VTNET_UNLOCK(sc);
+	} else
+		ifp->if_flags |= IFF_PROMISC;
+
+fail:
+	if (error)
+		vtnet_detach(dev);
+
+	return (error);
+}
+
+static int
+vtnet_detach(device_t dev)
+{
+	struct vtnet_softc *sc;
+	struct ifnet *ifp;
+
+	sc = device_get_softc(dev);
+	ifp = sc->vtnet_ifp;
+
+	KASSERT(mtx_initialized(VTNET_MTX(sc)),
+	    ("vtnet mutex not initialized"));
+
+#ifdef DEVICE_POLLING
+	if (ifp != NULL && ifp->if_capenable & IFCAP_POLLING)
+		ether_poll_deregister(ifp);
+#endif
+
+	if (device_is_attached(dev)) {
+		VTNET_LOCK(sc);
+		vtnet_stop(sc);
+		VTNET_UNLOCK(sc);
+
+		callout_drain(&sc->vtnet_tick_ch);
+		taskqueue_drain(taskqueue_fast, &sc->vtnet_cfgchg_task);
+
+		ether_ifdetach(ifp);
+	}
+
+	if (sc->vtnet_tq != NULL) {
+		taskqueue_drain(sc->vtnet_tq, &sc->vtnet_rx_intr_task);
+		taskqueue_drain(sc->vtnet_tq, &sc->vtnet_tx_intr_task);
+		taskqueue_free(sc->vtnet_tq);
+		sc->vtnet_tq = NULL;
+	}
+
+	if (sc->vtnet_vlan_attach != NULL) {
+		EVENTHANDLER_DEREGISTER(vlan_config, sc->vtnet_vlan_attach);
+		sc->vtnet_vlan_attach = NULL;
+	}
+	if (sc->vtnet_vlan_detach != NULL) {
+		EVENTHANDLER_DEREGISTER(vlan_unconfg, sc->vtnet_vlan_detach);
+		sc->vtnet_vlan_detach = NULL;
+	}
+
+	if (sc->vtnet_mac_filter != NULL) {
+		free(sc->vtnet_mac_filter, M_DEVBUF);
+		sc->vtnet_mac_filter = NULL;
+	}
+
+	if (ifp != NULL) {
+		if_free(ifp);
+		sc->vtnet_ifp = NULL;
+	}
+
+	if (sc->vtnet_rx_vq != NULL)
+		vtnet_free_rx_mbufs(sc);
+	if (sc->vtnet_tx_vq != NULL)
+		vtnet_free_tx_mbufs(sc);
+	if (sc->vtnet_ctrl_vq != NULL)
+		vtnet_free_ctrl_vq(sc);
+
+	ifmedia_removeall(&sc->vtnet_media);
+	VTNET_LOCK_DESTROY(sc);
+
+	return (0);
+}
+
+static int
+vtnet_suspend(device_t dev)
+{
+	struct vtnet_softc *sc;
+
+	sc = device_get_softc(dev);
+
+	VTNET_LOCK(sc);
+	vtnet_stop(sc);
+	sc->vtnet_flags |= VTNET_FLAG_SUSPENDED;
+	VTNET_UNLOCK(sc);
+
+	return (0);
+}
+
+static int
+vtnet_resume(device_t dev)
+{
+	struct vtnet_softc *sc;
+	struct ifnet *ifp;
+
+	sc = device_get_softc(dev);
+	ifp = sc->vtnet_ifp;
+
+	VTNET_LOCK(sc);
+	if (ifp->if_flags & IFF_UP)
+		vtnet_init_locked(sc);
+	sc->vtnet_flags &= ~VTNET_FLAG_SUSPENDED;
+	VTNET_UNLOCK(sc);
+
+	return (0);
+}
+
+static int
+vtnet_shutdown(device_t dev)
+{
+
+	/*
+	 * Suspend already does all of what we need to
+	 * do here; we just never expect to be resumed.
+	 */
+	return (vtnet_suspend(dev));
+}
+
+static int
+vtnet_config_change(device_t dev)
+{
+	struct vtnet_softc *sc;
+
+	sc = device_get_softc(dev);
+
+	taskqueue_enqueue_fast(taskqueue_fast, &sc->vtnet_cfgchg_task);
+
+	return (1);
+}
+
+static void
+vtnet_negotiate_features(struct vtnet_softc *sc)
+{
+	device_t dev;
+	uint64_t mask, features;
+
+	dev = sc->vtnet_dev;
+	mask = 0;
+
+	if (vtnet_csum_disable)
+		mask |= VIRTIO_NET_F_CSUM | VIRTIO_NET_F_GUEST_CSUM;
+
+	/*
+	 * TSO and LRO are only available when their corresponding
+	 * checksum offload feature is also negotiated.
+	 */
+
+	if (vtnet_csum_disable || vtnet_tso_disable)
+		mask |= VIRTIO_NET_F_HOST_TSO4 | VIRTIO_NET_F_HOST_TSO6 |
+		    VIRTIO_NET_F_HOST_ECN;
+
+	if (vtnet_csum_disable || vtnet_lro_disable)
+		mask |= VTNET_LRO_FEATURES;
+
+	features = VTNET_FEATURES & ~mask;
+#ifdef VTNET_TX_INTR_MODERATION
+	features |= VIRTIO_F_NOTIFY_ON_EMPTY;
+#endif
+	sc->vtnet_features = virtio_negotiate_features(dev, features);
+
+	if (virtio_with_feature(dev, VIRTIO_NET_F_MRG_RXBUF) == 0 &&
+	    virtio_with_feature(dev, VTNET_LRO_FEATURES)) {
+		/*
+		 * LRO without mergeable buffers requires special care. This
+		 * is not ideal because every receive buffer must be large
+		 * enough to hold the maximum TCP packet, the Ethernet header,
+		 * and the vtnet_rx_header. This requires up to 34 descriptors
+		 * when using MCLBYTES clusters. If we do not have indirect
+		 * descriptors, LRO is disabled since the virtqueue will not
+		 * be able to contain very many receive buffers.
+		 */
+		if (virtio_with_feature(dev,
+		    VIRTIO_RING_F_INDIRECT_DESC) == 0) {
+			device_printf(dev,
+			    "LRO disabled due to lack of both mergeable "
+			    "buffers and indirect descriptors\n");
+
+			sc->vtnet_features = virtio_negotiate_features(dev,
+			    features & ~VTNET_LRO_FEATURES);
+		} else
+			sc->vtnet_flags |= VTNET_FLAG_LRO_NOMRG;
+	}
+}
+
+static int
+vtnet_alloc_virtqueues(struct vtnet_softc *sc)
+{
+	device_t dev;
+	struct vq_alloc_info vq_info[3];
+	int nvqs, rxsegs;
+
+	dev = sc->vtnet_dev;
+	nvqs = 2;
+
+	/*
+	 * Indirect descriptors are not needed for the Rx
+	 * virtqueue when mergeable buffers are negotiated.
+	 * The header is placed inline with the data, not
+	 * in a separate descriptor, and mbuf clusters are
+	 * always physically contiguous.
+	 */
+	if ((sc->vtnet_flags & VTNET_FLAG_MRG_RXBUFS) == 0) {
+		rxsegs = sc->vtnet_flags & VTNET_FLAG_LRO_NOMRG ?
+		    VTNET_MAX_RX_SEGS : VTNET_MIN_RX_SEGS;
+	} else
+		rxsegs = 0;
+
+	VQ_ALLOC_INFO_INIT(&vq_info[0], rxsegs,
+	    vtnet_rx_vq_intr, sc, &sc->vtnet_rx_vq,
+	    "%s receive", device_get_nameunit(dev));
+
+	VQ_ALLOC_INFO_INIT(&vq_info[1], VTNET_MAX_TX_SEGS,
+	    vtnet_tx_vq_intr, sc, &sc->vtnet_tx_vq,
+	    "%s transmit", device_get_nameunit(dev));
+
+	if (sc->vtnet_flags & VTNET_FLAG_CTRL_VQ) {
+		nvqs++;
+
+		VQ_ALLOC_INFO_INIT(&vq_info[2], 0, NULL, NULL,
+		    &sc->vtnet_ctrl_vq, "%s control",
+		    device_get_nameunit(dev));
+	}
+
+	return (virtio_alloc_virtqueues(dev, 0, nvqs, vq_info));
+}
+
+static void
+vtnet_get_hwaddr(struct vtnet_softc *sc)
+{
+	device_t dev;
+
+	dev = sc->vtnet_dev;
+
+	if (virtio_with_feature(dev, VIRTIO_NET_F_MAC)) {
+		virtio_read_device_config(dev,
+		    offsetof(struct virtio_net_config, mac),
+		    sc->vtnet_hwaddr, ETHER_ADDR_LEN);
+	} else {
+		/* Generate random locally administered unicast address. */
+		sc->vtnet_hwaddr[0] = 0xB2;
+		arc4rand(&sc->vtnet_hwaddr[1], ETHER_ADDR_LEN - 1, 0);
+
+		vtnet_set_hwaddr(sc);
+	}
+}
+
+static void
+vtnet_set_hwaddr(struct vtnet_softc *sc)
+{
+	device_t dev;
+
+	dev = sc->vtnet_dev;
+
+	virtio_write_device_config(dev,
+	    offsetof(struct virtio_net_config, mac),
+	    sc->vtnet_hwaddr, ETHER_ADDR_LEN);
+}
+
+static int
+vtnet_is_link_up(struct vtnet_softc *sc)
+{
+	device_t dev;
+	struct ifnet *ifp;
+	uint16_t status;
+
+	dev = sc->vtnet_dev;
+	ifp = sc->vtnet_ifp;
+
+	VTNET_LOCK_ASSERT(sc);
+
+	if ((ifp->if_capenable & IFCAP_LINKSTATE) == 0)
+		return (1);
+
+	status = virtio_read_dev_config_2(dev,
+	    offsetof(struct virtio_net_config, status));
+
+	return ((status & VIRTIO_NET_S_LINK_UP) != 0);
+}
+
+static void
+vtnet_update_link_status(struct vtnet_softc *sc)
+{
+	struct ifnet *ifp;
+	int link;
+
+	ifp = sc->vtnet_ifp;
+
+	link = vtnet_is_link_up(sc);
+
+	if (link && ((sc->vtnet_flags & VTNET_FLAG_LINK) == 0)) {
+		sc->vtnet_flags |= VTNET_FLAG_LINK;
+		if_link_state_change(ifp, LINK_STATE_UP);
+		if (!IFQ_DRV_IS_EMPTY(&ifp->if_snd))
+			vtnet_start_locked(ifp);
+	} else if (!link && (sc->vtnet_flags & VTNET_FLAG_LINK)) {
+		sc->vtnet_flags &= ~VTNET_FLAG_LINK;
+		if_link_state_change(ifp, LINK_STATE_DOWN);
+	}
+}
+
+static void
+vtnet_watchdog(struct vtnet_softc *sc)
+{
+	struct ifnet *ifp;
+
+	ifp = sc->vtnet_ifp;
+
+#ifdef VTNET_TX_INTR_MODERATION
+	vtnet_txeof(sc);
+#endif
+
+	if (sc->vtnet_watchdog_timer == 0 || --sc->vtnet_watchdog_timer)
+		return;
+
+	if_printf(ifp, "watchdog timeout -- resetting\n");
+#ifdef VTNET_DEBUG
+	virtqueue_dump(sc->vtnet_tx_vq);
+#endif
+	ifp->if_oerrors++;
+	ifp->if_drv_flags &= ~IFF_DRV_RUNNING;
+	vtnet_init_locked(sc);
+}
+
+static void
+vtnet_config_change_task(void *arg, int pending)
+{
+	struct vtnet_softc *sc;
+
+	sc = arg;
+
+	VTNET_LOCK(sc);
+	vtnet_update_link_status(sc);
+	VTNET_UNLOCK(sc);
+}
+
+static int
+vtnet_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
+{
+	struct vtnet_softc *sc;
+	struct ifreq *ifr;
+	int reinit, mask, error;
+
+	sc = ifp->if_softc;
+	ifr = (struct ifreq *) data;
+	reinit = 0;
+	error = 0;
+
+	switch (cmd) {
+	case SIOCSIFMTU:
+		if (ifr->ifr_mtu < ETHERMIN || ifr->ifr_mtu > VTNET_MAX_MTU)
+			error = EINVAL;
+		else if (ifp->if_mtu != ifr->ifr_mtu) {
+			VTNET_LOCK(sc);
+			error = vtnet_change_mtu(sc, ifr->ifr_mtu);
+			VTNET_UNLOCK(sc);
+		}
+		break;
+
+	case SIOCSIFFLAGS:
+		VTNET_LOCK(sc);
+		if ((ifp->if_flags & IFF_UP) == 0) {
+			if (ifp->if_drv_flags & IFF_DRV_RUNNING)
+				vtnet_stop(sc);
+		} else if (ifp->if_drv_flags & IFF_DRV_RUNNING) {
+			if ((ifp->if_flags ^ sc->vtnet_if_flags) &
+			    (IFF_PROMISC | IFF_ALLMULTI)) {
+				if (sc->vtnet_flags & VTNET_FLAG_CTRL_RX)
+					vtnet_rx_filter(sc);
+				else
+					error = ENOTSUP;
+			}
+		} else
+			vtnet_init_locked(sc);
+
+		if (error == 0)
+			sc->vtnet_if_flags = ifp->if_flags;
+		VTNET_UNLOCK(sc);
+		break;
+
+	case SIOCADDMULTI:
+	case SIOCDELMULTI:
+		VTNET_LOCK(sc);
+		if ((sc->vtnet_flags & VTNET_FLAG_CTRL_RX) &&
+		    (ifp->if_drv_flags & IFF_DRV_RUNNING))
+			vtnet_rx_filter_mac(sc);
+		VTNET_UNLOCK(sc);
+		break;
+
+	case SIOCSIFMEDIA:
+	case SIOCGIFMEDIA:
+		error = ifmedia_ioctl(ifp, ifr, &sc->vtnet_media, cmd);
+		break;
+
+	case SIOCSIFCAP:
+		mask = ifr->ifr_reqcap ^ ifp->if_capenable;
+
+#ifdef DEVICE_POLLING
+		if (mask & IFCAP_POLLING) {
+			if (ifr->ifr_reqcap & IFCAP_POLLING) {
+				error = ether_poll_register(vtnet_poll, ifp);
+				if (error)
+					break;
+
+				VTNET_LOCK(sc);
+				vtnet_disable_rx_intr(sc);
+				vtnet_disable_tx_intr(sc);
+				ifp->if_capenable |= IFCAP_POLLING;
+				VTNET_UNLOCK(sc);
+			} else {
+				error = ether_poll_deregister(ifp);
+
+				/* Enable interrupts even in error case. */
+				VTNET_LOCK(sc);
+				vtnet_enable_tx_intr(sc);
+				vtnet_enable_rx_intr(sc);
+				ifp->if_capenable &= ~IFCAP_POLLING;
+				VTNET_UNLOCK(sc);
+			}
+		}
+#endif
+		VTNET_LOCK(sc);
+
+		if (mask & IFCAP_TXCSUM) {
+			ifp->if_capenable ^= IFCAP_TXCSUM;
+			if (ifp->if_capenable & IFCAP_TXCSUM)
+				ifp->if_hwassist |= VTNET_CSUM_OFFLOAD;
+			else
+				ifp->if_hwassist &= ~VTNET_CSUM_OFFLOAD;
+		}
+
+		if (mask & IFCAP_TSO4) {
+			ifp->if_capenable ^= IFCAP_TSO4;
+			if (ifp->if_capenable & IFCAP_TSO4)
+				ifp->if_hwassist |= CSUM_TSO;
+			else
+				ifp->if_hwassist &= ~CSUM_TSO;
+		}
+
+		if (mask & IFCAP_RXCSUM) {
+			ifp->if_capenable ^= IFCAP_RXCSUM;
+			reinit = 1;
+		}
+
+		if (mask & IFCAP_LRO) {
+			ifp->if_capenable ^= IFCAP_LRO;
+			reinit = 1;
+		}
+
+		if (mask & IFCAP_VLAN_HWFILTER) {
+			ifp->if_capenable ^= IFCAP_VLAN_HWFILTER;
+			reinit = 1;
+		}
+
+		if (mask & IFCAP_VLAN_HWTSO)
+			ifp->if_capenable ^= IFCAP_VLAN_HWTSO;
+
+		if (mask & IFCAP_VLAN_HWTAGGING)
+			ifp->if_capenable ^= IFCAP_VLAN_HWTAGGING;
+
+		if (reinit && (ifp->if_drv_flags & IFF_DRV_RUNNING)) {
+			ifp->if_drv_flags &= ~IFF_DRV_RUNNING;
+			vtnet_init_locked(sc);
+		}
+		VLAN_CAPABILITIES(ifp);
+
+		VTNET_UNLOCK(sc);
+		break;
+
+	default:
+		error = ether_ioctl(ifp, cmd, data);
+		break;
+	}
+
+	VTNET_LOCK_ASSERT_NOTOWNED(sc);
+
+	return (error);
+}
+
+static int
+vtnet_change_mtu(struct vtnet_softc *sc, int new_mtu)
+{
+	struct ifnet *ifp;
+	int new_frame_size, clsize;
+
+	ifp = sc->vtnet_ifp;
+
+	if ((sc->vtnet_flags & VTNET_FLAG_MRG_RXBUFS) == 0) {
+		new_frame_size = sizeof(struct vtnet_rx_header) +
+		    sizeof(struct ether_vlan_header) + new_mtu;
+
+		if (new_frame_size > MJUM9BYTES)
+			return (EINVAL);
+
+		if (new_frame_size <= MCLBYTES)
+			clsize = MCLBYTES;
+		else
+			clsize = MJUM9BYTES;
+	} else {
+		new_frame_size = sizeof(struct virtio_net_hdr_mrg_rxbuf) +
+		    sizeof(struct ether_vlan_header) + new_mtu;
+
+		if (new_frame_size <= MCLBYTES)
+			clsize = MCLBYTES;
+		else
+			clsize = MJUMPAGESIZE;
+	}
+
+	sc->vtnet_rx_mbuf_size = clsize;
+	sc->vtnet_rx_mbuf_count = VTNET_NEEDED_RX_MBUFS(sc);
+	KASSERT(sc->vtnet_rx_mbuf_count < VTNET_MAX_RX_SEGS,
+	    ("too many rx mbufs: %d", sc->vtnet_rx_mbuf_count));
+
+	ifp->if_mtu = new_mtu;
+
+	if (ifp->if_drv_flags & IFF_DRV_RUNNING) {
+		ifp->if_drv_flags &= ~IFF_DRV_RUNNING;
+		vtnet_init_locked(sc);
+	}
+
+	return (0);
+}
+
+static int
+vtnet_init_rx_vq(struct vtnet_softc *sc)
+{
+	struct virtqueue *vq;
+	int nbufs, error;
+
+	vq = sc->vtnet_rx_vq;
+	nbufs = 0;
+	error = ENOSPC;
+
+	while (!virtqueue_full(vq)) {
+		if ((error = vtnet_newbuf(sc)) != 0)
+			break;
+		nbufs++;
+	}
+
+	if (nbufs > 0) {
+		virtqueue_notify(vq);
+
+		/*
+		 * EMSGSIZE signifies the virtqueue did not have enough
+		 * entries available to hold the last mbuf. This is not
+		 * an error. We should not get ENOSPC since we check if
+		 * the virtqueue is full before attempting to add a
+		 * buffer.
+		 */
+		if (error == EMSGSIZE)
+			error = 0;
+	}
+
+	return (error);
+}
+
+static void
+vtnet_free_rx_mbufs(struct vtnet_softc *sc)
+{
+	struct virtqueue *vq;
+	struct mbuf *m;
+	int last;
+
+	vq = sc->vtnet_rx_vq;
+	last = 0;
+
+	while ((m = virtqueue_drain(vq, &last)) != NULL)
+		m_freem(m);
+
+	KASSERT(virtqueue_empty(vq), ("mbufs remaining in Rx Vq"));
+}
+
+static void
+vtnet_free_tx_mbufs(struct vtnet_softc *sc)
+{
+	struct virtqueue *vq;
+	struct vtnet_tx_header *txhdr;
+	int last;
+
+	vq = sc->vtnet_tx_vq;
+	last = 0;
+
+	while ((txhdr = virtqueue_drain(vq, &last)) != NULL) {
+		m_freem(txhdr->vth_mbuf);
+		uma_zfree(vtnet_tx_header_zone, txhdr);
+	}
+
+	KASSERT(virtqueue_empty(vq), ("mbufs remaining in Tx Vq"));
+}
+
+static void
+vtnet_free_ctrl_vq(struct vtnet_softc *sc)
+{
+
+	/*
+	 * The control virtqueue is only polled, therefore
+	 * it should already be empty.
+	 */
+	KASSERT(virtqueue_empty(sc->vtnet_ctrl_vq),
+	    ("Ctrl Vq not empty"));
+}
+
+#ifdef DEVICE_POLLING
+static int
+vtnet_poll(struct ifnet *ifp, enum poll_cmd cmd, int count)
+{
+	struct vtnet_softc *sc;
+	int rx_done;
+
+	sc = ifp->if_softc;
+	rx_done = 0;
+
+	VTNET_LOCK(sc);
+	if (ifp->if_drv_flags & IFF_DRV_RUNNING) {
+		if (cmd == POLL_AND_CHECK_STATUS)
+			vtnet_update_link_status(sc);
+
+		if (virtqueue_nused(sc->vtnet_rx_vq) > 0)
+			vtnet_rxeof(sc, count, &rx_done);
+
+		vtnet_txeof(sc);
+		if (!IFQ_DRV_IS_EMPTY(&ifp->if_snd))
+			vtnet_start_locked(ifp);
+	}
+	VTNET_UNLOCK(sc);
+
+	return (rx_done);
+}
+#endif /* DEVICE_POLLING */
+
+static struct mbuf *
+vtnet_alloc_rxbuf(struct vtnet_softc *sc, int nbufs, struct mbuf **m_tailp)
+{
+	struct mbuf *m_head, *m_tail, *m;
+	int i, clsize;
+
+	clsize = sc->vtnet_rx_mbuf_size;
+
+	m_head = m_getjcl(M_DONTWAIT, MT_DATA, M_PKTHDR, clsize);
+	if (m_head == NULL)
+		goto fail;
+
+	m_head->m_len = clsize;
+	m_tail = m_head;
+
+	if (nbufs > 1) {
+		KASSERT(sc->vtnet_flags & VTNET_FLAG_LRO_NOMRG,
+		    ("chained Rx mbuf requested without LRO_NOMRG"));
+
+		for (i = 1; i < nbufs; i++) {
+			m = m_getjcl(M_DONTWAIT, MT_DATA, 0, clsize);
+			if (m == NULL)
+				goto fail;
+
+			m->m_len = clsize;
+			m_tail->m_next = m;
+			m_tail = m;
+		}
+	}
+
+	if (m_tailp != NULL)
+		*m_tailp = m_tail;
+
+	return (m_head);
+
+fail:
+	sc->vtnet_stats.mbuf_alloc_failed++;
+	m_freem(m_head);
+
+	return (NULL);
+}
+
+static int
+vtnet_replace_rxbuf(struct vtnet_softc *sc, struct mbuf *m0, int len0)
+{
+	struct mbuf *m, *m_prev;
+	struct mbuf *m_new, *m_tail;
+	int len, clsize, nreplace, error;
+
+	m = m0;
+	m_prev = NULL;
+	len = len0;
+
+	m_tail = NULL;
+	clsize = sc->vtnet_rx_mbuf_size;
+	nreplace = 0;
+
+	KASSERT(sc->vtnet_flags & VTNET_FLAG_LRO_NOMRG ||
+	    m->m_next == NULL, ("chained Rx mbuf without LRO_NOMRG"));
+
+	/*
+	 * Since LRO_NOMRG mbuf chains are so large, we want to avoid
+	 * allocating an entire chain for each received frame. When
+	 * the received frame's length is less than that of the chain,
+	 * the unused mbufs are reassigned to the new chain.
+	 */
+	while (len > 0) {
+		/*
+		 * Something is seriously wrong if we received
+		 * a frame larger than the mbuf chain. Drop it.
+		 */
+		if (m == NULL) {
+			sc->vtnet_stats.rx_frame_too_large++;
+			return (EMSGSIZE);
+		}
+
+		KASSERT(m->m_len == clsize,
+		    ("mbuf length not expected cluster size: %d",
+		    m->m_len));
+
+		m->m_len = MIN(m->m_len, len);
+		len -= m->m_len;
+
+		m_prev = m;
+		m = m->m_next;
+		nreplace++;
+	}
+
+	KASSERT(m_prev != NULL, ("m_prev == NULL"));
+	KASSERT(nreplace <= sc->vtnet_rx_mbuf_count,
+	    ("too many replacement mbufs: %d/%d", nreplace,
+	    sc->vtnet_rx_mbuf_count));
+
+	m_new = vtnet_alloc_rxbuf(sc, nreplace, &m_tail);
+	if (m_new == NULL) {
+		m_prev->m_len = clsize;
+		return (ENOBUFS);
+	}
+
+	/*
+	 * Move unused mbufs, if any, from the original chain
+	 * onto the end of the new chain.
+	 */
+	if (m_prev->m_next != NULL) {
+		m_tail->m_next = m_prev->m_next;
+		m_prev->m_next = NULL;
+	}
+
+	error = vtnet_enqueue_rxbuf(sc, m_new);
+	if (error) {
+		/*
+		 * BAD! We could not enqueue the replacement mbuf chain. We
+		 * must restore the m0 chain to the original state if it was
+		 * modified so we can subsequently discard it.
+		 *
+		 * NOTE: The replacement is suppose to be an identical copy
+		 * to the one just dequeued so this is an unexpected error.
+		 */
+		sc->vtnet_stats.rx_enq_replacement_failed++;
+
+		if (m_tail->m_next != NULL) {
+			m_prev->m_next = m_tail->m_next;
+			m_tail->m_next = NULL;
+		}
+
+		m_prev->m_len = clsize;
+		m_freem(m_new);
+	}
+
+	return (error);
+}
+
+static int
+vtnet_newbuf(struct vtnet_softc *sc)
+{
+	struct mbuf *m;
+	int error;
+
+	m = vtnet_alloc_rxbuf(sc, sc->vtnet_rx_mbuf_count, NULL);
+	if (m == NULL)
+		return (ENOBUFS);
+
+	error = vtnet_enqueue_rxbuf(sc, m);
+	if (error)
+		m_freem(m);
+
+	return (error);
+}
+
+static void
+vtnet_discard_merged_rxbuf(struct vtnet_softc *sc, int nbufs)
+{
+	struct virtqueue *vq;
+	struct mbuf *m;
+
+	vq = sc->vtnet_rx_vq;
+
+	while (--nbufs > 0) {
+		if ((m = virtqueue_dequeue(vq, NULL)) == NULL)
+			break;
+		vtnet_discard_rxbuf(sc, m);
+	}
+}
+
+static void
+vtnet_discard_rxbuf(struct vtnet_softc *sc, struct mbuf *m)
+{
+	int error;
+
+	/*
+	 * Requeue the discarded mbuf. This should always be
+	 * successful since it was just dequeued.
+	 */
+	error = vtnet_enqueue_rxbuf(sc, m);
+	KASSERT(error == 0, ("cannot requeue discarded mbuf"));
+}
+
+static int
+vtnet_enqueue_rxbuf(struct vtnet_softc *sc, struct mbuf *m)
+{
+	struct sglist sg;
+	struct sglist_seg segs[VTNET_MAX_RX_SEGS];
+	struct vtnet_rx_header *rxhdr;
+	struct virtio_net_hdr *hdr;
+	uint8_t *mdata;
+	int offset, error;
+
+	VTNET_LOCK_ASSERT(sc);
+	KASSERT(sc->vtnet_flags & VTNET_FLAG_LRO_NOMRG ||
+	    m->m_next == NULL, ("chained Rx mbuf without LRO_NOMRG"));
+
+	sglist_init(&sg, VTNET_MAX_RX_SEGS, segs);
+
+	mdata = mtod(m, uint8_t *);
+	offset = 0;
+
+	if ((sc->vtnet_flags & VTNET_FLAG_MRG_RXBUFS) == 0) {
+		rxhdr = (struct vtnet_rx_header *) mdata;
+		hdr = &rxhdr->vrh_hdr;
+		offset += sizeof(struct vtnet_rx_header);
+
+		error = sglist_append(&sg, hdr, sc->vtnet_hdr_size);
+		KASSERT(error == 0, ("cannot add header to sglist"));
+	}
+
+	error = sglist_append(&sg, mdata + offset, m->m_len - offset);
+	if (error)
+		return (error);
+
+	if (m->m_next != NULL) {
+		error = sglist_append_mbuf(&sg, m->m_next);
+		if (error)
+			return (error);
+	}
+
+	return (virtqueue_enqueue(sc->vtnet_rx_vq, m, &sg, 0, sg.sg_nseg));
+}
+
+static void
+vtnet_vlan_tag_remove(struct mbuf *m)
+{
+	struct ether_vlan_header *evl;
+
+	evl = mtod(m, struct ether_vlan_header *);
+
+	m->m_pkthdr.ether_vtag = ntohs(evl->evl_tag);
+	m->m_flags |= M_VLANTAG;
+
+	/* Strip the 802.1Q header. */
+	bcopy((char *) evl, (char *) evl + ETHER_VLAN_ENCAP_LEN,
+	    ETHER_HDR_LEN - ETHER_TYPE_LEN);
+	m_adj(m, ETHER_VLAN_ENCAP_LEN);
+}
+
+#ifdef notyet
+static int
+vtnet_rx_csum(struct vtnet_softc *sc, struct mbuf *m,
+    struct virtio_net_hdr *hdr)
+{
+	struct ether_header *eh;
+	struct ether_vlan_header *evh;
+	struct ip *ip;
+	struct ip6_hdr *ip6;
+	struct udphdr *udp;
+	int ip_offset, csum_start, csum_offset, hlen;
+	uint16_t eth_type;
+	uint8_t ip_proto;
+
+	/*
+	 * Convert the VirtIO checksum interface to FreeBSD's interface.
+	 * The host only provides us with the offset at which to start
+	 * checksumming, and the offset from that to place the completed
+	 * checksum. While this maps well with how Linux does checksums,
+	 * for FreeBSD, we must parse the received packet in order to set
+	 * the appropriate CSUM_* flags.
+	 */
+
+	/*
+	 * Every mbuf added to the receive virtqueue is always at least
+	 * MCLBYTES big, so assume something is amiss if the first mbuf
+	 * does not contain both the Ethernet and protocol headers.
+	 */
+	ip_offset = sizeof(struct ether_header);
+	if (m->m_len < ip_offset)
+		return (1);
+
+	eh = mtod(m, struct ether_header *);
+	eth_type = ntohs(eh->ether_type);
+	if (eth_type == ETHERTYPE_VLAN) {
+		ip_offset = sizeof(struct ether_vlan_header);
+		if (m->m_len < ip_offset)
+			return (1);
+		evh = mtod(m, struct ether_vlan_header *);
+		eth_type = ntohs(evh->evl_proto);
+	}
+
+	switch (eth_type) {
+	case ETHERTYPE_IP:
+		if (m->m_len < ip_offset + sizeof(struct ip))
+			return (1);
+
+		ip = (struct ip *)(mtod(m, uint8_t *) + ip_offset);
+		 /* Sanity check the IP header. */
+		if (ip->ip_v != IPVERSION)
+			return (1);
+		hlen = ip->ip_hl << 2;
+		if (hlen < sizeof(struct ip))
+			return (1);
+		if (ntohs(ip->ip_len) < hlen)
+			return (1);
+		if (ntohs(ip->ip_len) != (m->m_pkthdr.len - ip_offset))
+			return (1);
+
+		ip_proto = ip->ip_p;
+		csum_start = ip_offset + hlen;
+		break;
+
+	case ETHERTYPE_IPV6:
+		if (m->m_len < ip_offset + sizeof(struct ip6_hdr))
+			return (1);
+
+		/*
+		 * XXX FreeBSD does not handle any IPv6 checksum offloading
+		 * at the moment.
+		 */
+
+		ip6 = (struct ip6_hdr *)(mtod(m, uint8_t *) + ip_offset);
+		/* XXX Assume no extension headers are present. */
+		ip_proto = ip6->ip6_nxt;
+		csum_start = ip_offset + sizeof(struct ip6_hdr);
+		break;
+
+	default:
+		sc->vtnet_stats.rx_csum_bad_ethtype++;
+		return (1);
+	}
+
+	/* Assume checksum begins right after the IP header. */
+	if (hdr->csum_start != csum_start) {
+		sc->vtnet_stats.rx_csum_bad_start++;
+		return (1);
+	}
+
+	switch (ip_proto) {
+	case IPPROTO_TCP:
+		csum_offset = offsetof(struct tcphdr, th_sum);
+		break;
+
+	case IPPROTO_UDP:
+		csum_offset = offsetof(struct udphdr, uh_sum);
+		break;
+
+	case IPPROTO_SCTP:
+		csum_offset = offsetof(struct sctphdr, checksum);
+		break;
+
+	default:
+		sc->vtnet_stats.rx_csum_bad_ipproto++;
+		return (1);
+	}
+
+	if (hdr->csum_offset != csum_offset) {
+		sc->vtnet_stats.rx_csum_bad_offset++;
+		return (1);
+	}
+
+	/*
+	 * The IP header checksum is almost certainly valid but I'm
+	 * uncertain if that is guaranteed.
+	 *
+	 * m->m_pkthdr.csum_flags |= CSUM_IP_CHECKED | CSUM_IP_VALID;
+	 */
+
+	switch (ip_proto) {
+	case IPPROTO_UDP:
+		if (m->m_len < csum_start + sizeof(struct udphdr))
+			return (1);
+
+		udp = (struct udphdr *)(mtod(m, uint8_t *) + csum_start);
+		if (udp->uh_sum == 0)
+			return (0);
+
+		/* FALLTHROUGH */
+
+	case IPPROTO_TCP:
+		m->m_pkthdr.csum_flags |= CSUM_DATA_VALID | CSUM_PSEUDO_HDR;
+		m->m_pkthdr.csum_data = 0xFFFF;
+		break;
+
+	case IPPROTO_SCTP:
+		m->m_pkthdr.csum_flags |= CSUM_SCTP_VALID;
+		break;
+	}
+
+	sc->vtnet_stats.rx_csum_offloaded++;
+
+	return (0);
+}
+#endif
+
+/*
+ * Alternative method of doing receive checksum offloading. Rather
+ * than parsing the received frame down to the IP header, use the
+ * csum_offset to determine which CSUM_* flags are appropriate. We
+ * can get by with doing this only because the checksum offsets are
+ * unique for the things we care about.
+ */
+static int
+vtnet_rx_csum(struct vtnet_softc *sc, struct mbuf *m,
+    struct virtio_net_hdr *hdr)
+{
+	struct ether_header *eh;
+	struct ether_vlan_header *evh;
+	struct udphdr *udp;
+	int csum_len;
+	uint16_t eth_type;
+
+	csum_len = hdr->csum_start + hdr->csum_offset;
+
+	if (csum_len < sizeof(struct ether_header) + sizeof(struct ip))
+		return (1);
+	if (m->m_len < csum_len)
+		return (1);
+
+	eh = mtod(m, struct ether_header *);
+	eth_type = ntohs(eh->ether_type);
+	if (eth_type == ETHERTYPE_VLAN) {
+		evh = mtod(m, struct ether_vlan_header *);
+		eth_type = ntohs(evh->evl_proto);
+	}
+
+	if (eth_type != ETHERTYPE_IP && eth_type != ETHERTYPE_IPV6) {
+		sc->vtnet_stats.rx_csum_bad_ethtype++;
+		return (1);
+	}
+
+	/* Use the offset to determine the appropriate CSUM_* flags. */
+	switch (hdr->csum_offset) {
+	case offsetof(struct udphdr, uh_sum):
+		if (m->m_len < hdr->csum_start + sizeof(struct udphdr))
+			return (1);
+		udp = (struct udphdr *)(mtod(m, uint8_t *) + hdr->csum_start);
+		if (udp->uh_sum == 0)
+			return (0);
+
+		/* FALLTHROUGH */
+
+	case offsetof(struct tcphdr, th_sum):
+		m->m_pkthdr.csum_flags |= CSUM_DATA_VALID | CSUM_PSEUDO_HDR;
+		m->m_pkthdr.csum_data = 0xFFFF;
+		break;
+
+	case offsetof(struct sctphdr, checksum):
+		m->m_pkthdr.csum_flags |= CSUM_SCTP_VALID;
+		break;
+
+	default:
+		sc->vtnet_stats.rx_csum_bad_offset++;
+		return (1);
+	}
+
+	sc->vtnet_stats.rx_csum_offloaded++;
+
+	return (0);
+}
+
+static int
+vtnet_rxeof_merged(struct vtnet_softc *sc, struct mbuf *m_head, int nbufs)
+{
+	struct ifnet *ifp;
+	struct virtqueue *vq;
+	struct mbuf *m, *m_tail;
+	int len;
+
+	ifp = sc->vtnet_ifp;
+	vq = sc->vtnet_rx_vq;
+	m_tail = m_head;
+
+	while (--nbufs > 0) {
+		m = virtqueue_dequeue(vq, &len);
+		if (m == NULL) {
+			ifp->if_ierrors++;
+			goto fail;
+		}
+
+		if (vtnet_newbuf(sc) != 0) {
+			ifp->if_iqdrops++;
+			vtnet_discard_rxbuf(sc, m);
+			if (nbufs > 1)
+				vtnet_discard_merged_rxbuf(sc, nbufs);
+			goto fail;
+		}
+
+		if (m->m_len < len)
+			len = m->m_len;
+
+		m->m_len = len;
+		m->m_flags &= ~M_PKTHDR;
+
+		m_head->m_pkthdr.len += len;
+		m_tail->m_next = m;
+		m_tail = m;
+	}
+
+	return (0);
+
+fail:
+	sc->vtnet_stats.rx_mergeable_failed++;
+	m_freem(m_head);
+
+	return (1);
+}
+
+static int
+vtnet_rxeof(struct vtnet_softc *sc, int count, int *rx_npktsp)
+{
+	struct virtio_net_hdr lhdr;
+	struct ifnet *ifp;
+	struct virtqueue *vq;
+	struct mbuf *m;
+	struct ether_header *eh;
+	struct virtio_net_hdr *hdr;
+	struct virtio_net_hdr_mrg_rxbuf *mhdr;
+	int len, deq, nbufs, adjsz, rx_npkts;
+
+	ifp = sc->vtnet_ifp;
+	vq = sc->vtnet_rx_vq;
+	hdr = &lhdr;
+	deq = 0;
+	rx_npkts = 0;
+
+	VTNET_LOCK_ASSERT(sc);
+
+	while (--count >= 0) {
+		m = virtqueue_dequeue(vq, &len);
+		if (m == NULL)
+			break;
+		deq++;
+
+		if (len < sc->vtnet_hdr_size + ETHER_HDR_LEN) {
+			ifp->if_ierrors++;
+			vtnet_discard_rxbuf(sc, m);
+			continue;
+		}
+
+		if ((sc->vtnet_flags & VTNET_FLAG_MRG_RXBUFS) == 0) {
+			nbufs = 1;
+			adjsz = sizeof(struct vtnet_rx_header);
+			/*
+			 * Account for our pad between the header and
+			 * the actual start of the frame.
+			 */
+			len += VTNET_RX_HEADER_PAD;
+		} else {
+			mhdr = mtod(m, struct virtio_net_hdr_mrg_rxbuf *);
+			nbufs = mhdr->num_buffers;
+			adjsz = sizeof(struct virtio_net_hdr_mrg_rxbuf);
+		}
+
+		if (vtnet_replace_rxbuf(sc, m, len) != 0) {
+			ifp->if_iqdrops++;
+			vtnet_discard_rxbuf(sc, m);
+			if (nbufs > 1)
+				vtnet_discard_merged_rxbuf(sc, nbufs);
+			continue;
+		}
+
+		m->m_pkthdr.len = len;
+		m->m_pkthdr.rcvif = ifp;
+		m->m_pkthdr.csum_flags = 0;
+
+		if (nbufs > 1) {
+			if (vtnet_rxeof_merged(sc, m, nbufs) != 0)
+				continue;
+		}
+
+		ifp->if_ipackets++;
+
+		/*
+		 * Save copy of header before we strip it. For both mergeable
+		 * and non-mergeable, the VirtIO header is placed first in the
+		 * mbuf's data. We no longer need num_buffers, so always use a
+		 * virtio_net_hdr.
+		 */
+		memcpy(hdr, mtod(m, void *), sizeof(struct virtio_net_hdr));
+		m_adj(m, adjsz);
+
+		if (ifp->if_capenable & IFCAP_VLAN_HWTAGGING) {
+			eh = mtod(m, struct ether_header *);
+			if (eh->ether_type == htons(ETHERTYPE_VLAN)) {
+				vtnet_vlan_tag_remove(m);
+
+				/*
+				 * With the 802.1Q header removed, update the
+				 * checksum starting location accordingly.
+				 */
+				if (hdr->flags & VIRTIO_NET_HDR_F_NEEDS_CSUM)
+					hdr->csum_start -=
+					    ETHER_VLAN_ENCAP_LEN;
+			}
+		}
+
+		if (ifp->if_capenable & IFCAP_RXCSUM &&
+		    hdr->flags & VIRTIO_NET_HDR_F_NEEDS_CSUM) {
+			if (vtnet_rx_csum(sc, m, hdr) != 0)
+				sc->vtnet_stats.rx_csum_failed++;
+		}
+
+		VTNET_UNLOCK(sc);
+		rx_npkts++;
+		(*ifp->if_input)(ifp, m);
+		VTNET_LOCK(sc);
+
+		/*
+		 * The interface may have been stopped while we were
+		 * passing the packet up the network stack.
+		 */
+		if ((ifp->if_drv_flags & IFF_DRV_RUNNING) == 0)
+			break;
+	}
+
+	if (deq > 0)
+		virtqueue_notify(vq);
+
+	if (rx_npktsp != NULL)
+		*rx_npktsp = rx_npkts;
+
+	return (count > 0 ? 0 : EAGAIN);
+}
+
+static void
+vtnet_rx_intr_task(void *arg, int pending)
+{
+	struct vtnet_softc *sc;
+	struct ifnet *ifp;
+	int more;
+
+	sc = arg;
+	ifp = sc->vtnet_ifp;
+
+	VTNET_LOCK(sc);
+
+#ifdef DEVICE_POLLING
+	if (ifp->if_capenable & IFCAP_POLLING) {
+		VTNET_UNLOCK(sc);
+		return;
+	}
+#endif
+
+	if ((ifp->if_drv_flags & IFF_DRV_RUNNING) == 0) {
+		vtnet_enable_rx_intr(sc);
+		VTNET_UNLOCK(sc);
+		return;
+	}
+
+	more = vtnet_rxeof(sc, sc->vtnet_rx_process_limit, NULL);
+	if (!more && vtnet_enable_rx_intr(sc) != 0) {
+		vtnet_disable_rx_intr(sc);
+		more = 1;
+	}
+
+	VTNET_UNLOCK(sc);
+
+	if (more) {
+		sc->vtnet_stats.rx_task_rescheduled++;
+		taskqueue_enqueue_fast(sc->vtnet_tq,
+		    &sc->vtnet_rx_intr_task);
+	}
+}
+
+static int
+vtnet_rx_vq_intr(void *xsc)
+{
+	struct vtnet_softc *sc;
+
+	sc = xsc;
+
+	vtnet_disable_rx_intr(sc);
+	taskqueue_enqueue_fast(sc->vtnet_tq, &sc->vtnet_rx_intr_task);
+
+	return (1);
+}
+
+static void
+vtnet_txeof(struct vtnet_softc *sc)
+{
+	struct virtqueue *vq;
+	struct ifnet *ifp;
+	struct vtnet_tx_header *txhdr;
+	int deq;
+
+	vq = sc->vtnet_tx_vq;
+	ifp = sc->vtnet_ifp;
+	deq = 0;
+
+	VTNET_LOCK_ASSERT(sc);
+
+	while ((txhdr = virtqueue_dequeue(vq, NULL)) != NULL) {
+		deq++;
+		ifp->if_opackets++;
+		m_freem(txhdr->vth_mbuf);
+		uma_zfree(vtnet_tx_header_zone, txhdr);
+	}
+
+	if (deq > 0) {
+		ifp->if_drv_flags &= ~IFF_DRV_OACTIVE;
+		if (virtqueue_empty(vq))
+			sc->vtnet_watchdog_timer = 0;
+	}
+}
+
+static struct mbuf *
+vtnet_tx_offload(struct vtnet_softc *sc, struct mbuf *m,
+    struct virtio_net_hdr *hdr)
+{
+	struct ifnet *ifp;
+	struct ether_header *eh;
+	struct ether_vlan_header *evh;
+	struct ip *ip;
+	struct ip6_hdr *ip6;
+	struct tcphdr *tcp;
+	int ip_offset;
+	uint16_t eth_type, csum_start;
+	uint8_t ip_proto, gso_type;
+
+	ifp = sc->vtnet_ifp;
+	M_ASSERTPKTHDR(m);
+
+	ip_offset = sizeof(struct ether_header);
+	if (m->m_len < ip_offset) {
+		if ((m = m_pullup(m, ip_offset)) == NULL)
+			return (NULL);
+	}
+
+	eh = mtod(m, struct ether_header *);
+	eth_type = ntohs(eh->ether_type);
+	if (eth_type == ETHERTYPE_VLAN) {
+		ip_offset = sizeof(struct ether_vlan_header);
+		if (m->m_len < ip_offset) {
+			if ((m = m_pullup(m, ip_offset)) == NULL)
+				return (NULL);
+		}
+		evh = mtod(m, struct ether_vlan_header *);
+		eth_type = ntohs(evh->evl_proto);
+	}
+
+	switch (eth_type) {
+	case ETHERTYPE_IP:
+		if (m->m_len < ip_offset + sizeof(struct ip)) {
+			m = m_pullup(m, ip_offset + sizeof(struct ip));
+			if (m == NULL)
+				return (NULL);
+		}
+
+		ip = (struct ip *)(mtod(m, uint8_t *) + ip_offset);
+		ip_proto = ip->ip_p;
+		csum_start = ip_offset + (ip->ip_hl << 2);
+		gso_type = VIRTIO_NET_HDR_GSO_TCPV4;
+		break;
+
+	case ETHERTYPE_IPV6:
+		if (m->m_len < ip_offset + sizeof(struct ip6_hdr)) {
+			m = m_pullup(m, ip_offset + sizeof(struct ip6_hdr));
+			if (m == NULL)
+				return (NULL);
+		}
+
+		ip6 = (struct ip6_hdr *)(mtod(m, uint8_t *) + ip_offset);
+		/*
+		 * XXX Assume no extension headers are present. Presently,
+		 * this will always be true in the case of TSO, and FreeBSD
+		 * does not perform checksum offloading of IPv6 yet.
+		 */
+		ip_proto = ip6->ip6_nxt;
+		csum_start = ip_offset + sizeof(struct ip6_hdr);
+		gso_type = VIRTIO_NET_HDR_GSO_TCPV6;
+		break;
+
+	default:
+		return (m);
+	}
+
+	if (m->m_pkthdr.csum_flags & VTNET_CSUM_OFFLOAD) {
+		hdr->flags |= VIRTIO_NET_HDR_F_NEEDS_CSUM;
+		hdr->csum_start = csum_start;
+		hdr->csum_offset = m->m_pkthdr.csum_data;
+
+		sc->vtnet_stats.tx_csum_offloaded++;
+	}
+
+	if (m->m_pkthdr.csum_flags & CSUM_TSO) {
+		if (ip_proto != IPPROTO_TCP)
+			return (m);
+
+		if (m->m_len < csum_start + sizeof(struct tcphdr)) {
+			m = m_pullup(m, csum_start + sizeof(struct tcphdr));
+			if (m == NULL)
+				return (NULL);
+		}
+
+		tcp = (struct tcphdr *)(mtod(m, uint8_t *) + csum_start);
+		hdr->gso_type = gso_type;
+		hdr->hdr_len = csum_start + (tcp->th_off << 2);
+		hdr->gso_size = m->m_pkthdr.tso_segsz;
+
+		if (tcp->th_flags & TH_CWR) {
+			/*
+			 * Drop if we did not negotiate VIRTIO_NET_F_HOST_ECN.
+			 * ECN support is only configurable globally with the
+			 * net.inet.tcp.ecn.enable sysctl knob.
+			 */
+			if ((sc->vtnet_flags & VTNET_FLAG_TSO_ECN) == 0) {
+				if_printf(ifp, "TSO with ECN not supported "
+				    "by host\n");
+				m_freem(m);
+				return (NULL);
+			}
+
+			hdr->flags |= VIRTIO_NET_HDR_GSO_ECN;
+		}
+
+		sc->vtnet_stats.tx_tso_offloaded++;
+	}
+
+	return (m);
+}
+
+static int
+vtnet_enqueue_txbuf(struct vtnet_softc *sc, struct mbuf **m_head,
+    struct vtnet_tx_header *txhdr)
+{
+	struct sglist sg;
+	struct sglist_seg segs[VTNET_MAX_TX_SEGS];
+	struct virtqueue *vq;
+	struct mbuf *m;
+	int collapsed, error;
+
+	vq = sc->vtnet_tx_vq;
+	m = *m_head;
+	collapsed = 0;
+
+	sglist_init(&sg, VTNET_MAX_TX_SEGS, segs);
+	error = sglist_append(&sg, &txhdr->vth_uhdr, sc->vtnet_hdr_size);
+	KASSERT(error == 0 && sg.sg_nseg == 1,
+	    ("cannot add header to sglist"));
+
+again:
+	error = sglist_append_mbuf(&sg, m);
+	if (error) {
+		if (collapsed)
+			goto fail;
+
+		m = m_collapse(m, M_DONTWAIT, VTNET_MAX_TX_SEGS - 1);
+		if (m == NULL)
+			goto fail;
+
+		*m_head = m;
+		collapsed = 1;
+		goto again;
+	}
+
+	txhdr->vth_mbuf = m;
+
+	return (virtqueue_enqueue(vq, txhdr, &sg, sg.sg_nseg, 0));
+
+fail:
+	m_freem(*m_head);
+	*m_head = NULL;
+
+	return (ENOBUFS);
+}
+
+static int
+vtnet_encap(struct vtnet_softc *sc, struct mbuf **m_head)
+{
+	struct vtnet_tx_header *txhdr;
+	struct virtio_net_hdr *hdr;
+	struct mbuf *m;
+	int error;
+
+	m = *m_head;
+
+	txhdr = uma_zalloc(vtnet_tx_header_zone, M_NOWAIT | M_ZERO);
+	if (txhdr == NULL) {
+		*m_head = NULL;
+		m_freem(m);
+		return (ENOMEM);
+	}
+
+	/*
+	 * Always use the non-mergeable header to simplify things. When
+	 * the mergeable feature is negotiated, the num_buffers field
+	 * must be set to zero. We use vtnet_hdr_size later to enqueue
+	 * the correct header size to the host.
+	 */
+	hdr = &txhdr->vth_uhdr.hdr;
+
+	if (m->m_flags & M_VLANTAG) {
+		m = ether_vlanencap(m, m->m_pkthdr.ether_vtag);
+		if ((*m_head = m) == NULL) {
+			error = ENOBUFS;
+			goto fail;
+		}
+		m->m_flags &= ~M_VLANTAG;
+	}
+
+	if (m->m_pkthdr.csum_flags != 0) {
+		m = vtnet_tx_offload(sc, m, hdr);
+		if ((*m_head = m) == NULL) {
+			error = ENOBUFS;
+			goto fail;
+		}
+	}
+
+	error = vtnet_enqueue_txbuf(sc, m_head, txhdr);
+fail:
+	if (error)
+		uma_zfree(vtnet_tx_header_zone, txhdr);
+
+	return (error);
+}
+
+static void
+vtnet_start(struct ifnet *ifp)
+{
+	struct vtnet_softc *sc;
+
+	sc = ifp->if_softc;
+
+	VTNET_LOCK(sc);
+	vtnet_start_locked(ifp);
+	VTNET_UNLOCK(sc);
+}
+
+static void
+vtnet_start_locked(struct ifnet *ifp)
+{
+	struct vtnet_softc *sc;
+	struct virtqueue *vq;
+	struct mbuf *m0;
+	int enq;
+
+	sc = ifp->if_softc;
+	vq = sc->vtnet_tx_vq;
+	enq = 0;
+
+	VTNET_LOCK_ASSERT(sc);
+
+	if ((ifp->if_drv_flags & (IFF_DRV_RUNNING | IFF_DRV_OACTIVE)) !=
+	    IFF_DRV_RUNNING || ((sc->vtnet_flags & VTNET_FLAG_LINK) == 0))
+		return;
+
+#ifdef VTNET_TX_INTR_MODERATION
+	if (virtqueue_nused(vq) >= sc->vtnet_tx_size / 2)
+		vtnet_txeof(sc);
+#endif
+
+	while (!IFQ_DRV_IS_EMPTY(&ifp->if_snd)) {
+		if (virtqueue_full(vq)) {
+			ifp->if_drv_flags |= IFF_DRV_OACTIVE;
+			break;
+		}
+
+		IFQ_DRV_DEQUEUE(&ifp->if_snd, m0);
+		if (m0 == NULL)
+			break;
+
+		if (vtnet_encap(sc, &m0) != 0) {
+			if (m0 == NULL)
+				break;
+			IFQ_DRV_PREPEND(&ifp->if_snd, m0);
+			ifp->if_drv_flags |= IFF_DRV_OACTIVE;
+			break;
+		}
+
+		enq++;
+		ETHER_BPF_MTAP(ifp, m0);
+	}
+
+	if (enq > 0) {
+		virtqueue_notify(vq);
+		sc->vtnet_watchdog_timer = VTNET_WATCHDOG_TIMEOUT;
+	}
+}
+
+static void
+vtnet_tick(void *xsc)
+{
+	struct vtnet_softc *sc;
+
+	sc = xsc;
+
+	VTNET_LOCK_ASSERT(sc);
+#ifdef VTNET_DEBUG
+	virtqueue_dump(sc->vtnet_rx_vq);
+	virtqueue_dump(sc->vtnet_tx_vq);
+#endif
+
+	vtnet_watchdog(sc);
+	callout_reset(&sc->vtnet_tick_ch, hz, vtnet_tick, sc);
+}
+
+static void
+vtnet_tx_intr_task(void *arg, int pending)
+{
+	struct vtnet_softc *sc;
+	struct ifnet *ifp;
+
+	sc = arg;
+	ifp = sc->vtnet_ifp;
+
+	VTNET_LOCK(sc);
+
+#ifdef DEVICE_POLLING
+	if (ifp->if_capenable & IFCAP_POLLING) {
+		VTNET_UNLOCK(sc);
+		return;
+	}
+#endif
+
+	if ((ifp->if_drv_flags & IFF_DRV_RUNNING) == 0) {
+		vtnet_enable_tx_intr(sc);
+		VTNET_UNLOCK(sc);
+		return;
+	}
+
+	vtnet_txeof(sc);
+
+	if (!IFQ_DRV_IS_EMPTY(&ifp->if_snd))
+		vtnet_start_locked(ifp);
+
+	if (vtnet_enable_tx_intr(sc) != 0) {
+		vtnet_disable_tx_intr(sc);
+		sc->vtnet_stats.tx_task_rescheduled++;
+		VTNET_UNLOCK(sc);
+		taskqueue_enqueue_fast(sc->vtnet_tq, &sc->vtnet_tx_intr_task);
+		return;
+	}
+
+	VTNET_UNLOCK(sc);
+}
+
+static int
+vtnet_tx_vq_intr(void *xsc)
+{
+	struct vtnet_softc *sc;
+
+	sc = xsc;
+
+	vtnet_disable_tx_intr(sc);
+	taskqueue_enqueue_fast(sc->vtnet_tq, &sc->vtnet_tx_intr_task);
+
+	return (1);
+}
+
+static void
+vtnet_stop(struct vtnet_softc *sc)
+{
+	device_t dev;
+	struct ifnet *ifp;
+
+	dev = sc->vtnet_dev;
+	ifp = sc->vtnet_ifp;
+
+	VTNET_LOCK_ASSERT(sc);
+
+	sc->vtnet_watchdog_timer = 0;
+	callout_stop(&sc->vtnet_tick_ch);
+	ifp->if_drv_flags &= ~(IFF_DRV_RUNNING | IFF_DRV_OACTIVE);
+
+	vtnet_disable_rx_intr(sc);
+	vtnet_disable_tx_intr(sc);
+
+	/*
+	 * Stop the host VirtIO adapter. Note this will reset the host
+	 * adapter's state back to the pre-initialized state, so in
+	 * order to make the device usable again, we must drive it
+	 * through virtio_reinit() and virtio_reinit_complete().
+	 */
+	virtio_stop(dev);
+
+	sc->vtnet_flags &= ~VTNET_FLAG_LINK;
+
+	vtnet_free_rx_mbufs(sc);
+	vtnet_free_tx_mbufs(sc);
+}
+
+static int
+vtnet_reinit(struct vtnet_softc *sc)
+{
+	struct ifnet *ifp;
+	uint64_t features;
+
+	ifp = sc->vtnet_ifp;
+	features = sc->vtnet_features;
+
+	/*
+	 * Re-negotiate with the host, removing any disabled receive
+	 * features. Transmit features are disabled only on our side
+	 * via if_capenable and if_hwassist.
+	 */
+
+	if (ifp->if_capabilities & IFCAP_RXCSUM) {
+		if ((ifp->if_capenable & IFCAP_RXCSUM) == 0)
+			features &= ~VIRTIO_NET_F_GUEST_CSUM;
+	}
+
+	if (ifp->if_capabilities & IFCAP_LRO) {
+		if ((ifp->if_capenable & IFCAP_LRO) == 0)
+			features &= ~VTNET_LRO_FEATURES;
+	}
+
+	if (ifp->if_capabilities & IFCAP_VLAN_HWFILTER) {
+		if ((ifp->if_capenable & IFCAP_VLAN_HWFILTER) == 0)
+			features &= ~VIRTIO_NET_F_CTRL_VLAN;
+	}
+
+	return (virtio_reinit(sc->vtnet_dev, features));
+}
+
+static void
+vtnet_init_locked(struct vtnet_softc *sc)
+{
+	device_t dev;
+	struct ifnet *ifp;
+	int error;
+
+	dev = sc->vtnet_dev;
+	ifp = sc->vtnet_ifp;
+
+	VTNET_LOCK_ASSERT(sc);
+
+	if (ifp->if_drv_flags & IFF_DRV_RUNNING)
+		return;
+
+	/* Stop host's adapter, cancel any pending I/O. */
+	vtnet_stop(sc);
+
+	/* Reinitialize the host device. */
+	error = vtnet_reinit(sc);
+	if (error) {
+		device_printf(dev,
+		    "reinitialization failed, stopping device...\n");
+		vtnet_stop(sc);
+		return;
+	}
+
+	/* Update host with assigned MAC address. */
+	bcopy(IF_LLADDR(ifp), sc->vtnet_hwaddr, ETHER_ADDR_LEN);
+	vtnet_set_hwaddr(sc);
+
+	ifp->if_hwassist = 0;
+	if (ifp->if_capenable & IFCAP_TXCSUM)
+		ifp->if_hwassist |= VTNET_CSUM_OFFLOAD;
+	if (ifp->if_capenable & IFCAP_TSO4)
+		ifp->if_hwassist |= CSUM_TSO;
+
+	error = vtnet_init_rx_vq(sc);
+	if (error) {
+		device_printf(dev,
+		    "cannot allocate mbufs for Rx virtqueue\n");
+		vtnet_stop(sc);
+		return;
+	}
+
+	if (sc->vtnet_flags & VTNET_FLAG_CTRL_VQ) {
+		if (sc->vtnet_flags & VTNET_FLAG_CTRL_RX) {
+			/* Restore promiscuous and all-multicast modes. */
+			vtnet_rx_filter(sc);
+
+			/* Restore filtered MAC addresses. */
+			vtnet_rx_filter_mac(sc);
+		}
+
+		/* Restore VLAN filters. */
+		if (ifp->if_capenable & IFCAP_VLAN_HWFILTER)
+			vtnet_rx_filter_vlan(sc);
+	}
+
+#ifdef DEVICE_POLLING
+	if (ifp->if_capenable & IFCAP_POLLING) {
+		vtnet_disable_rx_intr(sc);
+		vtnet_disable_tx_intr(sc);
+	} else
+#endif
+	{
+		vtnet_enable_rx_intr(sc);
+		vtnet_enable_tx_intr(sc);
+	}
+
+	ifp->if_drv_flags |= IFF_DRV_RUNNING;
+	ifp->if_drv_flags &= ~IFF_DRV_OACTIVE;
+
+	virtio_reinit_complete(dev);
+
+	vtnet_update_link_status(sc);
+	callout_reset(&sc->vtnet_tick_ch, hz, vtnet_tick, sc);
+}
+
+static void
+vtnet_init(void *xsc)
+{
+	struct vtnet_softc *sc;
+
+	sc = xsc;
+
+	VTNET_LOCK(sc);
+	vtnet_init_locked(sc);
+	VTNET_UNLOCK(sc);
+}
+
+static void
+vtnet_exec_ctrl_cmd(struct vtnet_softc *sc, void *cookie,
+    struct sglist *sg, int readable, int writable)
+{
+	struct virtqueue *vq;
+	void *c;
+
+	vq = sc->vtnet_ctrl_vq;
+
+	VTNET_LOCK_ASSERT(sc);
+	KASSERT(sc->vtnet_flags & VTNET_FLAG_CTRL_VQ,
+	    ("no control virtqueue"));
+	KASSERT(virtqueue_empty(vq),
+	    ("control command already enqueued"));
+
+	if (virtqueue_enqueue(vq, cookie, sg, readable, writable) != 0)
+		return;
+
+	virtqueue_notify(vq);
+
+	/*
+	 * Poll until the command is complete. Previously, we would
+	 * sleep until the control virtqueue interrupt handler woke
+	 * us up, but dropping the VTNET_MTX leads to serialization
+	 * difficulties.
+	 *
+	 * Furthermore, it appears QEMU/KVM only allocates three MSIX
+	 * vectors. Two of those vectors are needed for the Rx and Tx
+	 * virtqueues. We do not support sharing both a Vq and config
+	 * changed notification on the same MSIX vector.
+	 */
+	c = virtqueue_poll(vq, NULL);
+	KASSERT(c == cookie, ("unexpected control command response"));
+}
+
+static void
+vtnet_rx_filter(struct vtnet_softc *sc)
+{
+	device_t dev;
+	struct ifnet *ifp;
+
+	dev = sc->vtnet_dev;
+	ifp = sc->vtnet_ifp;
+
+	VTNET_LOCK_ASSERT(sc);
+	KASSERT(sc->vtnet_flags & VTNET_FLAG_CTRL_RX,
+	    ("CTRL_RX feature not negotiated"));
+
+	if (vtnet_set_promisc(sc, ifp->if_flags & IFF_PROMISC) != 0)
+		device_printf(dev, "cannot %s promiscuous mode\n",
+		    ifp->if_flags & IFF_PROMISC ? "enable" : "disable");
+
+	if (vtnet_set_allmulti(sc, ifp->if_flags & IFF_ALLMULTI) != 0)
+		device_printf(dev, "cannot %s all-multicast mode\n",
+		    ifp->if_flags & IFF_ALLMULTI ? "enable" : "disable");
+}
+
+static int
+vtnet_ctrl_rx_cmd(struct vtnet_softc *sc, int cmd, int on)
+{
+	struct virtio_net_ctrl_hdr hdr;
+	struct sglist_seg segs[3];
+	struct sglist sg;
+	uint8_t onoff, ack;
+	int error;
+
+	if ((sc->vtnet_flags & VTNET_FLAG_CTRL_RX) == 0)
+		return (ENOTSUP);
+
+	error = 0;
+
+	hdr.class = VIRTIO_NET_CTRL_RX;
+	hdr.cmd = cmd;
+	onoff = !!on;
+	ack = VIRTIO_NET_ERR;
+
+	sglist_init(&sg, 3, segs);
+	error |= sglist_append(&sg, &hdr, sizeof(struct virtio_net_ctrl_hdr));
+	error |= sglist_append(&sg, &onoff, sizeof(uint8_t));
+	error |= sglist_append(&sg, &ack, sizeof(uint8_t));
+	KASSERT(error == 0 && sg.sg_nseg == 3,
+	    ("error adding Rx filter message to sglist"));
+
+	vtnet_exec_ctrl_cmd(sc, &ack, &sg, sg.sg_nseg - 1, 1);
+
+	return (ack == VIRTIO_NET_OK ? 0 : EIO);
+}
+
+static int
+vtnet_set_promisc(struct vtnet_softc *sc, int on)
+{
+
+	return (vtnet_ctrl_rx_cmd(sc, VIRTIO_NET_CTRL_RX_PROMISC, on));
+}
+
+static int
+vtnet_set_allmulti(struct vtnet_softc *sc, int on)
+{
+
+	return (vtnet_ctrl_rx_cmd(sc, VIRTIO_NET_CTRL_RX_ALLMULTI, on));
+}
+
+static void
+vtnet_rx_filter_mac(struct vtnet_softc *sc)
+{
+	struct virtio_net_ctrl_hdr hdr;
+	struct vtnet_mac_filter *filter;
+	struct sglist_seg segs[4];
+	struct sglist sg;
+	struct ifnet *ifp;
+	struct ifaddr *ifa;
+	struct ifmultiaddr *ifma;
+	int ucnt, mcnt, promisc, allmulti, error;
+	uint8_t ack;
+
+	ifp = sc->vtnet_ifp;
+	filter = sc->vtnet_mac_filter;
+	ucnt = 0;
+	mcnt = 0;
+	promisc = 0;
+	allmulti = 0;
+	error = 0;
+
+	VTNET_LOCK_ASSERT(sc);
+	KASSERT(sc->vtnet_flags & VTNET_FLAG_CTRL_RX,
+	    ("CTRL_RX feature not negotiated"));
+
+	/* Unicast MAC addresses: */
+	if_addr_rlock(ifp);
+	TAILQ_FOREACH(ifa, &ifp->if_addrhead, ifa_link) {
+		if (ifa->ifa_addr->sa_family != AF_LINK)
+			continue;
+		else if (ucnt == VTNET_MAX_MAC_ENTRIES)
+			break;
+
+		bcopy(LLADDR((struct sockaddr_dl *)ifa->ifa_addr),
+		    &filter->vmf_unicast.macs[ucnt], ETHER_ADDR_LEN);
+		ucnt++;
+	}
+	if_addr_runlock(ifp);
+
+	if (ucnt >= VTNET_MAX_MAC_ENTRIES) {
+		promisc = 1;
+		filter->vmf_unicast.nentries = 0;
+
+		if_printf(ifp, "more than %d MAC addresses assigned, "
+		    "falling back to promiscuous mode\n",
+		    VTNET_MAX_MAC_ENTRIES);
+	} else
+		filter->vmf_unicast.nentries = ucnt;
+
+	/* Multicast MAC addresses: */
+	if_maddr_rlock(ifp);
+	TAILQ_FOREACH(ifma, &ifp->if_multiaddrs, ifma_link) {
+		if (ifma->ifma_addr->sa_family != AF_LINK)
+			continue;
+		else if (mcnt == VTNET_MAX_MAC_ENTRIES)
+			break;
+
+		bcopy(LLADDR((struct sockaddr_dl *)ifma->ifma_addr),
+		    &filter->vmf_multicast.macs[mcnt], ETHER_ADDR_LEN);
+		mcnt++;
+	}
+	if_maddr_runlock(ifp);
+
+	if (mcnt >= VTNET_MAX_MAC_ENTRIES) {
+		allmulti = 1;
+		filter->vmf_multicast.nentries = 0;
+
+		if_printf(ifp, "more than %d multicast MAC addresses "
+		    "assigned, falling back to all-multicast mode\n",
+		    VTNET_MAX_MAC_ENTRIES);
+	} else
+		filter->vmf_multicast.nentries = mcnt;
+
+	if (promisc && allmulti)
+		goto out;
+
+	hdr.class = VIRTIO_NET_CTRL_MAC;
+	hdr.cmd = VIRTIO_NET_CTRL_MAC_TABLE_SET;
+	ack = VIRTIO_NET_ERR;
+
+	sglist_init(&sg, 4, segs);
+	error |= sglist_append(&sg, &hdr, sizeof(struct virtio_net_ctrl_hdr));
+	error |= sglist_append(&sg, &filter->vmf_unicast,
+	    sizeof(uint32_t) + filter->vmf_unicast.nentries * ETHER_ADDR_LEN);
+	error |= sglist_append(&sg, &filter->vmf_multicast,
+	    sizeof(uint32_t) + filter->vmf_multicast.nentries * ETHER_ADDR_LEN);
+	error |= sglist_append(&sg, &ack, sizeof(uint8_t));
+	KASSERT(error == 0 && sg.sg_nseg == 4,
+	    ("error adding MAC filtering message to sglist"));
+
+	vtnet_exec_ctrl_cmd(sc, &ack, &sg, sg.sg_nseg - 1, 1);
+
+	if (ack != VIRTIO_NET_OK)
+		if_printf(ifp, "error setting host MAC filter table\n");
+
+out:
+	if (promisc)
+		if (vtnet_set_promisc(sc, 1) != 0)
+			if_printf(ifp, "cannot enable promiscuous mode\n");
+	if (allmulti)
+		if (vtnet_set_allmulti(sc, 1) != 0)
+			if_printf(ifp, "cannot enable all-multicast mode\n");
+}
+
+static int
+vtnet_exec_vlan_filter(struct vtnet_softc *sc, int add, uint16_t tag)
+{
+	struct virtio_net_ctrl_hdr hdr;
+	struct sglist_seg segs[3];
+	struct sglist sg;
+	uint8_t ack;
+	int error;
+
+	hdr.class = VIRTIO_NET_CTRL_VLAN;
+	hdr.cmd = add ? VIRTIO_NET_CTRL_VLAN_ADD : VIRTIO_NET_CTRL_VLAN_DEL;
+	ack = VIRTIO_NET_ERR;
+	error = 0;
+
+	sglist_init(&sg, 3, segs);
+	error |= sglist_append(&sg, &hdr, sizeof(struct virtio_net_ctrl_hdr));
+	error |= sglist_append(&sg, &tag, sizeof(uint16_t));
+	error |= sglist_append(&sg, &ack, sizeof(uint8_t));
+	KASSERT(error == 0 && sg.sg_nseg == 3,
+	    ("error adding VLAN control message to sglist"));
+
+	vtnet_exec_ctrl_cmd(sc, &ack, &sg, sg.sg_nseg - 1, 1);
+
+	return (ack == VIRTIO_NET_OK ? 0 : EIO);
+}
+
+static void
+vtnet_rx_filter_vlan(struct vtnet_softc *sc)
+{
+	device_t dev;
+	uint32_t w, mask;
+	uint16_t tag;
+	int i, nvlans, error;
+
+	VTNET_LOCK_ASSERT(sc);
+	KASSERT(sc->vtnet_flags & VTNET_FLAG_VLAN_FILTER,
+	    ("VLAN_FILTER feature not negotiated"));
+
+	dev = sc->vtnet_dev;
+	nvlans = sc->vtnet_nvlans;
+	error = 0;
+
+	/* Enable filtering for each configured VLAN. */
+	for (i = 0; i < VTNET_VLAN_SHADOW_SIZE && nvlans > 0; i++) {
+		w = sc->vtnet_vlan_shadow[i];
+		for (mask = 1, tag = i * 32; w != 0; mask <<= 1, tag++) {
+			if ((w & mask) != 0) {
+				w &= ~mask;
+				nvlans--;
+				if (vtnet_exec_vlan_filter(sc, 1, tag) != 0)
+					error++;
+			}
+		}
+	}
+
+	KASSERT(nvlans == 0, ("VLAN count incorrect"));
+	if (error)
+		device_printf(dev, "cannot restore VLAN filter table\n");
+}
+
+static void
+vtnet_set_vlan_filter(struct vtnet_softc *sc, int add, uint16_t tag)
+{
+	struct ifnet *ifp;
+	int idx, bit;
+
+	KASSERT(sc->vtnet_flags & VTNET_FLAG_VLAN_FILTER,
+	    ("VLAN_FILTER feature not negotiated"));
+
+	if ((tag == 0) || (tag > 4095))
+		return;
+
+	ifp = sc->vtnet_ifp;
+	idx = (tag >> 5) & 0x7F;
+	bit = tag & 0x1F;
+
+	VTNET_LOCK(sc);
+
+	/* Update shadow VLAN table. */
+	if (add) {
+		sc->vtnet_nvlans++;
+		sc->vtnet_vlan_shadow[idx] |= (1 << bit);
+	} else {
+		sc->vtnet_nvlans--;
+		sc->vtnet_vlan_shadow[idx] &= ~(1 << bit);
+	}
+
+	if (ifp->if_capenable & IFCAP_VLAN_HWFILTER) {
+		if (vtnet_exec_vlan_filter(sc, add, tag) != 0) {
+			device_printf(sc->vtnet_dev,
+			    "cannot %s VLAN %d %s the host filter table\n",
+			    add ? "add" : "remove", tag,
+			    add ? "to" : "from");
+		}
+	}
+
+	VTNET_UNLOCK(sc);
+}
+
+static void
+vtnet_register_vlan(void *arg, struct ifnet *ifp, uint16_t tag)
+{
+
+	if (ifp->if_softc != arg)
+		return;
+
+	vtnet_set_vlan_filter(arg, 1, tag);
+}
+
+static void
+vtnet_unregister_vlan(void *arg, struct ifnet *ifp, uint16_t tag)
+{
+
+	if (ifp->if_softc != arg)
+		return;
+
+	vtnet_set_vlan_filter(arg, 0, tag);
+}
+
+static int
+vtnet_ifmedia_upd(struct ifnet *ifp)
+{
+	struct vtnet_softc *sc;
+	struct ifmedia *ifm;
+
+	sc = ifp->if_softc;
+	ifm = &sc->vtnet_media;
+
+	if (IFM_TYPE(ifm->ifm_media) != IFM_ETHER)
+		return (EINVAL);
+
+	return (0);
+}
+
+static void
+vtnet_ifmedia_sts(struct ifnet *ifp, struct ifmediareq *ifmr)
+{
+	struct vtnet_softc *sc;
+
+	sc = ifp->if_softc;
+
+	ifmr->ifm_status = IFM_AVALID;
+	ifmr->ifm_active = IFM_ETHER;
+
+	VTNET_LOCK(sc);
+	if (vtnet_is_link_up(sc) != 0) {
+		ifmr->ifm_status |= IFM_ACTIVE;
+		ifmr->ifm_active |= VTNET_MEDIATYPE;
+	} else
+		ifmr->ifm_active |= IFM_NONE;
+	VTNET_UNLOCK(sc);
+}
+
+static void
+vtnet_add_statistics(struct vtnet_softc *sc)
+{
+	device_t dev;
+	struct vtnet_statistics *stats;
+        struct sysctl_ctx_list *ctx;
+	struct sysctl_oid *tree;
+	struct sysctl_oid_list *child;
+
+	dev = sc->vtnet_dev;
+	stats = &sc->vtnet_stats;
+	ctx = device_get_sysctl_ctx(dev);
+	tree = device_get_sysctl_tree(dev);
+	child = SYSCTL_CHILDREN(tree);
+
+	SYSCTL_ADD_ULONG(ctx, child, OID_AUTO, "mbuf_alloc_failed",
+	    CTLFLAG_RD, &stats->mbuf_alloc_failed,
+	    "Mbuf cluster allocation failures");
+
+	SYSCTL_ADD_ULONG(ctx, child, OID_AUTO, "rx_frame_too_large",
+	    CTLFLAG_RD, &stats->rx_frame_too_large,
+	    "Received frame larger than the mbuf chain");
+	SYSCTL_ADD_ULONG(ctx, child, OID_AUTO, "rx_enq_replacement_failed",
+	    CTLFLAG_RD, &stats->rx_enq_replacement_failed,
+	    "Enqueuing the replacement receive mbuf failed");
+	SYSCTL_ADD_ULONG(ctx, child, OID_AUTO, "rx_mergeable_failed",
+	    CTLFLAG_RD, &stats->rx_mergeable_failed,
+	    "Mergeable buffers receive failures");
+	SYSCTL_ADD_ULONG(ctx, child, OID_AUTO, "rx_csum_bad_ethtype",
+	    CTLFLAG_RD, &stats->rx_csum_bad_ethtype,
+	    "Received checksum offloaded buffer with unsupported "
+	    "Ethernet type");
+	SYSCTL_ADD_ULONG(ctx, child, OID_AUTO, "rx_csum_bad_start",
+	    CTLFLAG_RD, &stats->rx_csum_bad_start,
+	    "Received checksum offloaded buffer with incorrect start offset");
+	SYSCTL_ADD_ULONG(ctx, child, OID_AUTO, "rx_csum_bad_ipproto",
+	    CTLFLAG_RD, &stats->rx_csum_bad_ipproto,
+	    "Received checksum offloaded buffer with incorrect IP protocol");
+	SYSCTL_ADD_ULONG(ctx, child, OID_AUTO, "rx_csum_bad_offset",
+	    CTLFLAG_RD, &stats->rx_csum_bad_offset,
+	    "Received checksum offloaded buffer with incorrect offset");
+	SYSCTL_ADD_ULONG(ctx, child, OID_AUTO, "rx_csum_failed",
+	    CTLFLAG_RD, &stats->rx_csum_failed,
+	    "Received buffer checksum offload failed");
+	SYSCTL_ADD_ULONG(ctx, child, OID_AUTO, "rx_csum_offloaded",
+	    CTLFLAG_RD, &stats->rx_csum_offloaded,
+	    "Received buffer checksum offload succeeded");
+	SYSCTL_ADD_ULONG(ctx, child, OID_AUTO, "rx_task_rescheduled",
+	    CTLFLAG_RD, &stats->rx_task_rescheduled,
+	    "Times the receive interrupt task rescheduled itself");
+
+	SYSCTL_ADD_ULONG(ctx, child, OID_AUTO, "tx_csum_offloaded",
+	    CTLFLAG_RD, &stats->tx_csum_offloaded,
+	    "Offloaded checksum of transmitted buffer");
+	SYSCTL_ADD_ULONG(ctx, child, OID_AUTO, "tx_tso_offloaded",
+	    CTLFLAG_RD, &stats->tx_tso_offloaded,
+	    "Segmentation offload of transmitted buffer");
+	SYSCTL_ADD_ULONG(ctx, child, OID_AUTO, "tx_csum_bad_ethtype",
+	    CTLFLAG_RD, &stats->tx_csum_bad_ethtype,
+	    "Aborted transmit of checksum offloaded buffer with unknown "
+	    "Ethernet type");
+	SYSCTL_ADD_ULONG(ctx, child, OID_AUTO, "tx_tso_bad_ethtype",
+	    CTLFLAG_RD, &stats->tx_tso_bad_ethtype,
+	    "Aborted transmit of TSO buffer with unknown Ethernet type");
+	SYSCTL_ADD_ULONG(ctx, child, OID_AUTO, "tx_task_rescheduled",
+	    CTLFLAG_RD, &stats->tx_task_rescheduled,
+	    "Times the transmit interrupt task rescheduled itself");
+}
+
+static int
+vtnet_enable_rx_intr(struct vtnet_softc *sc)
+{
+
+	return (virtqueue_enable_intr(sc->vtnet_rx_vq));
+}
+
+static void
+vtnet_disable_rx_intr(struct vtnet_softc *sc)
+{
+
+	virtqueue_disable_intr(sc->vtnet_rx_vq);
+}
+
+static int
+vtnet_enable_tx_intr(struct vtnet_softc *sc)
+{
+
+#ifdef VTNET_TX_INTR_MODERATION
+	return (0);
+#else
+	return (virtqueue_enable_intr(sc->vtnet_tx_vq));
+#endif
+}
+
+static void
+vtnet_disable_tx_intr(struct vtnet_softc *sc)
+{
+
+	virtqueue_disable_intr(sc->vtnet_tx_vq);
+}
diff --git a/sys/dev/virtio/network/if_vtnetvar.h b/sys/dev/virtio/network/if_vtnetvar.h
new file mode 100644
index 0000000..184870e
--- /dev/null
+++ b/sys/dev/virtio/network/if_vtnetvar.h
@@ -0,0 +1,241 @@
+/*-
+ * Copyright (c) 2011, Bryan Venteicher <bryanv@daemoninthecloset.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice unmodified, this list of conditions, and the following
+ *    disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+
+#ifndef _IF_VTNETVAR_H
+#define _IF_VTNETVAR_H
+
+struct vtnet_statistics {
+	unsigned long	mbuf_alloc_failed;
+
+	unsigned long	rx_frame_too_large;
+	unsigned long	rx_enq_replacement_failed;
+	unsigned long	rx_mergeable_failed;
+	unsigned long	rx_csum_bad_ethtype;
+	unsigned long	rx_csum_bad_start;
+	unsigned long	rx_csum_bad_ipproto;
+	unsigned long	rx_csum_bad_offset;
+	unsigned long	rx_csum_failed;
+	unsigned long	rx_csum_offloaded;
+	unsigned long	rx_task_rescheduled;
+
+	unsigned long	tx_csum_offloaded;
+	unsigned long	tx_tso_offloaded;
+	unsigned long	tx_csum_bad_ethtype;
+	unsigned long	tx_tso_bad_ethtype;
+	unsigned long	tx_task_rescheduled;
+};
+
+struct vtnet_softc {
+	device_t		 vtnet_dev;
+	struct ifnet		*vtnet_ifp;
+	struct mtx		 vtnet_mtx;
+
+	uint32_t		 vtnet_flags;
+#define VTNET_FLAG_LINK		 0x0001
+#define VTNET_FLAG_SUSPENDED	 0x0002
+#define VTNET_FLAG_CTRL_VQ	 0x0004
+#define VTNET_FLAG_CTRL_RX	 0x0008
+#define VTNET_FLAG_VLAN_FILTER	 0x0010
+#define VTNET_FLAG_TSO_ECN	 0x0020
+#define VTNET_FLAG_MRG_RXBUFS	 0x0040
+#define VTNET_FLAG_LRO_NOMRG	 0x0080
+
+	struct virtqueue	*vtnet_rx_vq;
+	struct virtqueue	*vtnet_tx_vq;
+	struct virtqueue	*vtnet_ctrl_vq;
+
+	int			 vtnet_hdr_size;
+	int			 vtnet_tx_size;
+	int			 vtnet_rx_size;
+	int			 vtnet_rx_process_limit;
+	int			 vtnet_rx_mbuf_size;
+	int			 vtnet_rx_mbuf_count;
+	int			 vtnet_if_flags;
+	int			 vtnet_watchdog_timer;
+	uint64_t		 vtnet_features;
+
+	struct taskqueue	*vtnet_tq;
+	struct task		 vtnet_rx_intr_task;
+	struct task		 vtnet_tx_intr_task;
+	struct task		 vtnet_cfgchg_task;
+
+	struct vtnet_statistics	 vtnet_stats;
+
+	struct callout		 vtnet_tick_ch;
+
+	eventhandler_tag	 vtnet_vlan_attach;
+	eventhandler_tag	 vtnet_vlan_detach;
+
+	struct ifmedia		 vtnet_media;
+	/*
+	 * Fake media type; the host does not provide us with
+	 * any real media information.
+	 */
+#define VTNET_MEDIATYPE		 (IFM_ETHER | IFM_1000_T | IFM_FDX)
+	char			 vtnet_hwaddr[ETHER_ADDR_LEN];
+
+	struct vtnet_mac_filter	*vtnet_mac_filter;
+	/*
+	 * During reset, the host's VLAN filtering table is lost. The
+	 * array below is used to restore all the VLANs configured on
+	 * this interface after a reset.
+	 */
+#define VTNET_VLAN_SHADOW_SIZE	 (4096 / 32)
+	int			 vtnet_nvlans;
+	uint32_t		 vtnet_vlan_shadow[VTNET_VLAN_SHADOW_SIZE];
+
+	char			 vtnet_mtx_name[16];
+};
+
+/*
+ * When mergeable buffers are not negotiated, the vtnet_rx_header structure
+ * below is placed at the beginning of the mbuf data. Use 4 bytes of pad to
+ * both keep the VirtIO header and the data non-contiguous and to keep the
+ * frame's payload 4 byte aligned.
+ *
+ * When mergeable buffers are negotiated, the host puts the VirtIO header in
+ * the beginning of the first mbuf's data.
+ */
+#define VTNET_RX_HEADER_PAD	4
+struct vtnet_rx_header {
+	struct virtio_net_hdr	vrh_hdr;
+	char			vrh_pad[VTNET_RX_HEADER_PAD];
+} __packed;
+
+/*
+ * For each outgoing frame, the vtnet_tx_header below is allocated from
+ * the vtnet_tx_header_zone.
+ */
+struct vtnet_tx_header {
+	union {
+		struct virtio_net_hdr		hdr;
+		struct virtio_net_hdr_mrg_rxbuf	mhdr;
+	} vth_uhdr;
+
+	struct mbuf *vth_mbuf;
+};
+
+/*
+ * The VirtIO specification does not place a limit on the number of MAC
+ * addresses the guest driver may request to be filtered. In practice,
+ * the host is constrained by available resources. To simplify this driver,
+ * impose a reasonably high limit of MAC addresses we will filter before
+ * falling back to promiscuous or all-multicast modes.
+ */
+#define VTNET_MAX_MAC_ENTRIES	128
+
+struct vtnet_mac_table {
+	uint32_t	nentries;
+	uint8_t		macs[VTNET_MAX_MAC_ENTRIES][ETHER_ADDR_LEN];
+} __packed;
+
+struct vtnet_mac_filter {
+	struct vtnet_mac_table	vmf_unicast;
+	uint32_t		vmf_pad; /* Make tables non-contiguous. */
+	struct vtnet_mac_table	vmf_multicast;
+};
+
+/*
+ * The MAC filter table is malloc(9)'d when needed. Ensure it will
+ * always fit in one segment.
+ */
+CTASSERT(sizeof(struct vtnet_mac_filter) <= PAGE_SIZE);
+
+#define VTNET_WATCHDOG_TIMEOUT	5
+#define VTNET_CSUM_OFFLOAD	(CSUM_TCP | CSUM_UDP | CSUM_SCTP)
+
+/* Features desired/implemented by this driver. */
+#define VTNET_FEATURES \
+    (VIRTIO_NET_F_MAC			| \
+     VIRTIO_NET_F_STATUS		| \
+     VIRTIO_NET_F_CTRL_VQ		| \
+     VIRTIO_NET_F_CTRL_RX		| \
+     VIRTIO_NET_F_CTRL_VLAN		| \
+     VIRTIO_NET_F_CSUM			| \
+     VIRTIO_NET_F_HOST_TSO4		| \
+     VIRTIO_NET_F_HOST_TSO6		| \
+     VIRTIO_NET_F_HOST_ECN		| \
+     VIRTIO_NET_F_GUEST_CSUM		| \
+     VIRTIO_NET_F_GUEST_TSO4		| \
+     VIRTIO_NET_F_GUEST_TSO6		| \
+     VIRTIO_NET_F_GUEST_ECN		| \
+     VIRTIO_NET_F_MRG_RXBUF		| \
+     VIRTIO_RING_F_INDIRECT_DESC)
+
+/*
+ * The VIRTIO_NET_F_GUEST_TSO[46] features permit the host to send us
+ * frames larger than 1514 bytes. We do not yet support software LRO
+ * via tcp_lro_rx().
+ */
+#define VTNET_LRO_FEATURES (VIRTIO_NET_F_GUEST_TSO4 | \
+    VIRTIO_NET_F_GUEST_TSO6 | VIRTIO_NET_F_GUEST_ECN)
+
+#define VTNET_MAX_MTU		65536
+#define VTNET_MAX_RX_SIZE	65550
+
+/*
+ * Used to preallocate the Vq indirect descriptors. The first segment
+ * is reserved for the header.
+ */
+#define VTNET_MIN_RX_SEGS	2
+#define VTNET_MAX_RX_SEGS	34
+#define VTNET_MAX_TX_SEGS	34
+
+/*
+ * Assert we can receive and transmit the maximum with regular
+ * size clusters.
+ */
+CTASSERT(((VTNET_MAX_RX_SEGS - 1) * MCLBYTES) >= VTNET_MAX_RX_SIZE);
+CTASSERT(((VTNET_MAX_TX_SEGS - 1) * MCLBYTES) >= VTNET_MAX_MTU);
+
+/*
+ * Determine how many mbufs are in each receive buffer. For LRO without
+ * mergeable descriptors, we must allocate an mbuf chain large enough to
+ * hold both the vtnet_rx_header and the maximum receivable data.
+ */
+#define VTNET_NEEDED_RX_MBUFS(_sc)					\
+	((_sc)->vtnet_flags & VTNET_FLAG_LRO_NOMRG) == 0 ? 1 :		\
+	    howmany(sizeof(struct vtnet_rx_header) + VTNET_MAX_RX_SIZE,	\
+	        (_sc)->vtnet_rx_mbuf_size)
+
+#define VTNET_MTX(_sc)		&(_sc)->vtnet_mtx
+#define VTNET_LOCK(_sc)		mtx_lock(VTNET_MTX((_sc)))
+#define VTNET_UNLOCK(_sc)	mtx_unlock(VTNET_MTX((_sc)))
+#define VTNET_LOCK_DESTROY(_sc)	mtx_destroy(VTNET_MTX((_sc)))
+#define VTNET_LOCK_ASSERT(_sc)	mtx_assert(VTNET_MTX((_sc)), MA_OWNED)
+#define VTNET_LOCK_ASSERT_NOTOWNED(_sc)	\
+	 			mtx_assert(VTNET_MTX((_sc)), MA_NOTOWNED)
+
+#define VTNET_LOCK_INIT(_sc) do {					\
+    snprintf((_sc)->vtnet_mtx_name, sizeof((_sc)->vtnet_mtx_name),	\
+        "%s", device_get_nameunit((_sc)->vtnet_dev));			\
+    mtx_init(VTNET_MTX((_sc)), (_sc)->vtnet_mtx_name,			\
+        "VTNET Core Lock", MTX_DEF);					\
+} while (0)
+
+#endif /* _IF_VTNETVAR_H */
diff --git a/sys/dev/virtio/network/virtio_net.h b/sys/dev/virtio/network/virtio_net.h
new file mode 100644
index 0000000..15a73cc
--- /dev/null
+++ b/sys/dev/virtio/network/virtio_net.h
@@ -0,0 +1,159 @@
+/*-
+ * This header is BSD licensed so anyone can use the definitions to implement
+ * compatible drivers/servers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of IBM nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL IBM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+
+#ifndef _VIRTIO_NET_H
+#define _VIRTIO_NET_H
+
+/* The feature bitmap for virtio net */
+#define VIRTIO_NET_F_CSUM	0x00001 /* Host handles pkts w/ partial csum */
+#define VIRTIO_NET_F_GUEST_CSUM 0x00002 /* Guest handles pkts w/ partial csum*/
+#define VIRTIO_NET_F_MAC	0x00020 /* Host has given MAC address. */
+#define VIRTIO_NET_F_GSO	0x00040 /* Host handles pkts w/ any GSO type */
+#define VIRTIO_NET_F_GUEST_TSO4	0x00080 /* Guest can handle TSOv4 in. */
+#define VIRTIO_NET_F_GUEST_TSO6	0x00100 /* Guest can handle TSOv6 in. */
+#define VIRTIO_NET_F_GUEST_ECN	0x00200 /* Guest can handle TSO[6] w/ ECN in.*/
+#define VIRTIO_NET_F_GUEST_UFO	0x00400 /* Guest can handle UFO in. */
+#define VIRTIO_NET_F_HOST_TSO4	0x00800 /* Host can handle TSOv4 in. */
+#define VIRTIO_NET_F_HOST_TSO6	0x01000 /* Host can handle TSOv6 in. */
+#define VIRTIO_NET_F_HOST_ECN	0x02000 /* Host can handle TSO[6] w/ ECN in. */
+#define VIRTIO_NET_F_HOST_UFO	0x04000 /* Host can handle UFO in. */
+#define VIRTIO_NET_F_MRG_RXBUF	0x08000 /* Host can merge receive buffers. */
+#define VIRTIO_NET_F_STATUS	0x10000 /* virtio_net_config.status available*/
+#define VIRTIO_NET_F_CTRL_VQ	0x20000 /* Control channel available */
+#define VIRTIO_NET_F_CTRL_RX	0x40000 /* Control channel RX mode support */
+#define VIRTIO_NET_F_CTRL_VLAN	0x80000 /* Control channel VLAN filtering */
+#define VIRTIO_NET_F_CTRL_RX_EXTRA 0x100000 /* Extra RX mode control support */
+
+#define VIRTIO_NET_S_LINK_UP	1	/* Link is up */
+
+struct virtio_net_config {
+	/* The config defining mac address (if VIRTIO_NET_F_MAC) */
+	uint8_t		mac[ETHER_ADDR_LEN]; 
+	/* See VIRTIO_NET_F_STATUS and VIRTIO_NET_S_* above */
+	uint16_t	status;
+} __packed;
+
+/*
+ * This is the first element of the scatter-gather list.  If you don't
+ * specify GSO or CSUM features, you can simply ignore the header.
+ */
+struct virtio_net_hdr {
+#define VIRTIO_NET_HDR_F_NEEDS_CSUM	1	/* Use csum_start,csum_offset*/
+	uint8_t	flags;
+#define VIRTIO_NET_HDR_GSO_NONE		0	/* Not a GSO frame */
+#define VIRTIO_NET_HDR_GSO_TCPV4	1	/* GSO frame, IPv4 TCP (TSO) */
+#define VIRTIO_NET_HDR_GSO_UDP		3	/* GSO frame, IPv4 UDP (UFO) */
+#define VIRTIO_NET_HDR_GSO_TCPV6	4	/* GSO frame, IPv6 TCP */
+#define VIRTIO_NET_HDR_GSO_ECN		0x80	/* TCP has ECN set */
+	uint8_t gso_type;
+	uint16_t hdr_len;	/* Ethernet + IP + tcp/udp hdrs */
+	uint16_t gso_size;	/* Bytes to append to hdr_len per frame */
+	uint16_t csum_start;	/* Position to start checksumming from */
+	uint16_t csum_offset;	/* Offset after that to place checksum */
+};
+
+/*
+ * This is the version of the header to use when the MRG_RXBUF
+ * feature has been negotiated.
+ */
+struct virtio_net_hdr_mrg_rxbuf {
+	struct virtio_net_hdr hdr;
+	uint16_t num_buffers;	/* Number of merged rx buffers */
+};
+
+/*
+ * Control virtqueue data structures
+ *
+ * The control virtqueue expects a header in the first sg entry
+ * and an ack/status response in the last entry.  Data for the
+ * command goes in between.
+ */
+struct virtio_net_ctrl_hdr {
+	uint8_t class;
+	uint8_t cmd;
+} __packed;
+
+typedef uint8_t virtio_net_ctrl_ack;
+
+#define VIRTIO_NET_OK	0
+#define VIRTIO_NET_ERR	1
+
+/*
+ * Control the RX mode, ie. promiscuous, allmulti, etc...
+ * All commands require an "out" sg entry containing a 1 byte
+ * state value, zero = disable, non-zero = enable.  Commands
+ * 0 and 1 are supported with the VIRTIO_NET_F_CTRL_RX feature.
+ * Commands 2-5 are added with VIRTIO_NET_F_CTRL_RX_EXTRA.
+ */
+#define VIRTIO_NET_CTRL_RX	0
+#define VIRTIO_NET_CTRL_RX_PROMISC	0
+#define VIRTIO_NET_CTRL_RX_ALLMULTI	1
+#define VIRTIO_NET_CTRL_RX_ALLUNI	2
+#define VIRTIO_NET_CTRL_RX_NOMULTI	3
+#define VIRTIO_NET_CTRL_RX_NOUNI	4
+#define VIRTIO_NET_CTRL_RX_NOBCAST	5
+
+/*
+ * Control the MAC filter table.
+ *
+ * The MAC filter table is managed by the hypervisor, the guest should
+ * assume the size is infinite.  Filtering should be considered
+ * non-perfect, ie. based on hypervisor resources, the guest may
+ * received packets from sources not specified in the filter list.
+ *
+ * In addition to the class/cmd header, the TABLE_SET command requires
+ * two out scatterlists.  Each contains a 4 byte count of entries followed
+ * by a concatenated byte stream of the ETH_ALEN MAC addresses.  The
+ * first sg list contains unicast addresses, the second is for multicast.
+ * This functionality is present if the VIRTIO_NET_F_CTRL_RX feature
+ * is available.
+ */
+struct virtio_net_ctrl_mac {
+	uint32_t	entries;
+	uint8_t		macs[][ETHER_ADDR_LEN];
+} __packed;
+
+#define VIRTIO_NET_CTRL_MAC	1
+#define VIRTIO_NET_CTRL_MAC_TABLE_SET	0
+
+/*
+ * Control VLAN filtering
+ *
+ * The VLAN filter table is controlled via a simple ADD/DEL interface.
+ * VLAN IDs not added may be filtered by the hypervisor.  Del is the
+ * opposite of add.  Both commands expect an out entry containing a 2
+ * byte VLAN ID.  VLAN filtering is available with the
+ * VIRTIO_NET_F_CTRL_VLAN feature bit.
+ */
+#define VIRTIO_NET_CTRL_VLAN	2
+#define VIRTIO_NET_CTRL_VLAN_ADD	0
+#define VIRTIO_NET_CTRL_VLAN_DEL	1
+
+#endif /* _VIRTIO_NET_H */
diff --git a/sys/dev/virtio/pci/virtio_pci.c b/sys/dev/virtio/pci/virtio_pci.c
new file mode 100644
index 0000000..0f9ffc7
--- /dev/null
+++ b/sys/dev/virtio/pci/virtio_pci.c
@@ -0,0 +1,1262 @@
+/*-
+ * Copyright (c) 2011, Bryan Venteicher <bryanv@daemoninthecloset.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice unmodified, this list of conditions, and the following
+ *    disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* Driver for the VirtIO PCI interface. */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/bus.h>
+#include <sys/kernel.h>
+#include <sys/module.h>
+#include <sys/malloc.h>
+
+#include <machine/bus.h>
+#include <machine/resource.h>
+#include <sys/bus.h>
+#include <sys/rman.h>
+
+#include <dev/pci/pcivar.h>
+#include <dev/pci/pcireg.h>
+
+#include <dev/virtio/virtio.h>
+#include <dev/virtio/virtqueue.h>
+#include <dev/virtio/pci/virtio_pci.h>
+
+#include "virtio_bus_if.h"
+#include "virtio_if.h"
+
+struct vtpci_softc {
+	device_t			 vtpci_dev;
+	struct resource			*vtpci_res;
+	struct resource			*vtpci_msix_res;
+	uint64_t			 vtpci_features;
+	uint32_t			 vtpci_flags;
+#define VTPCI_FLAG_NO_MSI		0x0001
+#define VTPCI_FLAG_NO_MSIX		0x0002
+#define VTPCI_FLAG_LEGACY		0x1000
+#define VTPCI_FLAG_MSI			0x2000
+#define VTPCI_FLAG_MSIX			0x4000
+#define VTPCI_FLAG_SHARED_MSIX		0x8000
+#define VTPCI_FLAG_ITYPE_MASK		0xF000
+
+	/* This "bus" will only ever have one child. */
+	device_t			 vtpci_child_dev;
+	struct virtio_feature_desc	*vtpci_child_feat_desc;
+
+	/*
+	 * Ideally, each virtqueue that the driver provides a callback for
+	 * will receive its own MSIX vector. If there are not sufficient
+	 * vectors available, we will then attempt to have all the VQs
+	 * share one vector. Note that when using MSIX, the configuration
+	 * changed notifications must be on their own vector.
+	 *
+	 * If MSIX is not available, we will attempt to have the whole
+	 * device share one MSI vector, and then, finally, one legacy
+	 * interrupt.
+	 */
+	int				 vtpci_nvqs;
+	struct vtpci_virtqueue {
+		struct virtqueue *vq;
+		/* Device did not provide a callback for this virtqueue. */
+		int		  no_intr;
+		/* Index into vtpci_intr_res[] below. Unused, then -1. */
+		int		  ires_idx;
+	} vtpci_vqx[VIRTIO_MAX_VIRTQUEUES];
+
+	/*
+	 * When using MSIX interrupts, the first element of vtpci_intr_res[]
+	 * is always the configuration changed notifications. The remaining
+	 * element(s) are used for the virtqueues.
+	 *
+	 * With MSI and legacy interrupts, only the first element of
+	 * vtpci_intr_res[] is used.
+	 */
+	int				 vtpci_nintr_res;
+	struct vtpci_intr_resource {
+		struct resource	*irq;
+		int		 rid;
+		void		*intrhand;
+	} vtpci_intr_res[1 + VIRTIO_MAX_VIRTQUEUES];
+};
+
+static int	vtpci_probe(device_t);
+static int	vtpci_attach(device_t);
+static int	vtpci_detach(device_t);
+static int	vtpci_suspend(device_t);
+static int	vtpci_resume(device_t);
+static int	vtpci_shutdown(device_t);
+static void	vtpci_driver_added(device_t, driver_t *);
+static void	vtpci_child_detached(device_t, device_t);
+static int	vtpci_read_ivar(device_t, device_t, int, uintptr_t *);
+static int	vtpci_write_ivar(device_t, device_t, int, uintptr_t);
+
+static uint64_t	vtpci_negotiate_features(device_t, uint64_t);
+static int	vtpci_with_feature(device_t, uint64_t);
+static int	vtpci_alloc_virtqueues(device_t, int, int,
+		    struct vq_alloc_info *);
+static int	vtpci_setup_intr(device_t, enum intr_type);
+static void	vtpci_stop(device_t);
+static int	vtpci_reinit(device_t, uint64_t);
+static void	vtpci_reinit_complete(device_t);
+static void	vtpci_notify_virtqueue(device_t, uint16_t);
+static uint8_t	vtpci_get_status(device_t);
+static void	vtpci_set_status(device_t, uint8_t);
+static void	vtpci_read_dev_config(device_t, bus_size_t, void *, int);
+static void	vtpci_write_dev_config(device_t, bus_size_t, void *, int);
+
+static void	vtpci_describe_features(struct vtpci_softc *, const char *,
+		    uint64_t);
+static void	vtpci_probe_and_attach_child(struct vtpci_softc *);
+
+static int 	vtpci_alloc_msix(struct vtpci_softc *, int);
+static int 	vtpci_alloc_msi(struct vtpci_softc *);
+static int 	vtpci_alloc_intr_msix_pervq(struct vtpci_softc *);
+static int 	vtpci_alloc_intr_msix_shared(struct vtpci_softc *);
+static int 	vtpci_alloc_intr_msi(struct vtpci_softc *);
+static int 	vtpci_alloc_intr_legacy(struct vtpci_softc *);
+static int	vtpci_alloc_intr_resources(struct vtpci_softc *);
+
+static int 	vtpci_setup_legacy_interrupt(struct vtpci_softc *,
+		    enum intr_type);
+static int 	vtpci_setup_msix_interrupts(struct vtpci_softc *,
+		    enum intr_type);
+static int 	vtpci_setup_interrupts(struct vtpci_softc *, enum intr_type);
+
+static int	vtpci_register_msix_vector(struct vtpci_softc *, int, int);
+static int 	vtpci_set_host_msix_vectors(struct vtpci_softc *);
+static int 	vtpci_reinit_virtqueue(struct vtpci_softc *, int);
+
+static void	vtpci_free_interrupts(struct vtpci_softc *);
+static void	vtpci_free_virtqueues(struct vtpci_softc *);
+static void 	vtpci_cleanup_setup_intr_attempt(struct vtpci_softc *);
+static void	vtpci_release_child_resources(struct vtpci_softc *);
+static void	vtpci_reset(struct vtpci_softc *);
+
+static void	vtpci_select_virtqueue(struct vtpci_softc *, int);
+
+static int	vtpci_legacy_intr(void *);
+static int	vtpci_vq_shared_intr(void *);
+static int	vtpci_vq_intr(void *);
+static int	vtpci_config_intr(void *);
+
+#define vtpci_setup_msi_interrupt vtpci_setup_legacy_interrupt
+
+/*
+ * I/O port read/write wrappers.
+ */
+#define vtpci_read_config_1(sc, o)	bus_read_1((sc)->vtpci_res, (o))
+#define vtpci_read_config_2(sc, o)	bus_read_2((sc)->vtpci_res, (o))
+#define vtpci_read_config_4(sc, o)	bus_read_4((sc)->vtpci_res, (o))
+#define vtpci_write_config_1(sc, o, v)	bus_write_1((sc)->vtpci_res, (o), (v))
+#define vtpci_write_config_2(sc, o, v)	bus_write_2((sc)->vtpci_res, (o), (v))
+#define vtpci_write_config_4(sc, o, v)	bus_write_4((sc)->vtpci_res, (o), (v))
+
+/* Tunables. */
+static int vtpci_disable_msix = 0;
+TUNABLE_INT("hw.virtio.pci.disable_msix", &vtpci_disable_msix);
+
+static device_method_t vtpci_methods[] = {
+	/* Device interface. */
+	DEVMETHOD(device_probe,			  vtpci_probe),
+	DEVMETHOD(device_attach,		  vtpci_attach),
+	DEVMETHOD(device_detach,		  vtpci_detach),
+	DEVMETHOD(device_suspend,		  vtpci_suspend),
+	DEVMETHOD(device_resume,		  vtpci_resume),
+	DEVMETHOD(device_shutdown,		  vtpci_shutdown),
+
+	/* Bus interface. */
+	DEVMETHOD(bus_driver_added,		  vtpci_driver_added),
+	DEVMETHOD(bus_child_detached,		  vtpci_child_detached),
+	DEVMETHOD(bus_read_ivar,		  vtpci_read_ivar),
+	DEVMETHOD(bus_write_ivar,		  vtpci_write_ivar),
+
+	/* VirtIO bus interface. */
+	DEVMETHOD(virtio_bus_negotiate_features,  vtpci_negotiate_features),
+	DEVMETHOD(virtio_bus_with_feature,	  vtpci_with_feature),
+	DEVMETHOD(virtio_bus_alloc_virtqueues,	  vtpci_alloc_virtqueues),
+	DEVMETHOD(virtio_bus_setup_intr,	  vtpci_setup_intr),
+	DEVMETHOD(virtio_bus_stop,		  vtpci_stop),
+	DEVMETHOD(virtio_bus_reinit,		  vtpci_reinit),
+	DEVMETHOD(virtio_bus_reinit_complete,	  vtpci_reinit_complete),
+	DEVMETHOD(virtio_bus_notify_vq,		  vtpci_notify_virtqueue),
+	DEVMETHOD(virtio_bus_read_device_config,  vtpci_read_dev_config),
+	DEVMETHOD(virtio_bus_write_device_config, vtpci_write_dev_config),
+
+	DEVMETHOD_END
+};
+
+static driver_t vtpci_driver = {
+	"virtio_pci",
+	vtpci_methods,
+	sizeof(struct vtpci_softc)
+};
+
+devclass_t vtpci_devclass;
+
+DRIVER_MODULE(virtio_pci, pci, vtpci_driver, vtpci_devclass, 0, 0);
+MODULE_VERSION(virtio_pci, 1);
+MODULE_DEPEND(virtio_pci, pci, 1, 1, 1);
+MODULE_DEPEND(virtio_pci, virtio, 1, 1, 1);
+
+static int
+vtpci_probe(device_t dev)
+{
+	char desc[36];
+	const char *name;
+
+	if (pci_get_vendor(dev) != VIRTIO_PCI_VENDORID)
+		return (ENXIO);
+
+	if (pci_get_device(dev) < VIRTIO_PCI_DEVICEID_MIN ||
+	    pci_get_device(dev) > VIRTIO_PCI_DEVICEID_MAX)
+		return (ENXIO);
+
+	if (pci_get_revid(dev) != VIRTIO_PCI_ABI_VERSION)
+		return (ENXIO);
+
+	name = virtio_device_name(pci_get_subdevice(dev));
+	if (name == NULL)
+		name = "Unknown";
+
+	snprintf(desc, sizeof(desc), "VirtIO PCI %s adapter", name);
+	device_set_desc_copy(dev, desc);
+
+	return (BUS_PROBE_DEFAULT);
+}
+
+static int
+vtpci_attach(device_t dev)
+{
+	struct vtpci_softc *sc;
+	device_t child;
+	int rid;
+
+	sc = device_get_softc(dev);
+	sc->vtpci_dev = dev;
+
+	pci_enable_busmaster(dev);
+
+	rid = PCIR_BAR(0);
+	sc->vtpci_res = bus_alloc_resource_any(dev, SYS_RES_IOPORT, &rid,
+	    RF_ACTIVE);
+	if (sc->vtpci_res == NULL) {
+		device_printf(dev, "cannot map I/O space\n");
+		return (ENXIO);
+	}
+
+	if (pci_find_extcap(dev, PCIY_MSI, NULL) != 0)
+		sc->vtpci_flags |= VTPCI_FLAG_NO_MSI;
+
+	if (pci_find_extcap(dev, PCIY_MSIX, NULL) == 0) {
+		rid = PCIR_BAR(1);
+		sc->vtpci_msix_res = bus_alloc_resource_any(dev,
+		    SYS_RES_MEMORY, &rid, RF_ACTIVE);
+	}
+
+	if (sc->vtpci_msix_res == NULL)
+		sc->vtpci_flags |= VTPCI_FLAG_NO_MSIX;
+
+	vtpci_reset(sc);
+
+	/* Tell the host we've noticed this device. */
+	vtpci_set_status(dev, VIRTIO_CONFIG_STATUS_ACK);
+
+	if ((child = device_add_child(dev, NULL, -1)) == NULL) {
+		device_printf(dev, "cannot create child device\n");
+		vtpci_set_status(dev, VIRTIO_CONFIG_STATUS_FAILED);
+		vtpci_detach(dev);
+		return (ENOMEM);
+	}
+
+	sc->vtpci_child_dev = child;
+	vtpci_probe_and_attach_child(sc);
+
+	return (0);
+}
+
+static int
+vtpci_detach(device_t dev)
+{
+	struct vtpci_softc *sc;
+	device_t child;
+	int error;
+
+	sc = device_get_softc(dev);
+
+	if ((child = sc->vtpci_child_dev) != NULL) {
+		error = device_delete_child(dev, child);
+		if (error)
+			return (error);
+		sc->vtpci_child_dev = NULL;
+	}
+
+	vtpci_reset(sc);
+
+	if (sc->vtpci_msix_res != NULL) {
+		bus_release_resource(dev, SYS_RES_MEMORY, PCIR_BAR(1),
+		    sc->vtpci_msix_res);
+		sc->vtpci_msix_res = NULL;
+	}
+
+	if (sc->vtpci_res != NULL) {
+		bus_release_resource(dev, SYS_RES_IOPORT, PCIR_BAR(0),
+		    sc->vtpci_res);
+		sc->vtpci_res = NULL;
+	}
+
+	return (0);
+}
+
+static int
+vtpci_suspend(device_t dev)
+{
+
+	return (bus_generic_suspend(dev));
+}
+
+static int
+vtpci_resume(device_t dev)
+{
+
+	return (bus_generic_resume(dev));
+}
+
+static int
+vtpci_shutdown(device_t dev)
+{
+
+	(void) bus_generic_shutdown(dev);
+	/* Forcibly stop the host device. */
+	vtpci_stop(dev);
+
+	return (0);
+}
+
+static void
+vtpci_driver_added(device_t dev, driver_t *driver)
+{
+	struct vtpci_softc *sc;
+
+	sc = device_get_softc(dev);
+
+	vtpci_probe_and_attach_child(sc);
+}
+
+static void
+vtpci_child_detached(device_t dev, device_t child)
+{
+	struct vtpci_softc *sc;
+
+	sc = device_get_softc(dev);
+
+	vtpci_reset(sc);
+	vtpci_release_child_resources(sc);
+}
+
+static int
+vtpci_read_ivar(device_t dev, device_t child, int index, uintptr_t *result)
+{
+	struct vtpci_softc *sc;
+
+	sc = device_get_softc(dev);
+
+	if (sc->vtpci_child_dev != child)
+		return (ENOENT);
+
+	switch (index) {
+	case VIRTIO_IVAR_DEVTYPE:
+	case VIRTIO_IVAR_SUBDEVICE:
+		*result = pci_get_subdevice(dev);
+		break;
+	case VIRTIO_IVAR_VENDOR:
+		*result = pci_get_vendor(dev);
+		break;
+	case VIRTIO_IVAR_DEVICE:
+		*result = pci_get_device(dev);
+		break;
+	case VIRTIO_IVAR_SUBVENDOR:
+		*result = pci_get_subdevice(dev);
+		break;
+	default:
+		return (ENOENT);
+	}
+
+	return (0);
+}
+
+static int
+vtpci_write_ivar(device_t dev, device_t child, int index, uintptr_t value)
+{
+	struct vtpci_softc *sc;
+
+	sc = device_get_softc(dev);
+
+	if (sc->vtpci_child_dev != child)
+		return (ENOENT);
+
+	switch (index) {
+	case VIRTIO_IVAR_FEATURE_DESC:
+		sc->vtpci_child_feat_desc = (void *) value;
+		break;
+	default:
+		return (ENOENT);
+	}
+
+	return (0);
+}
+
+static uint64_t
+vtpci_negotiate_features(device_t dev, uint64_t child_features)
+{
+	struct vtpci_softc *sc;
+	uint64_t host_features, features;
+
+	sc = device_get_softc(dev);
+
+	host_features = vtpci_read_config_4(sc, VIRTIO_PCI_HOST_FEATURES);
+	vtpci_describe_features(sc, "host", host_features);
+
+	/*
+	 * Limit negotiated features to what the driver, virtqueue, and
+	 * host all support.
+	 */
+	features = host_features & child_features;
+	features = virtqueue_filter_features(features);
+	sc->vtpci_features = features;
+
+	vtpci_describe_features(sc, "negotiated", features);
+	vtpci_write_config_4(sc, VIRTIO_PCI_GUEST_FEATURES, features);
+
+	return (features);
+}
+
+static int
+vtpci_with_feature(device_t dev, uint64_t feature)
+{
+	struct vtpci_softc *sc;
+
+	sc = device_get_softc(dev);
+
+	return ((sc->vtpci_features & feature) != 0);
+}
+
+static int
+vtpci_alloc_virtqueues(device_t dev, int flags, int nvqs,
+    struct vq_alloc_info *vq_info)
+{
+	struct vtpci_softc *sc;
+	struct virtqueue *vq;
+	struct vtpci_virtqueue *vqx;
+	struct vq_alloc_info *info;
+	int idx, error;
+	uint16_t size;
+
+	sc = device_get_softc(dev);
+	error = 0;
+
+	if (sc->vtpci_nvqs != 0)
+		return (EALREADY);
+	if (nvqs <= 0 || nvqs > VIRTIO_MAX_VIRTQUEUES)
+		return (EINVAL);
+
+	if (flags & VIRTIO_ALLOC_VQS_DISABLE_MSIX)
+		sc->vtpci_flags |= VTPCI_FLAG_NO_MSIX;
+
+	for (idx = 0; idx < nvqs; idx++) {
+		vqx = &sc->vtpci_vqx[idx];
+		info = &vq_info[idx];
+
+		vtpci_select_virtqueue(sc, idx);
+		size = vtpci_read_config_2(sc, VIRTIO_PCI_QUEUE_NUM);
+
+		error = virtqueue_alloc(dev, idx, size, VIRTIO_PCI_VRING_ALIGN,
+		    0xFFFFFFFFUL, info, &vq);
+		if (error) {
+			device_printf(dev,
+			    "cannot allocate virtqueue %d: %d\n", idx, error);
+			break;
+		}
+
+		vtpci_write_config_4(sc, VIRTIO_PCI_QUEUE_PFN,
+		    virtqueue_paddr(vq) >> VIRTIO_PCI_QUEUE_ADDR_SHIFT);
+
+		vqx->vq = *info->vqai_vq = vq;
+		vqx->no_intr = info->vqai_intr == NULL;
+
+		sc->vtpci_nvqs++;
+	}
+
+	return (error);
+}
+
+static int
+vtpci_setup_intr(device_t dev, enum intr_type type)
+{
+	struct vtpci_softc *sc;
+	int attempt, error;
+
+	sc = device_get_softc(dev);
+
+	for (attempt = 0; attempt < 5; attempt++) {
+		/*
+		 * Start with the most desirable interrupt configuration and
+		 * fallback towards less desirable ones.
+		 */
+		switch (attempt) {
+		case 0:
+			error = vtpci_alloc_intr_msix_pervq(sc);
+			break;
+		case 1:
+			error = vtpci_alloc_intr_msix_shared(sc);
+			break;
+		case 2:
+			error = vtpci_alloc_intr_msi(sc);
+			break;
+		case 3:
+			error = vtpci_alloc_intr_legacy(sc);
+			break;
+		default:
+			device_printf(dev,
+			    "exhausted all interrupt allocation attempts\n");
+			return (ENXIO);
+		}
+
+		if (error == 0 && vtpci_setup_interrupts(sc, type) == 0)
+			break;
+
+		vtpci_cleanup_setup_intr_attempt(sc);
+	}
+
+	if (bootverbose) {
+		if (sc->vtpci_flags & VTPCI_FLAG_LEGACY)
+			device_printf(dev, "using legacy interrupt\n");
+		else if (sc->vtpci_flags & VTPCI_FLAG_MSI)
+			device_printf(dev, "using MSI interrupt\n");
+		else if (sc->vtpci_flags & VTPCI_FLAG_SHARED_MSIX)
+			device_printf(dev, "using shared MSIX interrupts\n");
+		else
+			device_printf(dev, "using per VQ MSIX interrupts\n");
+	}
+
+	return (0);
+}
+
+static void
+vtpci_stop(device_t dev)
+{
+
+	vtpci_reset(device_get_softc(dev));
+}
+
+static int
+vtpci_reinit(device_t dev, uint64_t features)
+{
+	struct vtpci_softc *sc;
+	int idx, error;
+
+	sc = device_get_softc(dev);
+
+	/*
+	 * Redrive the device initialization. This is a bit of an abuse of
+	 * the specification, but VirtualBox, QEMU/KVM, and BHyVe seem to
+	 * play nice.
+	 *
+	 * We do not allow the host device to change from what was originally
+	 * negotiated beyond what the guest driver changed. MSIX state should
+	 * not change, number of virtqueues and their size remain the same, etc.
+	 * This will need to be rethought when we want to support migration.
+	 */
+
+	if (vtpci_get_status(dev) != VIRTIO_CONFIG_STATUS_RESET)
+		vtpci_stop(dev);
+
+	/*
+	 * Quickly drive the status through ACK and DRIVER. The device
+	 * does not become usable again until vtpci_reinit_complete().
+	 */
+	vtpci_set_status(dev, VIRTIO_CONFIG_STATUS_ACK);
+	vtpci_set_status(dev, VIRTIO_CONFIG_STATUS_DRIVER);
+
+	vtpci_negotiate_features(dev, features);
+
+	for (idx = 0; idx < sc->vtpci_nvqs; idx++) {
+		error = vtpci_reinit_virtqueue(sc, idx);
+		if (error)
+			return (error);
+	}
+
+	if (sc->vtpci_flags & VTPCI_FLAG_MSIX) {
+		error = vtpci_set_host_msix_vectors(sc);
+		if (error)
+			return (error);
+	}
+
+	return (0);
+}
+
+static void
+vtpci_reinit_complete(device_t dev)
+{
+
+	vtpci_set_status(dev, VIRTIO_CONFIG_STATUS_DRIVER_OK);
+}
+
+static void
+vtpci_notify_virtqueue(device_t dev, uint16_t queue)
+{
+	struct vtpci_softc *sc;
+
+	sc = device_get_softc(dev);
+
+	vtpci_write_config_2(sc, VIRTIO_PCI_QUEUE_NOTIFY, queue);
+}
+
+static uint8_t
+vtpci_get_status(device_t dev)
+{
+	struct vtpci_softc *sc;
+
+	sc = device_get_softc(dev);
+
+	return (vtpci_read_config_1(sc, VIRTIO_PCI_STATUS));
+}
+
+static void
+vtpci_set_status(device_t dev, uint8_t status)
+{
+	struct vtpci_softc *sc;
+
+	sc = device_get_softc(dev);
+
+	if (status != VIRTIO_CONFIG_STATUS_RESET)
+		status |= vtpci_get_status(dev);
+
+	vtpci_write_config_1(sc, VIRTIO_PCI_STATUS, status);
+}
+
+static void
+vtpci_read_dev_config(device_t dev, bus_size_t offset,
+    void *dst, int length)
+{
+	struct vtpci_softc *sc;
+	bus_size_t off;
+	uint8_t *d;
+	int size;
+
+	sc = device_get_softc(dev);
+	off = VIRTIO_PCI_CONFIG(sc) + offset;
+
+	for (d = dst; length > 0; d += size, off += size, length -= size) {
+		if (length >= 4) {
+			size = 4;
+			*(uint32_t *)d = vtpci_read_config_4(sc, off);
+		} else if (length >= 2) {
+			size = 2;
+			*(uint16_t *)d = vtpci_read_config_2(sc, off);
+		} else {
+			size = 1;
+			*d = vtpci_read_config_1(sc, off);
+		}
+	}
+}
+
+static void
+vtpci_write_dev_config(device_t dev, bus_size_t offset,
+    void *src, int length)
+{
+	struct vtpci_softc *sc;
+	bus_size_t off;
+	uint8_t *s;
+	int size;
+
+	sc = device_get_softc(dev);
+	off = VIRTIO_PCI_CONFIG(sc) + offset;
+
+	for (s = src; length > 0; s += size, off += size, length -= size) {
+		if (length >= 4) {
+			size = 4;
+			vtpci_write_config_4(sc, off, *(uint32_t *)s);
+		} else if (length >= 2) {
+			size = 2;
+			vtpci_write_config_2(sc, off, *(uint16_t *)s);
+		} else {
+			size = 1;
+			vtpci_write_config_1(sc, off, *s);
+		}
+	}
+}
+
+static void
+vtpci_describe_features(struct vtpci_softc *sc, const char *msg,
+    uint64_t features)
+{
+	device_t dev, child;
+
+	dev = sc->vtpci_dev;
+	child = sc->vtpci_child_dev;
+
+	if (device_is_attached(child) && bootverbose == 0)
+		return;
+
+	virtio_describe(dev, msg, features, sc->vtpci_child_feat_desc);
+}
+
+static void
+vtpci_probe_and_attach_child(struct vtpci_softc *sc)
+{
+	device_t dev, child;
+
+	dev = sc->vtpci_dev;
+	child = sc->vtpci_child_dev;
+
+	if (child == NULL)
+		return;
+
+	if (device_get_state(child) != DS_NOTPRESENT)
+		return;
+
+	if (device_probe(child) != 0)
+		return;
+
+	vtpci_set_status(dev, VIRTIO_CONFIG_STATUS_DRIVER);
+	if (device_attach(child) != 0) {
+		vtpci_set_status(dev, VIRTIO_CONFIG_STATUS_FAILED);
+		vtpci_reset(sc);
+		vtpci_release_child_resources(sc);
+		/* Reset status for future attempt. */
+		vtpci_set_status(dev, VIRTIO_CONFIG_STATUS_ACK);
+	} else
+		vtpci_set_status(dev, VIRTIO_CONFIG_STATUS_DRIVER_OK);
+}
+
+static int
+vtpci_alloc_msix(struct vtpci_softc *sc, int nvectors)
+{
+	device_t dev;
+	int nmsix, cnt, required;
+
+	dev = sc->vtpci_dev;
+
+	/* Allocate an additional vector for the config changes. */
+	required = nvectors + 1;
+
+	nmsix = pci_msix_count(dev);
+	if (nmsix < required)
+		return (1);
+
+	cnt = required;
+	if (pci_alloc_msix(dev, &cnt) == 0 && cnt >= required) {
+		sc->vtpci_nintr_res = required;
+		return (0);
+	}
+
+	pci_release_msi(dev);
+
+	return (1);
+}
+
+static int
+vtpci_alloc_msi(struct vtpci_softc *sc)
+{
+	device_t dev;
+	int nmsi, cnt, required;
+
+	dev = sc->vtpci_dev;
+	required = 1;
+
+	nmsi = pci_msi_count(dev);
+	if (nmsi < required)
+		return (1);
+
+	cnt = required;
+	if (pci_alloc_msi(dev, &cnt) == 0 && cnt >= required) {
+		sc->vtpci_nintr_res = required;
+		return (0);
+	}
+
+	pci_release_msi(dev);
+
+	return (1);
+}
+
+static int
+vtpci_alloc_intr_msix_pervq(struct vtpci_softc *sc)
+{
+	int i, nvectors, error;
+
+	if (vtpci_disable_msix != 0 ||
+	    sc->vtpci_flags & VTPCI_FLAG_NO_MSIX)
+		return (ENOTSUP);
+
+	for (nvectors = 0, i = 0; i < sc->vtpci_nvqs; i++) {
+		if (sc->vtpci_vqx[i].no_intr == 0)
+			nvectors++;
+	}
+
+	error = vtpci_alloc_msix(sc, nvectors);
+	if (error)
+		return (error);
+
+	sc->vtpci_flags |= VTPCI_FLAG_MSIX;
+
+	return (0);
+}
+
+static int
+vtpci_alloc_intr_msix_shared(struct vtpci_softc *sc)
+{
+	int error;
+
+	if (vtpci_disable_msix != 0 ||
+	    sc->vtpci_flags & VTPCI_FLAG_NO_MSIX)
+		return (ENOTSUP);
+
+	error = vtpci_alloc_msix(sc, 1);
+	if (error)
+		return (error);
+
+	sc->vtpci_flags |= VTPCI_FLAG_MSIX | VTPCI_FLAG_SHARED_MSIX;
+
+	return (0);
+}
+
+static int
+vtpci_alloc_intr_msi(struct vtpci_softc *sc)
+{
+	int error;
+
+	/* Only BHyVe supports MSI. */
+	if (sc->vtpci_flags & VTPCI_FLAG_NO_MSI)
+		return (ENOTSUP);
+
+	error = vtpci_alloc_msi(sc);
+	if (error)
+		return (error);
+
+	sc->vtpci_flags |= VTPCI_FLAG_MSI;
+
+	return (0);
+}
+
+static int
+vtpci_alloc_intr_legacy(struct vtpci_softc *sc)
+{
+
+	sc->vtpci_flags |= VTPCI_FLAG_LEGACY;
+	sc->vtpci_nintr_res = 1;
+
+	return (0);
+}
+
+static int
+vtpci_alloc_intr_resources(struct vtpci_softc *sc)
+{
+	device_t dev;
+	struct resource *irq;
+	struct vtpci_virtqueue *vqx;
+	int i, rid, flags, res_idx;
+
+	dev = sc->vtpci_dev;
+
+	if (sc->vtpci_flags & VTPCI_FLAG_LEGACY) {
+		rid = 0;
+		flags = RF_ACTIVE | RF_SHAREABLE;
+	} else {
+		rid = 1;
+		flags = RF_ACTIVE;
+	}
+
+	for (i = 0; i < sc->vtpci_nintr_res; i++) {
+		irq = bus_alloc_resource_any(dev, SYS_RES_IRQ, &rid, flags);
+		if (irq == NULL)
+			return (ENXIO);
+
+		sc->vtpci_intr_res[i].irq = irq;
+		sc->vtpci_intr_res[i].rid = rid++;
+	}
+
+	/*
+	 * Map the virtqueue into the correct index in vq_intr_res[]. The
+	 * first index is reserved for configuration changed notifications.
+	 */
+	for (i = 0, res_idx = 1; i < sc->vtpci_nvqs; i++) {
+		vqx = &sc->vtpci_vqx[i];
+
+		if (sc->vtpci_flags & VTPCI_FLAG_MSIX) {
+			if (vqx->no_intr != 0)
+				vqx->ires_idx = -1;
+			else if (sc->vtpci_flags & VTPCI_FLAG_SHARED_MSIX)
+				vqx->ires_idx = res_idx;
+			else
+				vqx->ires_idx = res_idx++;
+		} else
+			vqx->ires_idx = -1;
+	}
+
+	return (0);
+}
+
+static int
+vtpci_setup_legacy_interrupt(struct vtpci_softc *sc, enum intr_type type)
+{
+	device_t dev;
+	struct vtpci_intr_resource *ires;
+	int error;
+
+	dev = sc->vtpci_dev;
+
+	ires = &sc->vtpci_intr_res[0];
+	error = bus_setup_intr(dev, ires->irq, type, vtpci_legacy_intr, NULL,
+	    sc, &ires->intrhand);
+
+	return (error);
+}
+
+static int
+vtpci_setup_msix_interrupts(struct vtpci_softc *sc, enum intr_type type)
+{
+	device_t dev;
+	struct vtpci_intr_resource *ires;
+	struct vtpci_virtqueue *vqx;
+	int i, error;
+
+	dev = sc->vtpci_dev;
+
+	/*
+	 * The first resource is used for configuration changed interrupts.
+	 */
+	ires = &sc->vtpci_intr_res[0];
+	error = bus_setup_intr(dev, ires->irq, type, vtpci_config_intr,
+	    NULL, sc, &ires->intrhand);
+	if (error)
+		return (error);
+
+	if (sc->vtpci_flags & VTPCI_FLAG_SHARED_MSIX) {
+		ires = &sc->vtpci_intr_res[1];
+
+		error = bus_setup_intr(dev, ires->irq, type,
+		    vtpci_vq_shared_intr, NULL, sc, &ires->intrhand);
+		if (error)
+			return (error);
+	} else {
+		/*
+		 * Each remaining resource is assigned to a specific virtqueue.
+		 */
+		for (i = 0; i < sc->vtpci_nvqs; i++) {
+			vqx = &sc->vtpci_vqx[i];
+			if (vqx->ires_idx < 1)
+				continue;
+
+			ires = &sc->vtpci_intr_res[vqx->ires_idx];
+			error = bus_setup_intr(dev, ires->irq, type,
+			    vtpci_vq_intr, NULL, vqx->vq, &ires->intrhand);
+			if (error)
+				return (error);
+		}
+	}
+
+	error = vtpci_set_host_msix_vectors(sc);
+	if (error)
+		return (error);
+
+	return (0);
+}
+
+static int
+vtpci_setup_interrupts(struct vtpci_softc *sc, enum intr_type type)
+{
+	int error;
+
+	type |= INTR_MPSAFE;
+	KASSERT(sc->vtpci_flags & VTPCI_FLAG_ITYPE_MASK,
+	    ("no interrupt type selected: %#x", sc->vtpci_flags));
+
+	error = vtpci_alloc_intr_resources(sc);
+	if (error)
+		return (error);
+
+	if (sc->vtpci_flags & VTPCI_FLAG_LEGACY)
+		error = vtpci_setup_legacy_interrupt(sc, type);
+	else if (sc->vtpci_flags & VTPCI_FLAG_MSI)
+		error = vtpci_setup_msi_interrupt(sc, type);
+	else
+		error = vtpci_setup_msix_interrupts(sc, type);
+
+	return (error);
+}
+
+static int
+vtpci_register_msix_vector(struct vtpci_softc *sc, int offset, int res_idx)
+{
+	device_t dev;
+	uint16_t vector, rdvector;
+
+	dev = sc->vtpci_dev;
+
+	if (res_idx != -1) {
+		/* Map from guest rid to host vector. */
+		vector = sc->vtpci_intr_res[res_idx].rid - 1;
+	} else
+		vector = VIRTIO_MSI_NO_VECTOR;
+
+	/*
+	 * Assert the first resource is always used for the configuration
+	 * changed interrupts.
+	 */
+	if (res_idx == 0) {
+		KASSERT(vector == 0 && offset == VIRTIO_MSI_CONFIG_VECTOR,
+		    ("bad first res use vector:%d offset:%d", vector, offset));
+	} else
+		KASSERT(offset == VIRTIO_MSI_QUEUE_VECTOR, ("bad offset"));
+
+	vtpci_write_config_2(sc, offset, vector);
+
+	/* Read vector to determine if the host had sufficient resources. */
+	rdvector = vtpci_read_config_2(sc, offset);
+	if (rdvector != vector) {
+		device_printf(dev,
+		    "insufficient host resources for MSIX interrupts\n");
+		return (ENODEV);
+	}
+
+	return (0);
+}
+
+static int
+vtpci_set_host_msix_vectors(struct vtpci_softc *sc)
+{
+	struct vtpci_virtqueue *vqx;
+	int idx, error;
+
+	error = vtpci_register_msix_vector(sc, VIRTIO_MSI_CONFIG_VECTOR, 0);
+	if (error)
+		return (error);
+
+	for (idx = 0; idx < sc->vtpci_nvqs; idx++) {
+		vqx = &sc->vtpci_vqx[idx];
+
+		vtpci_select_virtqueue(sc, idx);
+		error = vtpci_register_msix_vector(sc, VIRTIO_MSI_QUEUE_VECTOR,
+		    vqx->ires_idx);
+		if (error)
+			return (error);
+	}
+
+	return (0);
+}
+
+static int
+vtpci_reinit_virtqueue(struct vtpci_softc *sc, int idx)
+{
+	struct vtpci_virtqueue *vqx;
+	struct virtqueue *vq;
+	int error;
+	uint16_t size;
+
+	vqx = &sc->vtpci_vqx[idx];
+	vq = vqx->vq;
+
+	KASSERT(vq != NULL, ("vq %d not allocated", idx));
+
+	vtpci_select_virtqueue(sc, idx);
+	size = vtpci_read_config_2(sc, VIRTIO_PCI_QUEUE_NUM);
+
+	error = virtqueue_reinit(vq, size);
+	if (error)
+		return (error);
+
+	vtpci_write_config_4(sc, VIRTIO_PCI_QUEUE_PFN,
+	    virtqueue_paddr(vq) >> VIRTIO_PCI_QUEUE_ADDR_SHIFT);
+
+	return (0);
+}
+
+static void
+vtpci_free_interrupts(struct vtpci_softc *sc)
+{
+	device_t dev;
+	struct vtpci_intr_resource *ires;
+	int i;
+
+	dev = sc->vtpci_dev;
+
+	for (i = 0; i < sc->vtpci_nintr_res; i++) {
+		ires = &sc->vtpci_intr_res[i];
+
+		if (ires->intrhand != NULL) {
+			bus_teardown_intr(dev, ires->irq, ires->intrhand);
+			ires->intrhand = NULL;
+		}
+
+		if (ires->irq != NULL) {
+			bus_release_resource(dev, SYS_RES_IRQ, ires->rid,
+			    ires->irq);
+			ires->irq = NULL;
+		}
+
+		ires->rid = -1;
+	}
+
+	if (sc->vtpci_flags & (VTPCI_FLAG_MSI | VTPCI_FLAG_MSIX))
+		pci_release_msi(dev);
+
+	sc->vtpci_nintr_res = 0;
+	sc->vtpci_flags &= ~VTPCI_FLAG_ITYPE_MASK;
+}
+
+static void
+vtpci_free_virtqueues(struct vtpci_softc *sc)
+{
+	struct vtpci_virtqueue *vqx;
+	int i;
+
+	for (i = 0; i < sc->vtpci_nvqs; i++) {
+		vqx = &sc->vtpci_vqx[i];
+
+		virtqueue_free(vqx->vq);
+		vqx->vq = NULL;
+	}
+
+	sc->vtpci_nvqs = 0;
+}
+
+static void
+vtpci_cleanup_setup_intr_attempt(struct vtpci_softc *sc)
+{
+	int idx;
+
+	if (sc->vtpci_flags & VTPCI_FLAG_MSIX) {
+		vtpci_write_config_2(sc, VIRTIO_MSI_CONFIG_VECTOR,
+		    VIRTIO_MSI_NO_VECTOR);
+
+		for (idx = 0; idx < sc->vtpci_nvqs; idx++) {
+			vtpci_select_virtqueue(sc, idx);
+			vtpci_write_config_2(sc, VIRTIO_MSI_QUEUE_VECTOR,
+			    VIRTIO_MSI_NO_VECTOR);
+		}
+	}
+
+	vtpci_free_interrupts(sc);
+}
+
+static void
+vtpci_release_child_resources(struct vtpci_softc *sc)
+{
+
+	vtpci_free_interrupts(sc);
+	vtpci_free_virtqueues(sc);
+}
+
+static void
+vtpci_reset(struct vtpci_softc *sc)
+{
+
+	/*
+	 * Setting the status to RESET sets the host device to
+	 * the original, uninitialized state.
+	 */
+	vtpci_set_status(sc->vtpci_dev, VIRTIO_CONFIG_STATUS_RESET);
+}
+
+static void
+vtpci_select_virtqueue(struct vtpci_softc *sc, int idx)
+{
+
+	vtpci_write_config_2(sc, VIRTIO_PCI_QUEUE_SEL, idx);
+}
+
+static int
+vtpci_legacy_intr(void *xsc)
+{
+	struct vtpci_softc *sc;
+	struct vtpci_virtqueue *vqx;
+	int i;
+	uint8_t isr;
+
+	sc = xsc;
+	vqx = &sc->vtpci_vqx[0];
+
+	/* Reading the ISR also clears it. */
+	isr = vtpci_read_config_1(sc, VIRTIO_PCI_ISR);
+
+	if (isr & VIRTIO_PCI_ISR_CONFIG)
+		vtpci_config_intr(sc);
+
+	if (isr & VIRTIO_PCI_ISR_INTR)
+		for (i = 0; i < sc->vtpci_nvqs; i++, vqx++)
+			virtqueue_intr(vqx->vq);
+
+	return (isr ? FILTER_HANDLED : FILTER_STRAY);
+}
+
+static int
+vtpci_vq_shared_intr(void *xsc)
+{
+	struct vtpci_softc *sc;
+	struct vtpci_virtqueue *vqx;
+	int i, rc;
+
+	rc = 0;
+	sc = xsc;
+	vqx = &sc->vtpci_vqx[0];
+
+	for (i = 0; i < sc->vtpci_nvqs; i++, vqx++)
+		rc |= virtqueue_intr(vqx->vq);
+
+	return (rc ? FILTER_HANDLED : FILTER_STRAY);
+}
+
+static int
+vtpci_vq_intr(void *xvq)
+{
+	struct virtqueue *vq;
+	int rc;
+
+	vq = xvq;
+	rc = virtqueue_intr(vq);
+
+	return (rc ? FILTER_HANDLED : FILTER_STRAY);
+}
+
+static int
+vtpci_config_intr(void *xsc)
+{
+	struct vtpci_softc *sc;
+	device_t child;
+	int rc;
+
+	rc = 0;
+	sc = xsc;
+	child = sc->vtpci_child_dev;
+
+	if (child != NULL)
+		rc = VIRTIO_CONFIG_CHANGE(child);
+
+	return (rc ? FILTER_HANDLED : FILTER_STRAY);
+}
diff --git a/sys/dev/virtio/pci/virtio_pci.h b/sys/dev/virtio/pci/virtio_pci.h
new file mode 100644
index 0000000..485cf4f
--- /dev/null
+++ b/sys/dev/virtio/pci/virtio_pci.h
@@ -0,0 +1,87 @@
+/*-
+ * Copyright IBM Corp. 2007
+ *
+ * Authors:
+ *  Anthony Liguori  <aliguori@us.ibm.com>
+ *
+ * This header is BSD licensed so anyone can use the definitions to implement
+ * compatible drivers/servers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of IBM nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL IBM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+
+#ifndef _VIRTIO_PCI_H
+#define _VIRTIO_PCI_H
+
+/* VirtIO PCI vendor/device ID. */
+#define VIRTIO_PCI_VENDORID	0x1AF4
+#define VIRTIO_PCI_DEVICEID_MIN	0x1000
+#define VIRTIO_PCI_DEVICEID_MAX	0x103F
+
+/* VirtIO ABI version, this must match exactly. */
+#define VIRTIO_PCI_ABI_VERSION	0
+
+/*
+ * VirtIO Header, located in BAR 0.
+ */
+#define VIRTIO_PCI_HOST_FEATURES  0  /* host's supported features (32bit, RO)*/
+#define VIRTIO_PCI_GUEST_FEATURES 4  /* guest's supported features (32, RW) */
+#define VIRTIO_PCI_QUEUE_PFN      8  /* physical address of VQ (32, RW) */
+#define VIRTIO_PCI_QUEUE_NUM      12 /* number of ring entries (16, RO) */
+#define VIRTIO_PCI_QUEUE_SEL      14 /* current VQ selection (16, RW) */
+#define VIRTIO_PCI_QUEUE_NOTIFY	  16 /* notify host regarding VQ (16, RW) */
+#define VIRTIO_PCI_STATUS         18 /* device status register (8, RW) */
+#define VIRTIO_PCI_ISR            19 /* interrupt status register, reading
+				      * also clears the register (8, RO) */
+/* Only if MSIX is enabled: */
+#define VIRTIO_MSI_CONFIG_VECTOR  20 /* configuration change vector (16, RW) */
+#define VIRTIO_MSI_QUEUE_VECTOR   22 /* vector for selected VQ notifications
+					(16, RW) */
+
+/* The bit of the ISR which indicates a device has an interrupt. */
+#define VIRTIO_PCI_ISR_INTR	0x1
+/* The bit of the ISR which indicates a device configuration change. */
+#define VIRTIO_PCI_ISR_CONFIG	0x2
+/* Vector value used to disable MSI for queue. */
+#define VIRTIO_MSI_NO_VECTOR	0xFFFF
+
+/*
+ * The remaining space is defined by each driver as the per-driver
+ * configuration space.
+ */
+#define VIRTIO_PCI_CONFIG(sc) \
+    (((sc)->vtpci_flags & VTPCI_FLAG_MSIX) ? 24 : 20)
+
+/*
+ * How many bits to shift physical queue address written to QUEUE_PFN.
+ * 12 is historical, and due to x86 page size.
+ */
+#define VIRTIO_PCI_QUEUE_ADDR_SHIFT	12
+
+/* The alignment to use between consumer and producer parts of vring. */
+#define VIRTIO_PCI_VRING_ALIGN	4096
+
+#endif /* _VIRTIO_PCI_H */
diff --git a/sys/dev/virtio/scsi/virtio_scsi.c b/sys/dev/virtio/scsi/virtio_scsi.c
new file mode 100644
index 0000000..3d939d8
--- /dev/null
+++ b/sys/dev/virtio/scsi/virtio_scsi.c
@@ -0,0 +1,2351 @@
+/*-
+ * Copyright (c) 2012, Bryan Venteicher <bryanv@daemoninthecloset.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice unmodified, this list of conditions, and the following
+ *    disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* Driver for VirtIO SCSI devices. */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/kernel.h>
+#include <sys/kthread.h>
+#include <sys/malloc.h>
+#include <sys/module.h>
+#include <sys/sglist.h>
+#include <sys/sysctl.h>
+#include <sys/lock.h>
+#include <sys/mutex.h>
+#include <sys/callout.h>
+#include <sys/taskqueue.h>
+#include <sys/queue.h>
+#include <sys/sbuf.h>
+
+#include <machine/stdarg.h>
+
+#include <machine/bus.h>
+#include <machine/resource.h>
+#include <sys/bus.h>
+#include <sys/rman.h>
+
+#include <cam/cam.h>
+#include <cam/cam_ccb.h>
+#include <cam/cam_sim.h>
+#include <cam/cam_periph.h>
+#include <cam/cam_xpt_sim.h>
+#include <cam/cam_debug.h>
+#include <cam/scsi/scsi_all.h>
+#include <cam/scsi/scsi_message.h>
+
+#include <dev/virtio/virtio.h>
+#include <dev/virtio/virtqueue.h>
+#include <dev/virtio/scsi/virtio_scsi.h>
+#include <dev/virtio/scsi/virtio_scsivar.h>
+
+#include "virtio_if.h"
+
+static int	vtscsi_modevent(module_t, int, void *);
+
+static int	vtscsi_probe(device_t);
+static int	vtscsi_attach(device_t);
+static int	vtscsi_detach(device_t);
+static int	vtscsi_suspend(device_t);
+static int	vtscsi_resume(device_t);
+
+static void	vtscsi_negotiate_features(struct vtscsi_softc *);
+static int	vtscsi_maximum_segments(struct vtscsi_softc *, int);
+static int	vtscsi_alloc_virtqueues(struct vtscsi_softc *);
+static void	vtscsi_write_device_config(struct vtscsi_softc *);
+static int	vtscsi_reinit(struct vtscsi_softc *);
+
+static int	vtscsi_alloc_cam(struct vtscsi_softc *);
+static int 	vtscsi_register_cam(struct vtscsi_softc *);
+static void	vtscsi_free_cam(struct vtscsi_softc *);
+static void	vtscsi_cam_async(void *, uint32_t, struct cam_path *, void *);
+static int	vtscsi_register_async(struct vtscsi_softc *);
+static void	vtscsi_deregister_async(struct vtscsi_softc *);
+static void	vtscsi_cam_action(struct cam_sim *, union ccb *);
+static void	vtscsi_cam_poll(struct cam_sim *);
+
+static void	vtscsi_cam_scsi_io(struct vtscsi_softc *, struct cam_sim *,
+		    union ccb *);
+static void 	vtscsi_cam_get_tran_settings(struct vtscsi_softc *,
+		    union ccb *);
+static void	vtscsi_cam_reset_bus(struct vtscsi_softc *, union ccb *);
+static void	vtscsi_cam_reset_dev(struct vtscsi_softc *, union ccb *);
+static void	vtscsi_cam_abort(struct vtscsi_softc *, union ccb *);
+static void	vtscsi_cam_path_inquiry(struct vtscsi_softc *,
+		    struct cam_sim *, union ccb *);
+
+static int 	vtscsi_sg_append_scsi_buf(struct vtscsi_softc *,
+		    struct sglist *, struct ccb_scsiio *);
+static int 	vtscsi_fill_scsi_cmd_sglist(struct vtscsi_softc *,
+		    struct vtscsi_request *, int *, int *);
+static int 	vtscsi_execute_scsi_cmd(struct vtscsi_softc *,
+		    struct vtscsi_request *);
+static int 	vtscsi_start_scsi_cmd(struct vtscsi_softc *, union ccb *);
+static void	vtscsi_complete_abort_timedout_scsi_cmd(struct vtscsi_softc *,
+		    struct vtscsi_request *);
+static int 	vtscsi_abort_timedout_scsi_cmd(struct vtscsi_softc *,
+		    struct vtscsi_request *);
+static void	vtscsi_timedout_scsi_cmd(void *);
+static cam_status vtscsi_scsi_cmd_cam_status(struct virtio_scsi_cmd_resp *);
+static cam_status vtscsi_complete_scsi_cmd_response(struct vtscsi_softc *,
+		    struct ccb_scsiio *, struct virtio_scsi_cmd_resp *);
+static void 	vtscsi_complete_scsi_cmd(struct vtscsi_softc *,
+		    struct vtscsi_request *);
+
+static void	vtscsi_poll_ctrl_req(struct vtscsi_softc *,
+		    struct vtscsi_request *);
+static int 	vtscsi_execute_ctrl_req(struct vtscsi_softc *,
+		    struct vtscsi_request *, struct sglist *, int, int, int);
+static void 	vtscsi_complete_abort_task_cmd(struct vtscsi_softc *c,
+		    struct vtscsi_request *);
+static int 	vtscsi_execute_abort_task_cmd(struct vtscsi_softc *,
+		    struct vtscsi_request *);
+static int 	vtscsi_execute_reset_dev_cmd(struct vtscsi_softc *,
+		    struct vtscsi_request *);
+
+static void 	vtscsi_get_request_lun(uint8_t [], target_id_t *, lun_id_t *);
+static void	vtscsi_set_request_lun(struct ccb_hdr *, uint8_t []);
+static void	vtscsi_init_scsi_cmd_req(struct ccb_scsiio *,
+		    struct virtio_scsi_cmd_req *);
+static void	vtscsi_init_ctrl_tmf_req(struct ccb_hdr *, uint32_t,
+		    uintptr_t, struct virtio_scsi_ctrl_tmf_req *);
+
+static void 	vtscsi_freeze_simq(struct vtscsi_softc *, int);
+static int	vtscsi_thaw_simq(struct vtscsi_softc *, int);
+
+static void 	vtscsi_announce(struct vtscsi_softc *, uint32_t, target_id_t,
+		    lun_id_t);
+static void 	vtscsi_execute_rescan(struct vtscsi_softc *, target_id_t,
+		    lun_id_t);
+static void 	vtscsi_execute_rescan_bus(struct vtscsi_softc *);
+
+static void 	vtscsi_handle_event(struct vtscsi_softc *,
+		    struct virtio_scsi_event *);
+static int 	vtscsi_enqueue_event_buf(struct vtscsi_softc *,
+		    struct virtio_scsi_event *);
+static int	vtscsi_init_event_vq(struct vtscsi_softc *);
+static void 	vtscsi_reinit_event_vq(struct vtscsi_softc *);
+static void 	vtscsi_drain_event_vq(struct vtscsi_softc *);
+
+static void 	vtscsi_complete_vqs_locked(struct vtscsi_softc *);
+static void 	vtscsi_complete_vqs(struct vtscsi_softc *);
+static void 	vtscsi_drain_vqs(struct vtscsi_softc *);
+static void 	vtscsi_cancel_request(struct vtscsi_softc *,
+		    struct vtscsi_request *);
+static void	vtscsi_drain_vq(struct vtscsi_softc *, struct virtqueue *);
+static void	vtscsi_stop(struct vtscsi_softc *);
+static int	vtscsi_reset_bus(struct vtscsi_softc *);
+
+static void 	vtscsi_init_request(struct vtscsi_softc *,
+		    struct vtscsi_request *);
+static int	vtscsi_alloc_requests(struct vtscsi_softc *);
+static void	vtscsi_free_requests(struct vtscsi_softc *);
+static void	vtscsi_enqueue_request(struct vtscsi_softc *,
+		    struct vtscsi_request *);
+static struct vtscsi_request * vtscsi_dequeue_request(struct vtscsi_softc *);
+
+static void	vtscsi_complete_request(struct vtscsi_request *);
+static void 	vtscsi_complete_vq(struct vtscsi_softc *, struct virtqueue *);
+static void	vtscsi_control_vq_task(void *, int);
+static void	vtscsi_event_vq_task(void *, int);
+static void	vtscsi_request_vq_task(void *, int);
+
+static int	vtscsi_control_vq_intr(void *);
+static int	vtscsi_event_vq_intr(void *);
+static int	vtscsi_request_vq_intr(void *);
+static void 	vtscsi_disable_vqs_intr(struct vtscsi_softc *);
+static void 	vtscsi_enable_vqs_intr(struct vtscsi_softc *);
+
+static void 	vtscsi_get_tunables(struct vtscsi_softc *);
+static void 	vtscsi_add_sysctl(struct vtscsi_softc *);
+
+static void 	vtscsi_printf_req(struct vtscsi_request *, const char *,
+		    const char *, ...);
+
+/* Global tunables. */
+/*
+ * The current QEMU VirtIO SCSI implementation does not cancel in-flight
+ * IO during virtio_stop(). So in-flight requests still complete after the
+ * device reset. We would have to wait for all the in-flight IO to complete,
+ * which defeats the typical purpose of a bus reset. We could simulate the
+ * bus reset with either I_T_NEXUS_RESET of all the targets, or with
+ * LOGICAL_UNIT_RESET of all the LUNs (assuming there is space in the
+ * control virtqueue). But this isn't very useful if things really go off
+ * the rails, so default to disabled for now.
+ */
+static int vtscsi_bus_reset_disable = 1;
+TUNABLE_INT("hw.vtscsi.bus_reset_disable", &vtscsi_bus_reset_disable);
+
+static struct virtio_feature_desc vtscsi_feature_desc[] = {
+	{ VIRTIO_SCSI_F_INOUT,		"InOut"		},
+	{ VIRTIO_SCSI_F_HOTPLUG,	"Hotplug"	},
+
+	{ 0, NULL }
+};
+
+static device_method_t vtscsi_methods[] = {
+	/* Device methods. */
+	DEVMETHOD(device_probe,		vtscsi_probe),
+	DEVMETHOD(device_attach,	vtscsi_attach),
+	DEVMETHOD(device_detach,	vtscsi_detach),
+	DEVMETHOD(device_suspend,	vtscsi_suspend),
+	DEVMETHOD(device_resume,	vtscsi_resume),
+
+	DEVMETHOD_END
+};
+
+static driver_t vtscsi_driver = {
+	"vtscsi",
+	vtscsi_methods,
+	sizeof(struct vtscsi_softc)
+};
+static devclass_t vtscsi_devclass;
+
+DRIVER_MODULE(virtio_scsi, virtio_pci, vtscsi_driver, vtscsi_devclass,
+    vtscsi_modevent, 0);
+MODULE_VERSION(virtio_scsi, 1);
+MODULE_DEPEND(virtio_scsi, virtio, 1, 1, 1);
+MODULE_DEPEND(virtio_scsi, cam, 1, 1, 1);
+
+static int
+vtscsi_modevent(module_t mod, int type, void *unused)
+{
+	int error;
+
+	switch (type) {
+	case MOD_LOAD:
+	case MOD_QUIESCE:
+	case MOD_UNLOAD:
+	case MOD_SHUTDOWN:
+		error = 0;
+		break;
+	default:
+		error = EOPNOTSUPP;
+		break;
+	}
+
+	return (error);
+}
+
+static int
+vtscsi_probe(device_t dev)
+{
+
+	if (virtio_get_device_type(dev) != VIRTIO_ID_SCSI)
+		return (ENXIO);
+
+	device_set_desc(dev, "VirtIO SCSI Adapter");
+
+	return (BUS_PROBE_DEFAULT);
+}
+
+static int
+vtscsi_attach(device_t dev)
+{
+	struct vtscsi_softc *sc;
+	struct virtio_scsi_config scsicfg;
+	int error;
+
+	sc = device_get_softc(dev);
+	sc->vtscsi_dev = dev;
+
+	VTSCSI_LOCK_INIT(sc, device_get_nameunit(dev));
+	TAILQ_INIT(&sc->vtscsi_req_free);
+
+	vtscsi_get_tunables(sc);
+	vtscsi_add_sysctl(sc);
+
+	virtio_set_feature_desc(dev, vtscsi_feature_desc);
+	vtscsi_negotiate_features(sc);
+
+	if (virtio_with_feature(dev, VIRTIO_RING_F_INDIRECT_DESC))
+		sc->vtscsi_flags |= VTSCSI_FLAG_INDIRECT;
+	if (virtio_with_feature(dev, VIRTIO_SCSI_F_INOUT))
+		sc->vtscsi_flags |= VTSCSI_FLAG_BIDIRECTIONAL;
+	if (virtio_with_feature(dev, VIRTIO_SCSI_F_HOTPLUG))
+		sc->vtscsi_flags |= VTSCSI_FLAG_HOTPLUG;
+
+	virtio_read_device_config(dev, 0, &scsicfg,
+	    sizeof(struct virtio_scsi_config));
+
+	sc->vtscsi_max_channel = scsicfg.max_channel;
+	sc->vtscsi_max_target = scsicfg.max_target;
+	sc->vtscsi_max_lun = scsicfg.max_lun;
+	sc->vtscsi_event_buf_size = scsicfg.event_info_size;
+
+	vtscsi_write_device_config(sc);
+
+	sc->vtscsi_max_nsegs = vtscsi_maximum_segments(sc, scsicfg.seg_max);
+	sc->vtscsi_sglist = sglist_alloc(sc->vtscsi_max_nsegs, M_NOWAIT);
+	if (sc->vtscsi_sglist == NULL) {
+		error = ENOMEM;
+		device_printf(dev, "cannot allocate sglist\n");
+		goto fail;
+	}
+
+	error = vtscsi_alloc_virtqueues(sc);
+	if (error) {
+		device_printf(dev, "cannot allocate virtqueues\n");
+		goto fail;
+	}
+
+	error = vtscsi_init_event_vq(sc);
+	if (error) {
+		device_printf(dev, "cannot populate the eventvq\n");
+		goto fail;
+	}
+
+	error = vtscsi_alloc_requests(sc);
+	if (error) {
+		device_printf(dev, "cannot allocate requests\n");
+		goto fail;
+	}
+
+	error = vtscsi_alloc_cam(sc);
+	if (error) {
+		device_printf(dev, "cannot allocate CAM structures\n");
+		goto fail;
+	}
+
+	TASK_INIT(&sc->vtscsi_control_intr_task, 0,
+	    vtscsi_control_vq_task, sc);
+	TASK_INIT(&sc->vtscsi_event_intr_task, 0,
+	    vtscsi_event_vq_task, sc);
+	TASK_INIT(&sc->vtscsi_request_intr_task, 0,
+	    vtscsi_request_vq_task, sc);
+
+	sc->vtscsi_tq = taskqueue_create_fast("vtscsi_taskq", M_NOWAIT,
+	    taskqueue_thread_enqueue, &sc->vtscsi_tq);
+	if (sc->vtscsi_tq == NULL) {
+		error = ENOMEM;
+		device_printf(dev, "cannot allocate taskqueue\n");
+		goto fail;
+	}
+
+	error = virtio_setup_intr(dev, INTR_TYPE_CAM);
+	if (error) {
+		device_printf(dev, "cannot setup virtqueue interrupts\n");
+		goto fail;
+	}
+
+	taskqueue_start_threads(&sc->vtscsi_tq, 1, PI_DISK, "%s taskq",
+	    device_get_nameunit(dev));
+
+	vtscsi_enable_vqs_intr(sc);
+
+	/*
+	 * Register with CAM after interrupts are enabled so we will get
+	 * notified of the probe responses.
+	 */
+	error = vtscsi_register_cam(sc);
+	if (error) {
+		device_printf(dev, "cannot register with CAM\n");
+		goto fail;
+	}
+
+fail:
+	if (error)
+		vtscsi_detach(dev);
+
+	return (error);
+}
+
+static int
+vtscsi_detach(device_t dev)
+{
+	struct vtscsi_softc *sc;
+
+	sc = device_get_softc(dev);
+
+	VTSCSI_LOCK(sc);
+	sc->vtscsi_flags |= VTSCSI_FLAG_DETACH;
+	if (device_is_attached(dev))
+		vtscsi_stop(sc);
+	VTSCSI_UNLOCK(sc);
+
+	if (sc->vtscsi_tq != NULL) {
+		taskqueue_drain(sc->vtscsi_tq, &sc->vtscsi_control_intr_task);
+		taskqueue_drain(sc->vtscsi_tq, &sc->vtscsi_event_intr_task);
+		taskqueue_drain(sc->vtscsi_tq, &sc->vtscsi_request_intr_task);
+		taskqueue_free(sc->vtscsi_tq);
+		sc->vtscsi_tq = NULL;
+	}
+
+	vtscsi_complete_vqs(sc);
+	vtscsi_drain_vqs(sc);
+
+	vtscsi_free_cam(sc);
+	vtscsi_free_requests(sc);
+
+	if (sc->vtscsi_sglist != NULL) {
+		sglist_free(sc->vtscsi_sglist);
+		sc->vtscsi_sglist = NULL;
+	}
+
+	VTSCSI_LOCK_DESTROY(sc);
+
+	return (0);
+}
+
+static int
+vtscsi_suspend(device_t dev)
+{
+
+	return (0);
+}
+
+static int
+vtscsi_resume(device_t dev)
+{
+
+	return (0);
+}
+
+static void
+vtscsi_negotiate_features(struct vtscsi_softc *sc)
+{
+	device_t dev;
+	uint64_t features;
+
+	dev = sc->vtscsi_dev;
+	features = virtio_negotiate_features(dev, VTSCSI_FEATURES);
+	sc->vtscsi_features = features;
+}
+
+static int
+vtscsi_maximum_segments(struct vtscsi_softc *sc, int seg_max)
+{
+	int nsegs;
+
+	nsegs = VTSCSI_MIN_SEGMENTS;
+
+	if (seg_max > 0) {
+		nsegs += MIN(seg_max, MAXPHYS / PAGE_SIZE + 1);
+		if (sc->vtscsi_flags & VTSCSI_FLAG_INDIRECT)
+			nsegs = MIN(nsegs, VIRTIO_MAX_INDIRECT);
+	} else
+		nsegs += 1;
+
+	return (nsegs);
+}
+
+static int
+vtscsi_alloc_virtqueues(struct vtscsi_softc *sc)
+{
+	device_t dev;
+	struct vq_alloc_info vq_info[3];
+	int nvqs;
+
+	dev = sc->vtscsi_dev;
+	nvqs = 3;
+
+	VQ_ALLOC_INFO_INIT(&vq_info[0], 0, vtscsi_control_vq_intr, sc,
+	    &sc->vtscsi_control_vq, "%s control", device_get_nameunit(dev));
+
+	VQ_ALLOC_INFO_INIT(&vq_info[1], 0, vtscsi_event_vq_intr, sc,
+	    &sc->vtscsi_event_vq, "%s event", device_get_nameunit(dev));
+
+	VQ_ALLOC_INFO_INIT(&vq_info[2], sc->vtscsi_max_nsegs,
+	    vtscsi_request_vq_intr, sc, &sc->vtscsi_request_vq,
+	    "%s request", device_get_nameunit(dev));
+
+	return (virtio_alloc_virtqueues(dev, 0, nvqs, vq_info));
+}
+
+static void
+vtscsi_write_device_config(struct vtscsi_softc *sc)
+{
+
+	virtio_write_dev_config_4(sc->vtscsi_dev,
+	    offsetof(struct virtio_scsi_config, sense_size),
+	    VIRTIO_SCSI_SENSE_SIZE);
+
+	/*
+	 * This is the size in the virtio_scsi_cmd_req structure. Note
+	 * this value (32) is larger than the maximum CAM CDB size (16).
+	 */
+	virtio_write_dev_config_4(sc->vtscsi_dev,
+	    offsetof(struct virtio_scsi_config, cdb_size),
+	    VIRTIO_SCSI_CDB_SIZE);
+}
+
+static int
+vtscsi_reinit(struct vtscsi_softc *sc)
+{
+	device_t dev;
+	int error;
+
+	dev = sc->vtscsi_dev;
+
+	error = virtio_reinit(dev, sc->vtscsi_features);
+	if (error == 0) {
+		vtscsi_write_device_config(sc);
+		vtscsi_reinit_event_vq(sc);
+		virtio_reinit_complete(dev);
+
+		vtscsi_enable_vqs_intr(sc);
+	}
+
+	vtscsi_dprintf(sc, VTSCSI_TRACE, "error=%d\n", error);
+
+	return (error);
+}
+
+static int
+vtscsi_alloc_cam(struct vtscsi_softc *sc)
+{
+	device_t dev;
+	struct cam_devq *devq;
+	int openings;
+
+	dev = sc->vtscsi_dev;
+	openings = sc->vtscsi_nrequests - VTSCSI_RESERVED_REQUESTS;
+
+	devq = cam_simq_alloc(openings);
+	if (devq == NULL) {
+		device_printf(dev, "cannot allocate SIM queue\n");
+		return (ENOMEM);
+	}
+
+	sc->vtscsi_sim = cam_sim_alloc(vtscsi_cam_action, vtscsi_cam_poll,
+	    "vtscsi", sc, device_get_unit(dev), VTSCSI_MTX(sc), 1,
+	    openings, devq);
+	if (sc->vtscsi_sim == NULL) {
+		cam_simq_free(devq);
+		device_printf(dev, "cannot allocate SIM\n");
+		return (ENOMEM);
+	}
+
+	return (0);
+}
+
+static int
+vtscsi_register_cam(struct vtscsi_softc *sc)
+{
+	device_t dev;
+	int registered, error;
+
+	dev = sc->vtscsi_dev;
+	registered = 0;
+
+	VTSCSI_LOCK(sc);
+
+	if (xpt_bus_register(sc->vtscsi_sim, dev, 0) != CAM_SUCCESS) {
+		error = ENOMEM;
+		device_printf(dev, "cannot register XPT bus\n");
+		goto fail;
+	}
+
+	registered = 1;
+
+	if (xpt_create_path(&sc->vtscsi_path, NULL,
+	    cam_sim_path(sc->vtscsi_sim), CAM_TARGET_WILDCARD,
+	    CAM_LUN_WILDCARD) != CAM_REQ_CMP) {
+		error = ENOMEM;
+		device_printf(dev, "cannot create bus path\n");
+		goto fail;
+	}
+
+	VTSCSI_UNLOCK(sc);
+
+	/*
+	 * The async register apparently needs to be done without
+	 * the lock held, otherwise it can recurse on the lock.
+	 */
+	if (vtscsi_register_async(sc) != CAM_REQ_CMP) {
+		error = EIO;
+		device_printf(dev, "cannot register async callback\n");
+		VTSCSI_LOCK(sc);
+		goto fail;
+	}
+
+	return (0);
+
+fail:
+	if (sc->vtscsi_path != NULL) {
+		xpt_free_path(sc->vtscsi_path);
+		sc->vtscsi_path = NULL;
+	}
+
+	if (registered != 0)
+		xpt_bus_deregister(cam_sim_path(sc->vtscsi_sim));
+
+	VTSCSI_UNLOCK(sc);
+
+	return (error);
+}
+
+static void
+vtscsi_free_cam(struct vtscsi_softc *sc)
+{
+
+	VTSCSI_LOCK(sc);
+
+	if (sc->vtscsi_path != NULL) {
+		vtscsi_deregister_async(sc);
+
+		xpt_free_path(sc->vtscsi_path);
+		sc->vtscsi_path = NULL;
+
+		xpt_bus_deregister(cam_sim_path(sc->vtscsi_sim));
+	}
+
+	if (sc->vtscsi_sim != NULL) {
+		cam_sim_free(sc->vtscsi_sim, 1);
+		sc->vtscsi_sim = NULL;
+	}
+
+	VTSCSI_UNLOCK(sc);
+}
+
+static void
+vtscsi_cam_async(void *cb_arg, uint32_t code, struct cam_path *path, void *arg)
+{
+	struct cam_sim *sim;
+	struct vtscsi_softc *sc;
+
+	sim = cb_arg;
+	sc = cam_sim_softc(sim);
+
+	vtscsi_dprintf(sc, VTSCSI_TRACE, "code=%u\n", code);
+
+	/*
+	 * TODO Once QEMU supports event reporting, we should
+	 *      (un)subscribe to events here.
+	 */
+	switch (code) {
+	case AC_FOUND_DEVICE:
+		break;
+	case AC_LOST_DEVICE:
+		break;
+	}
+}
+
+static int
+vtscsi_register_async(struct vtscsi_softc *sc)
+{
+	struct ccb_setasync csa;
+
+	VTSCSI_LOCK_NOTOWNED(sc);
+
+	xpt_setup_ccb(&csa.ccb_h, sc->vtscsi_path, 5);
+	csa.ccb_h.func_code = XPT_SASYNC_CB;
+	csa.event_enable = AC_LOST_DEVICE | AC_FOUND_DEVICE;
+	csa.callback = vtscsi_cam_async;
+	csa.callback_arg = sc->vtscsi_sim;
+
+	xpt_action((union ccb *) &csa);
+
+	return (csa.ccb_h.status);
+}
+
+static void
+vtscsi_deregister_async(struct vtscsi_softc *sc)
+{
+	struct ccb_setasync csa;
+
+	xpt_setup_ccb(&csa.ccb_h, sc->vtscsi_path, 5);
+	csa.ccb_h.func_code = XPT_SASYNC_CB;
+	csa.event_enable = 0;
+	csa.callback = vtscsi_cam_async;
+	csa.callback_arg = sc->vtscsi_sim;
+
+	xpt_action((union ccb *) &csa);
+}
+
+static void
+vtscsi_cam_action(struct cam_sim *sim, union ccb *ccb)
+{
+	struct vtscsi_softc *sc;
+	struct ccb_hdr *ccbh;
+
+	sc = cam_sim_softc(sim);
+	ccbh = &ccb->ccb_h;
+
+	VTSCSI_LOCK_OWNED(sc);
+
+	if (sc->vtscsi_flags & VTSCSI_FLAG_DETACH) {
+		/*
+		 * The VTSCSI_MTX is briefly dropped between setting
+		 * VTSCSI_FLAG_DETACH and deregistering with CAM, so
+		 * drop any CCBs that come in during that window.
+		 */
+		ccbh->status = CAM_NO_HBA;
+		xpt_done(ccb);
+		return;
+	}
+
+	switch (ccbh->func_code) {
+	case XPT_SCSI_IO:
+		vtscsi_cam_scsi_io(sc, sim, ccb);
+		break;
+
+	case XPT_SET_TRAN_SETTINGS:
+		ccbh->status = CAM_FUNC_NOTAVAIL;
+		xpt_done(ccb);
+		break;
+
+	case XPT_GET_TRAN_SETTINGS:
+		vtscsi_cam_get_tran_settings(sc, ccb);
+		break;
+
+	case XPT_RESET_BUS:
+		vtscsi_cam_reset_bus(sc, ccb);
+		break;
+
+	case XPT_RESET_DEV:
+		vtscsi_cam_reset_dev(sc, ccb);
+		break;
+
+	case XPT_ABORT:
+		vtscsi_cam_abort(sc, ccb);
+		break;
+
+	case XPT_CALC_GEOMETRY:
+		cam_calc_geometry(&ccb->ccg, 1);
+		xpt_done(ccb);
+		break;
+
+	case XPT_PATH_INQ:
+		vtscsi_cam_path_inquiry(sc, sim, ccb);
+		break;
+
+	default:
+		vtscsi_dprintf(sc, VTSCSI_ERROR,
+		    "invalid ccb=%p func=%#x\n", ccb, ccbh->func_code);
+
+		ccbh->status = CAM_REQ_INVALID;
+		xpt_done(ccb);
+		break;
+	}
+}
+
+static void
+vtscsi_cam_poll(struct cam_sim *sim)
+{
+	struct vtscsi_softc *sc;
+
+	sc = cam_sim_softc(sim);
+
+	vtscsi_complete_vqs_locked(sc);
+}
+
+static void
+vtscsi_cam_scsi_io(struct vtscsi_softc *sc, struct cam_sim *sim,
+    union ccb *ccb)
+{
+	struct ccb_hdr *ccbh;
+	struct ccb_scsiio *csio;
+	int error;
+
+	ccbh = &ccb->ccb_h;
+	csio = &ccb->csio;
+
+	if (csio->cdb_len > VIRTIO_SCSI_CDB_SIZE) {
+		error = EINVAL;
+		ccbh->status = CAM_REQ_INVALID;
+		goto done;
+	}
+
+	error = vtscsi_start_scsi_cmd(sc, ccb);
+
+done:
+	if (error) {
+		vtscsi_dprintf(sc, VTSCSI_ERROR,
+		    "error=%d ccb=%p status=%#x\n", error, ccb, ccbh->status);
+		xpt_done(ccb);
+	}
+}
+
+static void
+vtscsi_cam_get_tran_settings(struct vtscsi_softc *sc, union ccb *ccb)
+{
+	struct ccb_trans_settings *cts;
+	struct ccb_trans_settings_scsi *scsi;
+
+	cts = &ccb->cts;
+	scsi = &cts->proto_specific.scsi;
+
+	cts->protocol = PROTO_SCSI;
+	cts->protocol_version = SCSI_REV_SPC3;
+	cts->transport = XPORT_SAS;
+	cts->transport_version = 0;
+
+	scsi->valid = CTS_SCSI_VALID_TQ;
+	scsi->flags = CTS_SCSI_FLAGS_TAG_ENB;
+
+	ccb->ccb_h.status = CAM_REQ_CMP;
+	xpt_done(ccb);
+}
+
+static void
+vtscsi_cam_reset_bus(struct vtscsi_softc *sc, union ccb *ccb)
+{
+	int error;
+
+	error = vtscsi_reset_bus(sc);
+	if (error == 0)
+		ccb->ccb_h.status = CAM_REQ_CMP;
+	else
+		ccb->ccb_h.status = CAM_REQ_CMP_ERR;
+
+	vtscsi_dprintf(sc, VTSCSI_TRACE, "error=%d ccb=%p status=%#x\n",
+	    error, ccb, ccb->ccb_h.status);
+
+	xpt_done(ccb);
+}
+
+static void
+vtscsi_cam_reset_dev(struct vtscsi_softc *sc, union ccb *ccb)
+{
+	struct ccb_hdr *ccbh;
+	struct vtscsi_request *req;
+	int error;
+
+	ccbh = &ccb->ccb_h;
+
+	req = vtscsi_dequeue_request(sc);
+	if (req == NULL) {
+		error = EAGAIN;
+		vtscsi_freeze_simq(sc, VTSCSI_REQUEST);
+		goto fail;
+	}
+
+	req->vsr_ccb = ccb;
+
+	error = vtscsi_execute_reset_dev_cmd(sc, req);
+	if (error == 0)
+		return;
+
+	vtscsi_enqueue_request(sc, req);
+
+fail:
+	vtscsi_dprintf(sc, VTSCSI_ERROR, "error=%d req=%p ccb=%p\n",
+	    error, req, ccb);
+
+	if (error == EAGAIN)
+		ccbh->status = CAM_RESRC_UNAVAIL;
+	else
+		ccbh->status = CAM_REQ_CMP_ERR;
+
+	xpt_done(ccb);
+}
+
+static void
+vtscsi_cam_abort(struct vtscsi_softc *sc, union ccb *ccb)
+{
+	struct vtscsi_request *req;
+	struct ccb_hdr *ccbh;
+	int error;
+
+	ccbh = &ccb->ccb_h;
+
+	req = vtscsi_dequeue_request(sc);
+	if (req == NULL) {
+		error = EAGAIN;
+		vtscsi_freeze_simq(sc, VTSCSI_REQUEST);
+		goto fail;
+	}
+
+	req->vsr_ccb = ccb;
+
+	error = vtscsi_execute_abort_task_cmd(sc, req);
+	if (error == 0)
+		return;
+
+	vtscsi_enqueue_request(sc, req);
+
+fail:
+	vtscsi_dprintf(sc, VTSCSI_ERROR, "error=%d req=%p ccb=%p\n",
+	    error, req, ccb);
+
+	if (error == EAGAIN)
+		ccbh->status = CAM_RESRC_UNAVAIL;
+	else
+		ccbh->status = CAM_REQ_CMP_ERR;
+
+	xpt_done(ccb);
+}
+
+static void
+vtscsi_cam_path_inquiry(struct vtscsi_softc *sc, struct cam_sim *sim,
+    union ccb *ccb)
+{
+	device_t dev;
+	struct ccb_pathinq *cpi;
+
+	dev = sc->vtscsi_dev;
+	cpi = &ccb->cpi;
+
+	vtscsi_dprintf(sc, VTSCSI_TRACE, "sim=%p ccb=%p\n", sim, ccb);
+
+	cpi->version_num = 1;
+	cpi->hba_inquiry = PI_TAG_ABLE;
+	cpi->target_sprt = 0;
+	cpi->hba_misc = PIM_SEQSCAN;
+	if (vtscsi_bus_reset_disable != 0)
+		cpi->hba_misc |= PIM_NOBUSRESET;
+	cpi->hba_eng_cnt = 0;
+
+	cpi->max_target = sc->vtscsi_max_target;
+	cpi->max_lun = sc->vtscsi_max_lun;
+	cpi->initiator_id = VTSCSI_INITIATOR_ID;
+
+	strncpy(cpi->sim_vid, "FreeBSD", SIM_IDLEN);
+	strncpy(cpi->hba_vid, "VirtIO", HBA_IDLEN);
+	strncpy(cpi->dev_name, cam_sim_name(sim), DEV_IDLEN);
+
+	cpi->unit_number = cam_sim_unit(sim);
+	cpi->bus_id = cam_sim_bus(sim);
+
+	cpi->base_transfer_speed = 300000;
+
+	cpi->protocol = PROTO_SCSI;
+	cpi->protocol_version = SCSI_REV_SPC3;
+	cpi->transport = XPORT_SAS;
+	cpi->transport_version = 0;
+
+	cpi->maxio = (sc->vtscsi_max_nsegs - VTSCSI_MIN_SEGMENTS - 1) *
+	    PAGE_SIZE;
+
+	ccb->ccb_h.status = CAM_REQ_CMP;
+	xpt_done(ccb);
+}
+
+static int
+vtscsi_sg_append_scsi_buf(struct vtscsi_softc *sc, struct sglist *sg,
+    struct ccb_scsiio *csio)
+{
+	struct ccb_hdr *ccbh;
+	struct bus_dma_segment *dseg;
+	int i, error;
+
+	ccbh = &csio->ccb_h;
+	error = 0;
+
+	if ((ccbh->flags & CAM_SCATTER_VALID) == 0) {
+
+		if ((ccbh->flags & CAM_DATA_PHYS) == 0)
+			error = sglist_append(sg,
+			    csio->data_ptr, csio->dxfer_len);
+		else
+			error = sglist_append_phys(sg,
+			    (vm_paddr_t)(vm_offset_t) csio->data_ptr,
+			    csio->dxfer_len);
+	} else {
+
+		for (i = 0; i < csio->sglist_cnt && error == 0; i++) {
+			dseg = &((struct bus_dma_segment *)csio->data_ptr)[i];
+
+			if ((ccbh->flags & CAM_SG_LIST_PHYS) == 0)
+				error = sglist_append(sg,
+				    (void *)(vm_offset_t) dseg->ds_addr,
+				    dseg->ds_len);
+			else
+				error = sglist_append_phys(sg,
+				    (vm_paddr_t) dseg->ds_addr, dseg->ds_len);
+		}
+	}
+
+	return (error);
+}
+
+static int
+vtscsi_fill_scsi_cmd_sglist(struct vtscsi_softc *sc, struct vtscsi_request *req,
+    int *readable, int *writable)
+{
+	struct sglist *sg;
+	struct ccb_hdr *ccbh;
+	struct ccb_scsiio *csio;
+	struct virtio_scsi_cmd_req *cmd_req;
+	struct virtio_scsi_cmd_resp *cmd_resp;
+	int error;
+
+	sg = sc->vtscsi_sglist;
+	csio = &req->vsr_ccb->csio;
+	ccbh = &csio->ccb_h;
+	cmd_req = &req->vsr_cmd_req;
+	cmd_resp = &req->vsr_cmd_resp;
+
+	sglist_reset(sg);
+
+	sglist_append(sg, cmd_req, sizeof(struct virtio_scsi_cmd_req));
+	if ((ccbh->flags & CAM_DIR_MASK) == CAM_DIR_OUT) {
+		error = vtscsi_sg_append_scsi_buf(sc, sg, csio);
+		/* At least one segment must be left for the response. */
+		if (error || sg->sg_nseg == sg->sg_maxseg)
+			goto fail;
+	}
+
+	*readable = sg->sg_nseg;
+
+	sglist_append(sg, cmd_resp, sizeof(struct virtio_scsi_cmd_resp));
+	if ((ccbh->flags & CAM_DIR_MASK) == CAM_DIR_IN) {
+		error = vtscsi_sg_append_scsi_buf(sc, sg, csio);
+		if (error)
+			goto fail;
+	}
+
+	*writable = sg->sg_nseg - *readable;
+
+	vtscsi_dprintf(sc, VTSCSI_TRACE, "req=%p ccb=%p readable=%d "
+	    "writable=%d\n", req, ccbh, *readable, *writable);
+
+	return (0);
+
+fail:
+	/*
+	 * This should never happen unless maxio was incorrectly set.
+	 */
+	vtscsi_set_ccb_status(ccbh, CAM_REQ_TOO_BIG, 0);
+
+	vtscsi_dprintf(sc, VTSCSI_ERROR, "error=%d req=%p ccb=%p "
+	    "nseg=%d maxseg=%d\n",
+	    error, req, ccbh, sg->sg_nseg, sg->sg_maxseg);
+
+	return (EFBIG);
+}
+
+static int
+vtscsi_execute_scsi_cmd(struct vtscsi_softc *sc, struct vtscsi_request *req)
+{
+	struct sglist *sg;
+	struct virtqueue *vq;
+	struct ccb_scsiio *csio;
+	struct ccb_hdr *ccbh;
+	struct virtio_scsi_cmd_req *cmd_req;
+	struct virtio_scsi_cmd_resp *cmd_resp;
+	int readable, writable, error;
+
+	sg = sc->vtscsi_sglist;
+	vq = sc->vtscsi_request_vq;
+	csio = &req->vsr_ccb->csio;
+	ccbh = &csio->ccb_h;
+	cmd_req = &req->vsr_cmd_req;
+	cmd_resp = &req->vsr_cmd_resp;
+
+	vtscsi_init_scsi_cmd_req(csio, cmd_req);
+
+	error = vtscsi_fill_scsi_cmd_sglist(sc, req, &readable, &writable);
+	if (error)
+		return (error);
+
+	req->vsr_complete = vtscsi_complete_scsi_cmd;
+	cmd_resp->response = -1;
+
+	error = virtqueue_enqueue(vq, req, sg, readable, writable);
+	if (error) {
+		vtscsi_dprintf(sc, VTSCSI_ERROR,
+		    "enqueue error=%d req=%p ccb=%p\n", error, req, ccbh);
+
+		ccbh->status = CAM_REQUEUE_REQ;
+		vtscsi_freeze_simq(sc, VTSCSI_REQUEST_VQ);
+		return (error);
+	}
+
+	ccbh->status |= CAM_SIM_QUEUED;
+	ccbh->ccbh_vtscsi_req = req;
+
+	virtqueue_notify(vq);
+
+	if (ccbh->timeout != CAM_TIME_INFINITY) {
+		req->vsr_flags |= VTSCSI_REQ_FLAG_TIMEOUT_SET;
+		callout_reset(&req->vsr_callout, ccbh->timeout * hz / 1000,
+		    vtscsi_timedout_scsi_cmd, req);
+	}
+
+	vtscsi_dprintf_req(req, VTSCSI_TRACE, "enqueued req=%p ccb=%p\n",
+	    req, ccbh);
+
+	return (0);
+}
+
+static int
+vtscsi_start_scsi_cmd(struct vtscsi_softc *sc, union ccb *ccb)
+{
+	struct vtscsi_request *req;
+	int error;
+
+	req = vtscsi_dequeue_request(sc);
+	if (req == NULL) {
+		ccb->ccb_h.status = CAM_REQUEUE_REQ;
+		vtscsi_freeze_simq(sc, VTSCSI_REQUEST);
+		return (ENOBUFS);
+	}
+
+	req->vsr_ccb = ccb;
+
+	error = vtscsi_execute_scsi_cmd(sc, req);
+	if (error)
+		vtscsi_enqueue_request(sc, req);
+
+	return (error);
+}
+
+static void
+vtscsi_complete_abort_timedout_scsi_cmd(struct vtscsi_softc *sc,
+    struct vtscsi_request *req)
+{
+	struct virtio_scsi_ctrl_tmf_resp *tmf_resp;
+	struct vtscsi_request *to_req;
+	uint8_t response;
+
+	tmf_resp = &req->vsr_tmf_resp;
+	response = tmf_resp->response;
+	to_req = req->vsr_timedout_req;
+
+	vtscsi_dprintf(sc, VTSCSI_TRACE, "req=%p to_req=%p response=%d\n",
+	    req, to_req, response);
+
+	vtscsi_enqueue_request(sc, req);
+
+	/*
+	 * The timedout request could have completed between when the
+	 * abort task was sent and when the host processed it.
+	 */
+	if (to_req->vsr_state != VTSCSI_REQ_STATE_TIMEDOUT)
+		return;
+
+	/* The timedout request was successfully aborted. */
+	if (response == VIRTIO_SCSI_S_FUNCTION_COMPLETE)
+		return;
+
+	/* Don't bother if the device is going away. */
+	if (sc->vtscsi_flags & VTSCSI_FLAG_DETACH)
+		return;
+
+	/* The timedout request will be aborted by the reset. */
+	if (sc->vtscsi_flags & VTSCSI_FLAG_RESET)
+		return;
+
+	vtscsi_reset_bus(sc);
+}
+
+static int
+vtscsi_abort_timedout_scsi_cmd(struct vtscsi_softc *sc,
+    struct vtscsi_request *to_req)
+{
+	struct sglist *sg;
+	struct ccb_hdr *to_ccbh;
+	struct vtscsi_request *req;
+	struct virtio_scsi_ctrl_tmf_req *tmf_req;
+	struct virtio_scsi_ctrl_tmf_resp *tmf_resp;
+	int error;
+
+	sg = sc->vtscsi_sglist;
+	to_ccbh = &to_req->vsr_ccb->ccb_h;
+
+	req = vtscsi_dequeue_request(sc);
+	if (req == NULL) {
+		error = ENOBUFS;
+		goto fail;
+	}
+
+	tmf_req = &req->vsr_tmf_req;
+	tmf_resp = &req->vsr_tmf_resp;
+
+	vtscsi_init_ctrl_tmf_req(to_ccbh, VIRTIO_SCSI_T_TMF_ABORT_TASK,
+	    (uintptr_t) to_ccbh, tmf_req);
+
+	sglist_reset(sg);
+	sglist_append(sg, tmf_req, sizeof(struct virtio_scsi_ctrl_tmf_req));
+	sglist_append(sg, tmf_resp, sizeof(struct virtio_scsi_ctrl_tmf_resp));
+
+	req->vsr_timedout_req = to_req;
+	req->vsr_complete = vtscsi_complete_abort_timedout_scsi_cmd;
+	tmf_resp->response = -1;
+
+	error = vtscsi_execute_ctrl_req(sc, req, sg, 1, 1,
+	    VTSCSI_EXECUTE_ASYNC);
+	if (error == 0)
+		return (0);
+
+	vtscsi_enqueue_request(sc, req);
+
+fail:
+	vtscsi_dprintf(sc, VTSCSI_ERROR, "error=%d req=%p "
+	    "timedout req=%p ccb=%p\n", error, req, to_req, to_ccbh);
+
+	return (error);
+}
+
+static void
+vtscsi_timedout_scsi_cmd(void *xreq)
+{
+	struct vtscsi_softc *sc;
+	struct vtscsi_request *to_req;
+
+	to_req = xreq;
+	sc = to_req->vsr_softc;
+
+	vtscsi_dprintf(sc, VTSCSI_INFO, "timedout req=%p ccb=%p state=%#x\n",
+	    to_req, to_req->vsr_ccb, to_req->vsr_state);
+
+	/* Don't bother if the device is going away. */
+	if (sc->vtscsi_flags & VTSCSI_FLAG_DETACH)
+		return;
+
+	/*
+	 * Bail if the request is not in use. We likely raced when
+	 * stopping the callout handler or it has already been aborted.
+	 */
+	if (to_req->vsr_state != VTSCSI_REQ_STATE_INUSE ||
+	    (to_req->vsr_flags & VTSCSI_REQ_FLAG_TIMEOUT_SET) == 0)
+		return;
+
+	/*
+	 * Complete the request queue in case the timedout request is
+	 * actually just pending.
+	 */
+	vtscsi_complete_vq(sc, sc->vtscsi_request_vq);
+	if (to_req->vsr_state == VTSCSI_REQ_STATE_FREE)
+		return;
+
+	sc->vtscsi_stats.scsi_cmd_timeouts++;
+	to_req->vsr_state = VTSCSI_REQ_STATE_TIMEDOUT;
+
+	if (vtscsi_abort_timedout_scsi_cmd(sc, to_req) == 0)
+		return;
+
+	vtscsi_dprintf(sc, VTSCSI_ERROR, "resetting bus\n");
+	vtscsi_reset_bus(sc);
+}
+
+static cam_status
+vtscsi_scsi_cmd_cam_status(struct virtio_scsi_cmd_resp *cmd_resp)
+{
+	cam_status status;
+
+	switch (cmd_resp->response) {
+	case VIRTIO_SCSI_S_OK:
+		status = CAM_REQ_CMP;
+		break;
+	case VIRTIO_SCSI_S_OVERRUN:
+		status = CAM_DATA_RUN_ERR;
+		break;
+	case VIRTIO_SCSI_S_ABORTED:
+		status = CAM_REQ_ABORTED;
+		break;
+	case VIRTIO_SCSI_S_BAD_TARGET:
+		status = CAM_TID_INVALID;
+		break;
+	case VIRTIO_SCSI_S_RESET:
+		status = CAM_SCSI_BUS_RESET;
+		break;
+	case VIRTIO_SCSI_S_BUSY:
+		status = CAM_SCSI_BUSY;
+		break;
+	case VIRTIO_SCSI_S_TRANSPORT_FAILURE:
+	case VIRTIO_SCSI_S_TARGET_FAILURE:
+	case VIRTIO_SCSI_S_NEXUS_FAILURE:
+		status = CAM_SCSI_IT_NEXUS_LOST;
+		break;
+	default: /* VIRTIO_SCSI_S_FAILURE */
+		status = CAM_REQ_CMP_ERR;
+		break;
+	}
+
+	return (status);
+}
+
+static cam_status
+vtscsi_complete_scsi_cmd_response(struct vtscsi_softc *sc,
+    struct ccb_scsiio *csio, struct virtio_scsi_cmd_resp *cmd_resp)
+{
+	cam_status status;
+
+	csio->scsi_status = cmd_resp->status;
+	csio->resid = cmd_resp->resid;
+
+	if (csio->scsi_status == SCSI_STATUS_OK)
+		status = CAM_REQ_CMP;
+	else
+		status = CAM_SCSI_STATUS_ERROR;
+
+	if (cmd_resp->sense_len > 0) {
+		status |= CAM_AUTOSNS_VALID;
+
+		if (cmd_resp->sense_len < csio->sense_len)
+			csio->sense_resid = csio->sense_len -
+			    cmd_resp->sense_len;
+		else
+			csio->sense_resid = 0;
+
+		bzero(&csio->sense_data, sizeof(csio->sense_data));
+		memcpy(cmd_resp->sense, &csio->sense_data,
+		    csio->sense_len - csio->sense_resid);
+	}
+
+	vtscsi_dprintf(sc, status == CAM_REQ_CMP ? VTSCSI_TRACE : VTSCSI_ERROR,
+	    "ccb=%p scsi_status=%#x resid=%u sense_resid=%u\n",
+	    csio, csio->scsi_status, csio->resid, csio->sense_resid);
+
+	return (status);
+}
+
+static void
+vtscsi_complete_scsi_cmd(struct vtscsi_softc *sc, struct vtscsi_request *req)
+{
+	struct ccb_hdr *ccbh;
+	struct ccb_scsiio *csio;
+	struct virtio_scsi_cmd_resp *cmd_resp;
+	cam_status status;
+
+	csio = &req->vsr_ccb->csio;
+	ccbh = &csio->ccb_h;
+	cmd_resp = &req->vsr_cmd_resp;
+
+	KASSERT(ccbh->ccbh_vtscsi_req == req,
+	    ("ccb %p req mismatch %p/%p", ccbh, ccbh->ccbh_vtscsi_req, req));
+
+	if (req->vsr_flags & VTSCSI_REQ_FLAG_TIMEOUT_SET)
+		callout_stop(&req->vsr_callout);
+
+	status = vtscsi_scsi_cmd_cam_status(cmd_resp);
+	if (status == CAM_REQ_ABORTED) {
+		if (req->vsr_state == VTSCSI_REQ_STATE_TIMEDOUT)
+			status = CAM_CMD_TIMEOUT;
+	} else if (status == CAM_REQ_CMP)
+		status = vtscsi_complete_scsi_cmd_response(sc, csio, cmd_resp);
+
+	if ((status & CAM_STATUS_MASK) != CAM_REQ_CMP) {
+		status |= CAM_DEV_QFRZN;
+		xpt_freeze_devq(ccbh->path, 1);
+	}
+
+	if (vtscsi_thaw_simq(sc, VTSCSI_REQUEST | VTSCSI_REQUEST_VQ) != 0)
+		status |= CAM_RELEASE_SIMQ;
+
+	vtscsi_dprintf(sc, VTSCSI_TRACE, "req=%p ccb=%p status=%#x\n",
+	    req, ccbh, status);
+
+	ccbh->status = status;
+	xpt_done(req->vsr_ccb);
+	vtscsi_enqueue_request(sc, req);
+}
+
+static void
+vtscsi_poll_ctrl_req(struct vtscsi_softc *sc, struct vtscsi_request *req)
+{
+
+	/* XXX We probably shouldn't poll forever. */
+	req->vsr_flags |= VTSCSI_REQ_FLAG_POLLED;
+	do
+		vtscsi_complete_vq(sc, sc->vtscsi_control_vq);
+	while ((req->vsr_flags & VTSCSI_REQ_FLAG_COMPLETE) == 0);
+
+	req->vsr_flags &= ~VTSCSI_REQ_FLAG_POLLED;
+}
+
+static int
+vtscsi_execute_ctrl_req(struct vtscsi_softc *sc, struct vtscsi_request *req,
+    struct sglist *sg, int readable, int writable, int flag)
+{
+	struct virtqueue *vq;
+	int error;
+
+	vq = sc->vtscsi_control_vq;
+
+	MPASS(flag == VTSCSI_EXECUTE_POLL || req->vsr_complete != NULL);
+
+	error = virtqueue_enqueue(vq, req, sg, readable, writable);
+	if (error) {
+		/*
+		 * Return EAGAIN when the virtqueue does not have enough
+		 * descriptors available.
+		 */
+		if (error == ENOSPC || error == EMSGSIZE)
+			error = EAGAIN;
+
+		return (error);
+	}
+
+	virtqueue_notify(vq);
+	if (flag == VTSCSI_EXECUTE_POLL)
+		vtscsi_poll_ctrl_req(sc, req);
+
+	return (0);
+}
+
+static void
+vtscsi_complete_abort_task_cmd(struct vtscsi_softc *sc,
+    struct vtscsi_request *req)
+{
+	union ccb *ccb;
+	struct ccb_hdr *ccbh;
+	struct virtio_scsi_ctrl_tmf_resp *tmf_resp;
+
+	ccb = req->vsr_ccb;
+	ccbh = &ccb->ccb_h;
+	tmf_resp = &req->vsr_tmf_resp;
+
+	switch (tmf_resp->response) {
+	case VIRTIO_SCSI_S_FUNCTION_COMPLETE:
+		ccbh->status = CAM_REQ_CMP;
+		break;
+	case VIRTIO_SCSI_S_FUNCTION_REJECTED:
+		ccbh->status = CAM_UA_ABORT;
+		break;
+	default:
+		ccbh->status = CAM_REQ_CMP_ERR;
+		break;
+	}
+
+	xpt_done(ccb);
+	vtscsi_enqueue_request(sc, req);
+}
+
+static int
+vtscsi_execute_abort_task_cmd(struct vtscsi_softc *sc,
+    struct vtscsi_request *req)
+{
+	struct sglist *sg;
+	struct ccb_abort *cab;
+	struct ccb_hdr *ccbh;
+	struct ccb_hdr *abort_ccbh;
+	struct vtscsi_request *abort_req;
+	struct virtio_scsi_ctrl_tmf_req *tmf_req;
+	struct virtio_scsi_ctrl_tmf_resp *tmf_resp;
+	int error;
+
+	sg = sc->vtscsi_sglist;
+	cab = &req->vsr_ccb->cab;
+	ccbh = &cab->ccb_h;
+	tmf_req = &req->vsr_tmf_req;
+	tmf_resp = &req->vsr_tmf_resp;
+
+	/* CCB header and request that's to be aborted. */
+	abort_ccbh = &cab->abort_ccb->ccb_h;
+	abort_req = abort_ccbh->ccbh_vtscsi_req;
+
+	if (abort_ccbh->func_code != XPT_SCSI_IO || abort_req == NULL) {
+		error = EINVAL;
+		goto fail;
+	}
+
+	/* Only attempt to abort requests that could be in-flight. */
+	if (abort_req->vsr_state != VTSCSI_REQ_STATE_INUSE) {
+		error = EALREADY;
+		goto fail;
+	}
+
+	abort_req->vsr_state = VTSCSI_REQ_STATE_ABORTED;
+	if (abort_req->vsr_flags & VTSCSI_REQ_FLAG_TIMEOUT_SET)
+		callout_stop(&abort_req->vsr_callout);
+
+	vtscsi_init_ctrl_tmf_req(ccbh, VIRTIO_SCSI_T_TMF_ABORT_TASK,
+	    (uintptr_t) abort_ccbh, tmf_req);
+
+	sglist_reset(sg);
+	sglist_append(sg, tmf_req, sizeof(struct virtio_scsi_ctrl_tmf_req));
+	sglist_append(sg, tmf_resp, sizeof(struct virtio_scsi_ctrl_tmf_resp));
+
+	req->vsr_complete = vtscsi_complete_abort_task_cmd;
+	tmf_resp->response = -1;
+
+	error = vtscsi_execute_ctrl_req(sc, req, sg, 1, 1,
+	    VTSCSI_EXECUTE_ASYNC);
+
+fail:
+	vtscsi_dprintf(sc, VTSCSI_TRACE, "error=%d req=%p abort_ccb=%p "
+	    "abort_req=%p\n", error, req, abort_ccbh, abort_req);
+
+	return (error);
+}
+
+static void
+vtscsi_complete_reset_dev_cmd(struct vtscsi_softc *sc,
+    struct vtscsi_request *req)
+{
+	union ccb *ccb;
+	struct ccb_hdr *ccbh;
+	struct virtio_scsi_ctrl_tmf_resp *tmf_resp;
+
+	ccb = req->vsr_ccb;
+	ccbh = &ccb->ccb_h;
+	tmf_resp = &req->vsr_tmf_resp;
+
+	vtscsi_dprintf(sc, VTSCSI_TRACE, "req=%p ccb=%p response=%d\n",
+	    req, ccb, tmf_resp->response);
+
+	if (tmf_resp->response == VIRTIO_SCSI_S_FUNCTION_COMPLETE) {
+		ccbh->status = CAM_REQ_CMP;
+		vtscsi_announce(sc, AC_SENT_BDR, ccbh->target_id,
+		    ccbh->target_lun);
+	} else
+		ccbh->status = CAM_REQ_CMP_ERR;
+
+	xpt_done(ccb);
+	vtscsi_enqueue_request(sc, req);
+}
+
+static int
+vtscsi_execute_reset_dev_cmd(struct vtscsi_softc *sc,
+    struct vtscsi_request *req)
+{
+	struct sglist *sg;
+	struct ccb_resetdev *crd;
+	struct ccb_hdr *ccbh;
+	struct virtio_scsi_ctrl_tmf_req *tmf_req;
+	struct virtio_scsi_ctrl_tmf_resp *tmf_resp;
+	uint32_t subtype;
+	int error;
+
+	sg = sc->vtscsi_sglist;
+	crd = &req->vsr_ccb->crd;
+	ccbh = &crd->ccb_h;
+	tmf_req = &req->vsr_tmf_req;
+	tmf_resp = &req->vsr_tmf_resp;
+
+	if (ccbh->target_lun == CAM_LUN_WILDCARD)
+		subtype = VIRTIO_SCSI_T_TMF_I_T_NEXUS_RESET;
+	else
+		subtype = VIRTIO_SCSI_T_TMF_LOGICAL_UNIT_RESET;
+
+	vtscsi_init_ctrl_tmf_req(ccbh, subtype, 0, tmf_req);
+
+	sglist_reset(sg);
+	sglist_append(sg, tmf_req, sizeof(struct virtio_scsi_ctrl_tmf_req));
+	sglist_append(sg, tmf_resp, sizeof(struct virtio_scsi_ctrl_tmf_resp));
+
+	req->vsr_complete = vtscsi_complete_reset_dev_cmd;
+	tmf_resp->response = -1;
+
+	error = vtscsi_execute_ctrl_req(sc, req, sg, 1, 1,
+	    VTSCSI_EXECUTE_ASYNC);
+
+	vtscsi_dprintf(sc, VTSCSI_TRACE, "error=%d req=%p ccb=%p\n",
+	    error, req, ccbh);
+
+	return (error);
+}
+
+static void
+vtscsi_get_request_lun(uint8_t lun[], target_id_t *target_id, lun_id_t *lun_id)
+{
+
+	*target_id = lun[1];
+	*lun_id = (lun[2] << 8) | lun[3];
+}
+
+static void
+vtscsi_set_request_lun(struct ccb_hdr *ccbh, uint8_t lun[])
+{
+
+	lun[0] = 1;
+	lun[1] = ccbh->target_id;
+	lun[2] = 0x40 | ((ccbh->target_lun >> 8) & 0x3F);
+	lun[3] = (ccbh->target_lun >> 8) & 0xFF;
+}
+
+static void
+vtscsi_init_scsi_cmd_req(struct ccb_scsiio *csio,
+    struct virtio_scsi_cmd_req *cmd_req)
+{
+	uint8_t attr;
+
+	switch (csio->tag_action) {
+	case MSG_HEAD_OF_Q_TAG:
+		attr = VIRTIO_SCSI_S_HEAD;
+		break;
+	case MSG_ORDERED_Q_TAG:
+		attr = VIRTIO_SCSI_S_ORDERED;
+		break;
+	case MSG_ACA_TASK:
+		attr = VIRTIO_SCSI_S_ACA;
+		break;
+	default: /* MSG_SIMPLE_Q_TAG */
+		attr = VIRTIO_SCSI_S_SIMPLE;
+		break;
+	}
+
+	vtscsi_set_request_lun(&csio->ccb_h, cmd_req->lun);
+	cmd_req->tag = (uintptr_t) csio;
+	cmd_req->task_attr = attr;
+
+	memcpy(cmd_req->cdb,
+	    csio->ccb_h.flags & CAM_CDB_POINTER ?
+	        csio->cdb_io.cdb_ptr : csio->cdb_io.cdb_bytes,
+	    csio->cdb_len);
+}
+
+static void
+vtscsi_init_ctrl_tmf_req(struct ccb_hdr *ccbh, uint32_t subtype,
+    uintptr_t tag, struct virtio_scsi_ctrl_tmf_req *tmf_req)
+{
+
+	vtscsi_set_request_lun(ccbh, tmf_req->lun);
+
+	tmf_req->type = VIRTIO_SCSI_T_TMF;
+	tmf_req->subtype = subtype;
+	tmf_req->tag = tag;
+}
+
+static void
+vtscsi_freeze_simq(struct vtscsi_softc *sc, int reason)
+{
+	int frozen;
+
+	frozen = sc->vtscsi_frozen;
+
+	if (reason & VTSCSI_REQUEST &&
+	    (sc->vtscsi_frozen & VTSCSI_FROZEN_NO_REQUESTS) == 0)
+		sc->vtscsi_frozen |= VTSCSI_FROZEN_NO_REQUESTS;
+
+	if (reason & VTSCSI_REQUEST_VQ &&
+	    (sc->vtscsi_frozen & VTSCSI_FROZEN_REQUEST_VQ_FULL) == 0)
+		sc->vtscsi_frozen |= VTSCSI_FROZEN_REQUEST_VQ_FULL;
+
+	/* Freeze the SIMQ if transitioned to frozen. */
+	if (frozen == 0 && sc->vtscsi_frozen != 0) {
+		vtscsi_dprintf(sc, VTSCSI_INFO, "SIMQ frozen\n");
+		xpt_freeze_simq(sc->vtscsi_sim, 1);
+	}
+}
+
+static int
+vtscsi_thaw_simq(struct vtscsi_softc *sc, int reason)
+{
+	int thawed;
+
+	if (sc->vtscsi_frozen == 0 || reason == 0)
+		return (0);
+
+	if (reason & VTSCSI_REQUEST &&
+	    sc->vtscsi_frozen & VTSCSI_FROZEN_NO_REQUESTS)
+		sc->vtscsi_frozen &= ~VTSCSI_FROZEN_NO_REQUESTS;
+
+	if (reason & VTSCSI_REQUEST_VQ &&
+	    sc->vtscsi_frozen & VTSCSI_FROZEN_REQUEST_VQ_FULL)
+		sc->vtscsi_frozen &= ~VTSCSI_FROZEN_REQUEST_VQ_FULL;
+
+	thawed = sc->vtscsi_frozen == 0;
+	if (thawed != 0)
+		vtscsi_dprintf(sc, VTSCSI_INFO, "SIMQ thawed\n");
+
+	return (thawed);
+}
+
+static void
+vtscsi_announce(struct vtscsi_softc *sc, uint32_t ac_code,
+    target_id_t target_id, lun_id_t lun_id)
+{
+	struct cam_path *path;
+
+	/* Use the wildcard path from our softc for bus announcements. */
+	if (target_id == CAM_TARGET_WILDCARD && lun_id == CAM_LUN_WILDCARD) {
+		xpt_async(ac_code, sc->vtscsi_path, NULL);
+		return;
+	}
+
+	if (xpt_create_path(&path, NULL, cam_sim_path(sc->vtscsi_sim),
+	    target_id, lun_id) != CAM_REQ_CMP) {
+		vtscsi_dprintf(sc, VTSCSI_ERROR, "cannot create path\n");
+		return;
+	}
+
+	xpt_async(ac_code, path, NULL);
+	xpt_free_path(path);
+}
+
+static void
+vtscsi_execute_rescan(struct vtscsi_softc *sc, target_id_t target_id,
+    lun_id_t lun_id)
+{
+	union ccb *ccb;
+	cam_status status;
+
+	ccb = xpt_alloc_ccb_nowait();
+	if (ccb == NULL) {
+		vtscsi_dprintf(sc, VTSCSI_ERROR, "cannot allocate CCB\n");
+		return;
+	}
+
+	status = xpt_create_path(&ccb->ccb_h.path, xpt_periph,
+	    cam_sim_path(sc->vtscsi_sim), target_id, lun_id);
+	if (status != CAM_REQ_CMP) {
+		xpt_free_ccb(ccb);
+		return;
+	}
+
+	xpt_rescan(ccb);
+}
+
+static void
+vtscsi_execute_rescan_bus(struct vtscsi_softc *sc)
+{
+
+	vtscsi_execute_rescan(sc, CAM_TARGET_WILDCARD, CAM_LUN_WILDCARD);
+}
+
+static void
+vtscsi_transport_reset_event(struct vtscsi_softc *sc,
+    struct virtio_scsi_event *event)
+{
+	target_id_t target_id;
+	lun_id_t lun_id;
+
+	vtscsi_get_request_lun(event->lun, &target_id, &lun_id);
+
+	switch (event->reason) {
+	case VIRTIO_SCSI_EVT_RESET_RESCAN:
+	case VIRTIO_SCSI_EVT_RESET_REMOVED:
+		vtscsi_execute_rescan(sc, target_id, lun_id);
+		break;
+	default:
+		device_printf(sc->vtscsi_dev,
+		    "unhandled transport event reason: %d\n", event->reason);
+		break;
+	}
+}
+
+static void
+vtscsi_handle_event(struct vtscsi_softc *sc, struct virtio_scsi_event *event)
+{
+	int error;
+
+	if ((event->event & VIRTIO_SCSI_T_EVENTS_MISSED) == 0) {
+		switch (event->event) {
+		case VIRTIO_SCSI_T_TRANSPORT_RESET:
+			vtscsi_transport_reset_event(sc, event);
+			break;
+		default:
+			device_printf(sc->vtscsi_dev,
+			    "unhandled event: %d\n", event->event);
+			break;
+		}
+	} else
+		vtscsi_execute_rescan_bus(sc);
+
+	/*
+	 * This should always be successful since the buffer
+	 * was just dequeued.
+	 */
+	error = vtscsi_enqueue_event_buf(sc, event);
+	KASSERT(error == 0,
+	    ("cannot requeue event buffer: %d", error));
+}
+
+static int
+vtscsi_enqueue_event_buf(struct vtscsi_softc *sc,
+    struct virtio_scsi_event *event)
+{
+	struct sglist *sg;
+	struct virtqueue *vq;
+	int size, error;
+
+	sg = sc->vtscsi_sglist;
+	vq = sc->vtscsi_event_vq;
+	size = sc->vtscsi_event_buf_size;
+
+	bzero(event, size);
+
+	sglist_reset(sg);
+	error = sglist_append(sg, event, size);
+	if (error)
+		return (error);
+
+	error = virtqueue_enqueue(vq, event, sg, 0, sg->sg_nseg);
+	if (error)
+		return (error);
+
+	virtqueue_notify(vq);
+
+	return (0);
+}
+
+static int
+vtscsi_init_event_vq(struct vtscsi_softc *sc)
+{
+	struct virtio_scsi_event *event;
+	int i, size, error;
+
+	/*
+	 * The first release of QEMU with VirtIO SCSI support would crash
+	 * when attempting to notify the event virtqueue. This was fixed
+	 * when hotplug support was added.
+	 */
+	if (sc->vtscsi_flags & VTSCSI_FLAG_HOTPLUG)
+		size = sc->vtscsi_event_buf_size;
+	else
+		size = 0;
+
+	if (size < sizeof(struct virtio_scsi_event))
+		return (0);
+
+	for (i = 0; i < VTSCSI_NUM_EVENT_BUFS; i++) {
+		event = &sc->vtscsi_event_bufs[i];
+
+		error = vtscsi_enqueue_event_buf(sc, event);
+		if (error)
+			break;
+	}
+
+	/*
+	 * Even just one buffer is enough. Missed events are
+	 * denoted with the VIRTIO_SCSI_T_EVENTS_MISSED flag.
+	 */
+	if (i > 0)
+		error = 0;
+
+	return (error);
+}
+
+static void
+vtscsi_reinit_event_vq(struct vtscsi_softc *sc)
+{
+	struct virtio_scsi_event *event;
+	int i, error;
+
+	if ((sc->vtscsi_flags & VTSCSI_FLAG_HOTPLUG) == 0 ||
+	    sc->vtscsi_event_buf_size < sizeof(struct virtio_scsi_event))
+		return;
+
+	for (i = 0; i < VTSCSI_NUM_EVENT_BUFS; i++) {
+		event = &sc->vtscsi_event_bufs[i];
+
+		error = vtscsi_enqueue_event_buf(sc, event);
+		if (error)
+			break;
+	}
+
+	KASSERT(i > 0, ("cannot reinit event vq: %d", error));
+}
+
+static void
+vtscsi_drain_event_vq(struct vtscsi_softc *sc)
+{
+	struct virtqueue *vq;
+	int last;
+
+	vq = sc->vtscsi_event_vq;
+	last = 0;
+
+	while (virtqueue_drain(vq, &last) != NULL)
+		;
+
+	KASSERT(virtqueue_empty(vq), ("eventvq not empty"));
+}
+
+static void
+vtscsi_complete_vqs_locked(struct vtscsi_softc *sc)
+{
+
+	VTSCSI_LOCK_OWNED(sc);
+
+	if (sc->vtscsi_request_vq != NULL)
+		vtscsi_complete_vq(sc, sc->vtscsi_request_vq);
+	if (sc->vtscsi_control_vq != NULL)
+		vtscsi_complete_vq(sc, sc->vtscsi_control_vq);
+}
+
+static void
+vtscsi_complete_vqs(struct vtscsi_softc *sc)
+{
+
+	VTSCSI_LOCK(sc);
+	vtscsi_complete_vqs_locked(sc);
+	VTSCSI_UNLOCK(sc);
+}
+
+static void
+vtscsi_cancel_request(struct vtscsi_softc *sc, struct vtscsi_request *req)
+{
+	union ccb *ccb;
+	int detach;
+
+	ccb = req->vsr_ccb;
+
+	vtscsi_dprintf(sc, VTSCSI_TRACE, "req=%p ccb=%p\n", req, ccb);
+
+	/*
+	 * The callout must be drained when detaching since the request is
+	 * about to be freed. The VTSCSI_MTX must not be held for this in
+	 * case the callout is pending because there is a deadlock potential.
+	 * Otherwise, the virtqueue is being drained because of a bus reset
+	 * so we only need to attempt to stop the callouts.
+	 */
+	detach = (sc->vtscsi_flags & VTSCSI_FLAG_DETACH) != 0;
+	if (detach != 0)
+		VTSCSI_LOCK_NOTOWNED(sc);
+	else
+		VTSCSI_LOCK_OWNED(sc);
+
+	if (req->vsr_flags & VTSCSI_REQ_FLAG_TIMEOUT_SET) {
+		if (detach != 0)
+			callout_drain(&req->vsr_callout);
+		else
+			callout_stop(&req->vsr_callout);
+	}
+
+	if (ccb != NULL) {
+		if (detach != 0) {
+			VTSCSI_LOCK(sc);
+			ccb->ccb_h.status = CAM_NO_HBA;
+		} else
+			ccb->ccb_h.status = CAM_REQUEUE_REQ;
+		xpt_done(ccb);
+		if (detach != 0)
+			VTSCSI_UNLOCK(sc);
+	}
+
+	vtscsi_enqueue_request(sc, req);
+}
+
+static void
+vtscsi_drain_vq(struct vtscsi_softc *sc, struct virtqueue *vq)
+{
+	struct vtscsi_request *req;
+	int last;
+
+	last = 0;
+
+	vtscsi_dprintf(sc, VTSCSI_TRACE, "vq=%p\n", vq);
+
+	while ((req = virtqueue_drain(vq, &last)) != NULL)
+		vtscsi_cancel_request(sc, req);
+
+	KASSERT(virtqueue_empty(vq), ("virtqueue not empty"));
+}
+
+static void
+vtscsi_drain_vqs(struct vtscsi_softc *sc)
+{
+
+	if (sc->vtscsi_control_vq != NULL)
+		vtscsi_drain_vq(sc, sc->vtscsi_control_vq);
+	if (sc->vtscsi_request_vq != NULL)
+		vtscsi_drain_vq(sc, sc->vtscsi_request_vq);
+	if (sc->vtscsi_event_vq != NULL)
+		vtscsi_drain_event_vq(sc);
+}
+
+static void
+vtscsi_stop(struct vtscsi_softc *sc)
+{
+
+	vtscsi_disable_vqs_intr(sc);
+	virtio_stop(sc->vtscsi_dev);
+}
+
+static int
+vtscsi_reset_bus(struct vtscsi_softc *sc)
+{
+	int error;
+
+	VTSCSI_LOCK_OWNED(sc);
+
+	if (vtscsi_bus_reset_disable != 0) {
+		device_printf(sc->vtscsi_dev, "bus reset disabled\n");
+		return (0);
+	}
+
+	sc->vtscsi_flags |= VTSCSI_FLAG_RESET;
+
+	/*
+	 * vtscsi_stop() will cause the in-flight requests to be canceled.
+	 * Those requests are then completed here so CAM will retry them
+	 * after the reset is complete.
+	 */
+	vtscsi_stop(sc);
+	vtscsi_complete_vqs_locked(sc);
+
+	/* Rid the virtqueues of any remaining requests. */
+	vtscsi_drain_vqs(sc);
+
+	/*
+	 * Any resource shortage that froze the SIMQ cannot persist across
+	 * a bus reset so ensure it gets thawed here.
+	 */
+	if (vtscsi_thaw_simq(sc, VTSCSI_REQUEST | VTSCSI_REQUEST_VQ) != 0)
+		xpt_release_simq(sc->vtscsi_sim, 0);
+
+	error = vtscsi_reinit(sc);
+	if (error) {
+		device_printf(sc->vtscsi_dev,
+		    "reinitialization failed, stopping device...\n");
+		vtscsi_stop(sc);
+	} else
+		vtscsi_announce(sc, AC_BUS_RESET, CAM_TARGET_WILDCARD,
+		    CAM_LUN_WILDCARD);
+
+	sc->vtscsi_flags &= ~VTSCSI_FLAG_RESET;
+
+	return (error);
+}
+
+static void
+vtscsi_init_request(struct vtscsi_softc *sc, struct vtscsi_request *req)
+{
+
+#ifdef INVARIANTS
+	int req_nsegs, resp_nsegs;
+
+	req_nsegs = sglist_count(&req->vsr_ureq, sizeof(req->vsr_ureq));
+	resp_nsegs = sglist_count(&req->vsr_uresp, sizeof(req->vsr_uresp));
+
+	KASSERT(req_nsegs == 1, ("request crossed page boundary"));
+	KASSERT(resp_nsegs == 1, ("response crossed page boundary"));
+#endif
+
+	req->vsr_softc = sc;
+	callout_init_mtx(&req->vsr_callout, VTSCSI_MTX(sc), 0);
+}
+
+static int
+vtscsi_alloc_requests(struct vtscsi_softc *sc)
+{
+	struct vtscsi_request *req;
+	int i, nreqs;
+
+	/*
+	 * Commands destined for either the request or control queues come
+	 * from the same SIM queue. Use the size of the request virtqueue
+	 * as it (should) be much more frequently used. Some additional
+	 * requests are allocated for internal (TMF) use.
+	 */
+	nreqs = virtqueue_size(sc->vtscsi_request_vq);
+	if ((sc->vtscsi_flags & VTSCSI_FLAG_INDIRECT) == 0)
+		nreqs /= VTSCSI_MIN_SEGMENTS;
+	nreqs += VTSCSI_RESERVED_REQUESTS;
+
+	for (i = 0; i < nreqs; i++) {
+		req = malloc(sizeof(struct vtscsi_request), M_DEVBUF,
+		    M_NOWAIT);
+		if (req == NULL)
+			return (ENOMEM);
+
+		vtscsi_init_request(sc, req);
+
+		sc->vtscsi_nrequests++;
+		vtscsi_enqueue_request(sc, req);
+	}
+
+	return (0);
+}
+
+static void
+vtscsi_free_requests(struct vtscsi_softc *sc)
+{
+	struct vtscsi_request *req;
+
+	while ((req = vtscsi_dequeue_request(sc)) != NULL) {
+		KASSERT(callout_active(&req->vsr_callout) == 0,
+		    ("request callout still active"));
+
+		sc->vtscsi_nrequests--;
+		free(req, M_DEVBUF);
+	}
+
+	KASSERT(sc->vtscsi_nrequests == 0, ("leaked requests: %d",
+	    sc->vtscsi_nrequests));
+}
+
+static void
+vtscsi_enqueue_request(struct vtscsi_softc *sc, struct vtscsi_request *req)
+{
+
+	KASSERT(req->vsr_softc == sc,
+	    ("non-matching request vsr_softc %p/%p", req->vsr_softc, sc));
+
+	vtscsi_dprintf(sc, VTSCSI_TRACE, "req=%p\n", req);
+
+	/* A request is available so the SIMQ could be released. */
+	if (vtscsi_thaw_simq(sc, VTSCSI_REQUEST) != 0)
+		xpt_release_simq(sc->vtscsi_sim, 1);
+
+	req->vsr_ccb = NULL;
+	req->vsr_complete = NULL;
+	req->vsr_ptr0 = NULL;
+	req->vsr_state = VTSCSI_REQ_STATE_FREE;
+	req->vsr_flags = 0;
+
+	bzero(&req->vsr_ureq, sizeof(req->vsr_ureq));
+	bzero(&req->vsr_uresp, sizeof(req->vsr_uresp));
+
+	/*
+	 * We insert at the tail of the queue in order to make it
+	 * very unlikely a request will be reused if we race with
+	 * stopping its callout handler.
+	 */
+	TAILQ_INSERT_TAIL(&sc->vtscsi_req_free, req, vsr_link);
+}
+
+static struct vtscsi_request *
+vtscsi_dequeue_request(struct vtscsi_softc *sc)
+{
+	struct vtscsi_request *req;
+
+	req = TAILQ_FIRST(&sc->vtscsi_req_free);
+	if (req != NULL) {
+		req->vsr_state = VTSCSI_REQ_STATE_INUSE;
+		TAILQ_REMOVE(&sc->vtscsi_req_free, req, vsr_link);
+	} else
+		sc->vtscsi_stats.dequeue_no_requests++;
+
+	vtscsi_dprintf(sc, VTSCSI_TRACE, "req=%p\n", req);
+
+	return (req);
+}
+
+static void
+vtscsi_complete_request(struct vtscsi_request *req)
+{
+
+	if (req->vsr_flags & VTSCSI_REQ_FLAG_POLLED)
+		req->vsr_flags |= VTSCSI_REQ_FLAG_COMPLETE;
+
+	if (req->vsr_complete != NULL)
+		req->vsr_complete(req->vsr_softc, req);
+}
+
+static void
+vtscsi_complete_vq(struct vtscsi_softc *sc, struct virtqueue *vq)
+{
+	struct vtscsi_request *req;
+
+	VTSCSI_LOCK_OWNED(sc);
+
+	while ((req = virtqueue_dequeue(vq, NULL)) != NULL)
+		vtscsi_complete_request(req);
+}
+
+static void
+vtscsi_control_vq_task(void *arg, int pending)
+{
+	struct vtscsi_softc *sc;
+	struct virtqueue *vq;
+
+	sc = arg;
+	vq = sc->vtscsi_control_vq;
+
+	VTSCSI_LOCK(sc);
+
+	vtscsi_complete_vq(sc, sc->vtscsi_control_vq);
+
+	if (virtqueue_enable_intr(vq) != 0) {
+		virtqueue_disable_intr(vq);
+		VTSCSI_UNLOCK(sc);
+		taskqueue_enqueue_fast(sc->vtscsi_tq,
+		    &sc->vtscsi_control_intr_task);
+		return;
+	}
+
+	VTSCSI_UNLOCK(sc);
+}
+
+static void
+vtscsi_event_vq_task(void *arg, int pending)
+{
+	struct vtscsi_softc *sc;
+	struct virtqueue *vq;
+	struct virtio_scsi_event *event;
+
+	sc = arg;
+	vq = sc->vtscsi_event_vq;
+
+	VTSCSI_LOCK(sc);
+
+	while ((event = virtqueue_dequeue(vq, NULL)) != NULL)
+		vtscsi_handle_event(sc, event);
+
+	if (virtqueue_enable_intr(vq) != 0) {
+		virtqueue_disable_intr(vq);
+		VTSCSI_UNLOCK(sc);
+		taskqueue_enqueue_fast(sc->vtscsi_tq,
+		    &sc->vtscsi_control_intr_task);
+		return;
+	}
+
+	VTSCSI_UNLOCK(sc);
+}
+
+static void
+vtscsi_request_vq_task(void *arg, int pending)
+{
+	struct vtscsi_softc *sc;
+	struct virtqueue *vq;
+
+	sc = arg;
+	vq = sc->vtscsi_request_vq;
+
+	VTSCSI_LOCK(sc);
+
+	vtscsi_complete_vq(sc, sc->vtscsi_request_vq);
+
+	if (virtqueue_enable_intr(vq) != 0) {
+		virtqueue_disable_intr(vq);
+		VTSCSI_UNLOCK(sc);
+		taskqueue_enqueue_fast(sc->vtscsi_tq,
+		    &sc->vtscsi_request_intr_task);
+		return;
+	}
+
+	VTSCSI_UNLOCK(sc);
+}
+
+static int
+vtscsi_control_vq_intr(void *xsc)
+{
+	struct vtscsi_softc *sc;
+
+	sc = xsc;
+
+	virtqueue_disable_intr(sc->vtscsi_control_vq);
+	taskqueue_enqueue_fast(sc->vtscsi_tq,
+	    &sc->vtscsi_control_intr_task);
+
+	return (1);
+}
+
+static int
+vtscsi_event_vq_intr(void *xsc)
+{
+	struct vtscsi_softc *sc;
+
+	sc = xsc;
+
+	virtqueue_disable_intr(sc->vtscsi_event_vq);
+	taskqueue_enqueue_fast(sc->vtscsi_tq,
+	    &sc->vtscsi_event_intr_task);
+
+	return (1);
+}
+
+static int
+vtscsi_request_vq_intr(void *xsc)
+{
+	struct vtscsi_softc *sc;
+
+	sc = xsc;
+
+	virtqueue_disable_intr(sc->vtscsi_request_vq);
+	taskqueue_enqueue_fast(sc->vtscsi_tq,
+	    &sc->vtscsi_request_intr_task);
+
+	return (1);
+}
+
+static void
+vtscsi_disable_vqs_intr(struct vtscsi_softc *sc)
+{
+
+	virtqueue_disable_intr(sc->vtscsi_control_vq);
+	virtqueue_disable_intr(sc->vtscsi_event_vq);
+	virtqueue_disable_intr(sc->vtscsi_request_vq);
+}
+
+static void
+vtscsi_enable_vqs_intr(struct vtscsi_softc *sc)
+{
+
+	virtqueue_enable_intr(sc->vtscsi_control_vq);
+	virtqueue_enable_intr(sc->vtscsi_event_vq);
+	virtqueue_enable_intr(sc->vtscsi_request_vq);
+}
+
+static void
+vtscsi_get_tunables(struct vtscsi_softc *sc)
+{
+	char tmpstr[64];
+
+	TUNABLE_INT_FETCH("hw.vtscsi.debug_level", &sc->vtscsi_debug);
+
+	snprintf(tmpstr, sizeof(tmpstr), "dev.vtscsi.%d.debug_level",
+	    device_get_unit(sc->vtscsi_dev));
+	TUNABLE_INT_FETCH(tmpstr, &sc->vtscsi_debug);
+}
+
+static void
+vtscsi_add_sysctl(struct vtscsi_softc *sc)
+{
+	device_t dev;
+	struct vtscsi_statistics *stats;
+        struct sysctl_ctx_list *ctx;
+	struct sysctl_oid *tree;
+	struct sysctl_oid_list *child;
+
+	dev = sc->vtscsi_dev;
+	stats = &sc->vtscsi_stats;
+	ctx = device_get_sysctl_ctx(dev);
+	tree = device_get_sysctl_tree(dev);
+	child = SYSCTL_CHILDREN(tree);
+
+	SYSCTL_ADD_INT(ctx, child, OID_AUTO, "debug_level",
+	    CTLFLAG_RW, &sc->vtscsi_debug, 0,
+	    "Debug level");
+
+	SYSCTL_ADD_ULONG(ctx, child, OID_AUTO, "scsi_cmd_timeouts",
+	    CTLFLAG_RD, &stats->scsi_cmd_timeouts,
+	    "SCSI command timeouts");
+	SYSCTL_ADD_ULONG(ctx, child, OID_AUTO, "dequeue_no_requests",
+	    CTLFLAG_RD, &stats->dequeue_no_requests,
+	    "No available requests to dequeue");
+}
+
+static void
+vtscsi_printf_req(struct vtscsi_request *req, const char *func,
+    const char *fmt, ...)
+{
+	struct vtscsi_softc *sc;
+	union ccb *ccb;
+	struct sbuf sb;
+	va_list ap;
+	char str[192];
+	char path_str[64];
+
+	if (req == NULL)
+		return;
+
+	sc = req->vsr_softc;
+	ccb = req->vsr_ccb;
+
+	va_start(ap, fmt);
+	sbuf_new(&sb, str, sizeof(str), 0);
+
+	if (ccb == NULL) {
+		sbuf_printf(&sb, "(noperiph:%s%d:%u): ",
+		    cam_sim_name(sc->vtscsi_sim), cam_sim_unit(sc->vtscsi_sim),
+		    cam_sim_bus(sc->vtscsi_sim));
+	} else {
+		xpt_path_string(ccb->ccb_h.path, path_str, sizeof(path_str));
+		sbuf_cat(&sb, path_str);
+		if (ccb->ccb_h.func_code == XPT_SCSI_IO) {
+			scsi_command_string(&ccb->csio, &sb);
+			sbuf_printf(&sb, "length %d ", ccb->csio.dxfer_len);
+		}
+	}
+
+	sbuf_vprintf(&sb, fmt, ap);
+	va_end(ap);
+
+	sbuf_finish(&sb);
+	printf("%s: %s: %s", device_get_nameunit(sc->vtscsi_dev), func,
+	    sbuf_data(&sb));
+}
diff --git a/sys/dev/virtio/scsi/virtio_scsi.h b/sys/dev/virtio/scsi/virtio_scsi.h
new file mode 100644
index 0000000..caf7aaf
--- /dev/null
+++ b/sys/dev/virtio/scsi/virtio_scsi.h
@@ -0,0 +1,152 @@
+/*-
+ * This header is BSD licensed so anyone can use the definitions to implement
+ * compatible drivers/servers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+
+#ifndef _VIRTIO_SCSI_H
+#define _VIRTIO_SCSI_H
+
+/* Feature bits */
+#define VIRTIO_SCSI_F_INOUT	0x0001	/* Single request can contain both
+					 * read and write buffers */
+#define VIRTIO_SCSI_F_HOTPLUG	0x0002	/* Host should enable hot plug/unplug
+					 * of new LUNs and targets.
+					 */
+
+#define VIRTIO_SCSI_CDB_SIZE	32
+#define VIRTIO_SCSI_SENSE_SIZE	96
+
+/* SCSI command request, followed by data-out */
+struct virtio_scsi_cmd_req {
+	uint8_t lun[8];		/* Logical Unit Number */
+	uint64_t tag;		/* Command identifier */
+	uint8_t task_attr;	/* Task attribute */
+	uint8_t prio;
+	uint8_t crn;
+	uint8_t cdb[VIRTIO_SCSI_CDB_SIZE];
+} __packed;
+
+/* Response, followed by sense data and data-in */
+struct virtio_scsi_cmd_resp {
+	uint32_t sense_len;		/* Sense data length */
+	uint32_t resid;			/* Residual bytes in data buffer */
+	uint16_t status_qualifier;	/* Status qualifier */
+	uint8_t status;			/* Command completion status */
+	uint8_t response;		/* Response values */
+	uint8_t sense[VIRTIO_SCSI_SENSE_SIZE];
+} __packed;
+
+/* Task Management Request */
+struct virtio_scsi_ctrl_tmf_req {
+	uint32_t type;
+	uint32_t subtype;
+	uint8_t lun[8];
+	uint64_t tag;
+} __packed;
+
+struct virtio_scsi_ctrl_tmf_resp {
+	uint8_t response;
+} __packed;
+
+/* Asynchronous notification query/subscription */
+struct virtio_scsi_ctrl_an_req {
+	uint32_t type;
+	uint8_t lun[8];
+	uint32_t event_requested;
+} __packed;
+
+struct virtio_scsi_ctrl_an_resp {
+	uint32_t event_actual;
+	uint8_t response;
+} __packed;
+
+struct virtio_scsi_event {
+	uint32_t event;
+	uint8_t lun[8];
+	uint32_t reason;
+} __packed;
+
+struct virtio_scsi_config {
+	uint32_t num_queues;
+	uint32_t seg_max;
+	uint32_t max_sectors;
+	uint32_t cmd_per_lun;
+	uint32_t event_info_size;
+	uint32_t sense_size;
+	uint32_t cdb_size;
+	uint16_t max_channel;
+	uint16_t max_target;
+	uint32_t max_lun;
+} __packed;
+
+/* Response codes */
+#define VIRTIO_SCSI_S_OK                       0
+#define VIRTIO_SCSI_S_FUNCTION_COMPLETE        0
+#define VIRTIO_SCSI_S_OVERRUN                  1
+#define VIRTIO_SCSI_S_ABORTED                  2
+#define VIRTIO_SCSI_S_BAD_TARGET               3
+#define VIRTIO_SCSI_S_RESET                    4
+#define VIRTIO_SCSI_S_BUSY                     5
+#define VIRTIO_SCSI_S_TRANSPORT_FAILURE        6
+#define VIRTIO_SCSI_S_TARGET_FAILURE           7
+#define VIRTIO_SCSI_S_NEXUS_FAILURE            8
+#define VIRTIO_SCSI_S_FAILURE                  9
+#define VIRTIO_SCSI_S_FUNCTION_SUCCEEDED       10
+#define VIRTIO_SCSI_S_FUNCTION_REJECTED        11
+#define VIRTIO_SCSI_S_INCORRECT_LUN            12
+
+/* Controlq type codes.  */
+#define VIRTIO_SCSI_T_TMF                      0
+#define VIRTIO_SCSI_T_AN_QUERY                 1
+#define VIRTIO_SCSI_T_AN_SUBSCRIBE             2
+
+/* Valid TMF subtypes.  */
+#define VIRTIO_SCSI_T_TMF_ABORT_TASK           0
+#define VIRTIO_SCSI_T_TMF_ABORT_TASK_SET       1
+#define VIRTIO_SCSI_T_TMF_CLEAR_ACA            2
+#define VIRTIO_SCSI_T_TMF_CLEAR_TASK_SET       3
+#define VIRTIO_SCSI_T_TMF_I_T_NEXUS_RESET      4
+#define VIRTIO_SCSI_T_TMF_LOGICAL_UNIT_RESET   5
+#define VIRTIO_SCSI_T_TMF_QUERY_TASK           6
+#define VIRTIO_SCSI_T_TMF_QUERY_TASK_SET       7
+
+/* Events.  */
+#define VIRTIO_SCSI_T_EVENTS_MISSED            0x80000000
+#define VIRTIO_SCSI_T_NO_EVENT                 0
+#define VIRTIO_SCSI_T_TRANSPORT_RESET          1
+#define VIRTIO_SCSI_T_ASYNC_NOTIFY             2
+
+/* Reasons of transport reset event */
+#define VIRTIO_SCSI_EVT_RESET_HARD             0
+#define VIRTIO_SCSI_EVT_RESET_RESCAN           1
+#define VIRTIO_SCSI_EVT_RESET_REMOVED          2
+
+#define VIRTIO_SCSI_S_SIMPLE                   0
+#define VIRTIO_SCSI_S_ORDERED                  1
+#define VIRTIO_SCSI_S_HEAD                     2
+#define VIRTIO_SCSI_S_ACA                      3
+
+#endif /* _VIRTIO_SCSI_H */
diff --git a/sys/dev/virtio/scsi/virtio_scsivar.h b/sys/dev/virtio/scsi/virtio_scsivar.h
new file mode 100644
index 0000000..7afe32f
--- /dev/null
+++ b/sys/dev/virtio/scsi/virtio_scsivar.h
@@ -0,0 +1,221 @@
+/*-
+ * Copyright (c) 2012, Bryan Venteicher <bryanv@daemoninthecloset.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice unmodified, this list of conditions, and the following
+ *    disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+
+#ifndef _VIRTIO_SCSIVAR_H
+#define _VIRTIO_SCSIVAR_H
+
+struct vtscsi_softc;
+struct vtscsi_request;
+
+typedef void vtscsi_request_cb_t(struct vtscsi_softc *,
+    struct vtscsi_request *);
+
+struct vtscsi_statistics {
+	unsigned long		scsi_cmd_timeouts;
+	unsigned long		dequeue_no_requests;
+};
+
+struct vtscsi_softc {
+	device_t		 vtscsi_dev;
+	struct mtx		 vtscsi_mtx;
+	uint64_t		 vtscsi_features;
+
+	uint16_t		 vtscsi_flags;
+#define VTSCSI_FLAG_INDIRECT		0x0001
+#define VTSCSI_FLAG_BIDIRECTIONAL	0x0002
+#define VTSCSI_FLAG_HOTPLUG		0x0004
+#define VTSCSI_FLAG_RESET		0x0008
+#define VTSCSI_FLAG_DETACH		0x0010
+
+	uint16_t		 vtscsi_frozen;
+#define VTSCSI_FROZEN_NO_REQUESTS	0x01
+#define VTSCSI_FROZEN_REQUEST_VQ_FULL	0x02
+
+	struct sglist		*vtscsi_sglist;
+
+	struct virtqueue	*vtscsi_control_vq;
+	struct virtqueue	*vtscsi_event_vq;
+	struct virtqueue	*vtscsi_request_vq;
+
+	struct taskqueue	*vtscsi_tq;
+	struct task		 vtscsi_control_intr_task;
+	struct task		 vtscsi_event_intr_task;
+	struct task		 vtscsi_request_intr_task;
+
+	struct cam_sim		*vtscsi_sim;
+	struct cam_path		*vtscsi_path;
+
+	int			 vtscsi_debug;
+	int			 vtscsi_nrequests;
+	int			 vtscsi_max_nsegs;
+	int			 vtscsi_event_buf_size;
+
+	TAILQ_HEAD(,vtscsi_request)
+				 vtscsi_req_free;
+
+	uint16_t		 vtscsi_max_channel;
+	uint16_t		 vtscsi_max_target;
+	uint32_t		 vtscsi_max_lun;
+
+#define VTSCSI_NUM_EVENT_BUFS	4
+	struct virtio_scsi_event
+				 vtscsi_event_bufs[VTSCSI_NUM_EVENT_BUFS];
+
+	struct vtscsi_statistics vtscsi_stats;
+};
+
+enum vtscsi_request_state {
+	VTSCSI_REQ_STATE_FREE,
+	VTSCSI_REQ_STATE_INUSE,
+	VTSCSI_REQ_STATE_ABORTED,
+	VTSCSI_REQ_STATE_TIMEDOUT
+};
+
+struct vtscsi_request {
+	struct vtscsi_softc			*vsr_softc;
+	union ccb				*vsr_ccb;
+	vtscsi_request_cb_t			*vsr_complete;
+
+	void					*vsr_ptr0;
+/* Request when aborting a timedout command. */
+#define vsr_timedout_req	vsr_ptr0
+
+	enum vtscsi_request_state		 vsr_state;
+
+	uint16_t				 vsr_flags;
+#define VTSCSI_REQ_FLAG_POLLED		0x01
+#define VTSCSI_REQ_FLAG_COMPLETE	0x02
+#define VTSCSI_REQ_FLAG_TIMEOUT_SET	0x04
+
+	union {
+		struct virtio_scsi_cmd_req	 cmd;
+		struct virtio_scsi_ctrl_tmf_req	 tmf;
+		struct virtio_scsi_ctrl_an_req	 an;
+	} vsr_ureq;
+#define vsr_cmd_req 	vsr_ureq.cmd
+#define vsr_tmf_req 	vsr_ureq.tmf
+#define vsr_an_req	vsr_ureq.an
+
+	/* Make request and response non-contiguous. */
+	uint32_t				 vsr_pad;
+
+	union {
+		struct virtio_scsi_cmd_resp	 cmd;
+		struct virtio_scsi_ctrl_tmf_resp tmf;
+		struct virtio_scsi_ctrl_an_resp	 an;
+	} vsr_uresp;
+#define vsr_cmd_resp	vsr_uresp.cmd
+#define vsr_tmf_resp	vsr_uresp.tmf
+#define vsr_an_resp	vsr_uresp.an
+
+	struct callout				 vsr_callout;
+
+	TAILQ_ENTRY(vtscsi_request)		 vsr_link;
+};
+
+/* Private field in the CCB header that points to our request. */
+#define ccbh_vtscsi_req	spriv_ptr0
+
+/* Features desired/implemented by this driver. */
+#define VTSCSI_FEATURES \
+    (VIRTIO_SCSI_F_HOTPLUG		| \
+     VIRTIO_RING_F_INDIRECT_DESC)
+
+#define VTSCSI_MTX(_sc)			&(_sc)->vtscsi_mtx
+#define VTSCSI_LOCK_INIT(_sc, _name) 	mtx_init(VTSCSI_MTX(_sc), _name, \
+					    "VTSCSI Lock", MTX_DEF)
+#define VTSCSI_LOCK(_sc)		mtx_lock(VTSCSI_MTX(_sc))
+#define VTSCSI_UNLOCK(_sc)		mtx_unlock(VTSCSI_MTX(_sc))
+#define VTSCSI_LOCK_OWNED(_sc)		mtx_assert(VTSCSI_MTX(_sc), MA_OWNED)
+#define VTSCSI_LOCK_NOTOWNED(_sc) 	mtx_assert(VTSCSI_MTX(_sc), MA_NOTOWNED)
+#define VTSCSI_LOCK_DESTROY(_sc)	mtx_destroy(VTSCSI_MTX(_sc))
+
+/*
+ * Reasons for either freezing or thawing the SIMQ.
+ *
+ * VirtIO SCSI is a bit unique in the sense that SCSI and TMF
+ * commands go over different queues. Both queues are fed by
+ * the same SIMQ, but we only freeze the SIMQ when the request
+ * (SCSI) virtqueue is full, not caring if the control (TMF)
+ * virtqueue unlikely gets full. However, both queues share the
+ * same pool of requests, so the completion of a TMF command
+ * could cause the SIMQ to be unfrozen.
+ */
+#define VTSCSI_REQUEST		0x01
+#define VTSCSI_REQUEST_VQ	0x02
+
+/* Debug trace levels. */
+#define VTSCSI_INFO	0x01
+#define VTSCSI_ERROR	0x02
+#define VTSCSI_TRACE	0x04
+
+#define vtscsi_dprintf(_sc, _level, _msg, _args ...) do { 		\
+	if ((_sc)->vtscsi_debug & (_level))				\
+		device_printf((_sc)->vtscsi_dev, "%s: "_msg,		\
+		    __FUNCTION__, ##_args);				\
+} while (0)
+
+#define vtscsi_dprintf_req(_req, _level, _msg, _args ...) do {		\
+	struct vtscsi_softc *__sc = (_req)->vsr_softc;			\
+	if ((__sc)->vtscsi_debug & (_level))				\
+		vtscsi_printf_req(_req, __FUNCTION__, _msg, ##_args);	\
+} while (0)
+
+/*
+ * Set the status field in a CCB, optionally clearing non CCB_STATUS_* flags.
+ */
+#define vtscsi_set_ccb_status(_ccbh, _status, _mask) do {		\
+	KASSERT(((_mask) & CAM_STATUS_MASK) == 0,			\
+	    ("%s:%d bad mask: 0x%x", __FUNCTION__, __LINE__, (_mask)));	\
+	(_ccbh)->status &= ~(CAM_STATUS_MASK | (_mask));		\
+	(_ccbh)->status |= (_status);					\
+} while (0)
+
+/*
+ * One segment each for the request and the response.
+ */
+#define VTSCSI_MIN_SEGMENTS	2
+
+/*
+ * Allocate additional requests for internal use such
+ * as TM commands (e.g. aborting timedout commands).
+ */
+#define VTSCSI_RESERVED_REQUESTS	10
+
+/*
+ * Specification doesn't say, use traditional SCSI default.
+ */
+#define VTSCSI_INITIATOR_ID	7
+
+/*
+ * How to wait (or not) for request completion.
+ */
+#define VTSCSI_EXECUTE_ASYNC	0
+#define VTSCSI_EXECUTE_POLL	1
+
+#endif /* _VIRTIO_SCSIVAR_H */
diff --git a/sys/dev/virtio/virtio.c b/sys/dev/virtio/virtio.c
new file mode 100644
index 0000000..6c6b0bc
--- /dev/null
+++ b/sys/dev/virtio/virtio.c
@@ -0,0 +1,277 @@
+/*-
+ * Copyright (c) 2011, Bryan Venteicher <bryanv@daemoninthecloset.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice unmodified, this list of conditions, and the following
+ *    disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/kernel.h>
+#include <sys/malloc.h>
+#include <sys/module.h>
+#include <sys/sbuf.h>
+
+#include <machine/bus.h>
+#include <machine/resource.h>
+#include <machine/_inttypes.h>
+#include <sys/bus.h>
+#include <sys/rman.h>
+
+#include <dev/virtio/virtio.h>
+#include <dev/virtio/virtqueue.h>
+
+#include "virtio_bus_if.h"
+
+static int virtio_modevent(module_t, int, void *);
+static const char *virtio_feature_name(uint64_t, struct virtio_feature_desc *);
+
+static struct virtio_ident {
+	uint16_t devid;
+	char	*name;
+} virtio_ident_table[] = {
+	{ VIRTIO_ID_NETWORK,	"Network"	},
+	{ VIRTIO_ID_BLOCK,	"Block"		},
+	{ VIRTIO_ID_CONSOLE,	"Console"	},
+	{ VIRTIO_ID_ENTROPY,	"Entropy"	},
+	{ VIRTIO_ID_BALLOON,	"Balloon"	},
+	{ VIRTIO_ID_IOMEMORY,	"IOMemory"	},
+	{ VIRTIO_ID_SCSI,	"SCSI"		},
+	{ VIRTIO_ID_9P,		"9P Transport"	},
+
+	{ 0, NULL }
+};
+
+/* Device independent features. */
+static struct virtio_feature_desc virtio_common_feature_desc[] = {
+	{ VIRTIO_F_NOTIFY_ON_EMPTY,	"NotifyOnEmpty"	},
+	{ VIRTIO_RING_F_INDIRECT_DESC,	"RingIndirect"	},
+	{ VIRTIO_RING_F_EVENT_IDX,	"EventIdx"	},
+	{ VIRTIO_F_BAD_FEATURE,		"BadFeature"	},
+
+	{ 0, NULL }
+};
+
+const char *
+virtio_device_name(uint16_t devid)
+{
+	struct virtio_ident *ident;
+
+	for (ident = virtio_ident_table; ident->name != NULL; ident++) {
+		if (ident->devid == devid)
+			return (ident->name);
+	}
+
+	return (NULL);
+}
+
+void
+virtio_describe(device_t dev, const char *msg,
+    uint64_t features, struct virtio_feature_desc *feature_desc)
+{
+	struct sbuf sb;
+	uint64_t val;
+	char *buf;
+	const char *name;
+	int n;
+
+	if ((buf = malloc(512, M_TEMP, M_NOWAIT)) == NULL) {
+		device_printf(dev, "%s features: 0x%"PRIx64"\n", msg,
+		    features);
+		return;
+	}
+
+	sbuf_new(&sb, buf, 512, SBUF_FIXEDLEN);
+	sbuf_printf(&sb, "%s features: 0x%"PRIx64, msg, features);
+
+	for (n = 0, val = 1ULL << 63; val != 0; val >>= 1) {
+		/*
+		 * BAD_FEATURE is used to detect broken Linux clients
+		 * and therefore is not applicable to FreeBSD.
+		 */
+		if (((features & val) == 0) || val == VIRTIO_F_BAD_FEATURE)
+			continue;
+
+		if (n++ == 0)
+			sbuf_cat(&sb, " <");
+		else
+			sbuf_cat(&sb, ",");
+
+		name = NULL;
+		if (feature_desc != NULL)
+			name = virtio_feature_name(val, feature_desc);
+		if (name == NULL)
+			name = virtio_feature_name(val,
+			    virtio_common_feature_desc);
+
+		if (name == NULL)
+			sbuf_printf(&sb, "0x%"PRIx64, val);
+		else
+			sbuf_cat(&sb, name);
+	}
+
+	if (n > 0)
+		sbuf_cat(&sb, ">");
+
+#if __FreeBSD_version < 900020
+	sbuf_finish(&sb);
+	if (sbuf_overflowed(&sb) == 0)
+#else
+	if (sbuf_finish(&sb) == 0)
+#endif
+		device_printf(dev, "%s\n", sbuf_data(&sb));
+
+	sbuf_delete(&sb);
+	free(buf, M_TEMP);
+}
+
+static const char *
+virtio_feature_name(uint64_t val, struct virtio_feature_desc *feature_desc)
+{
+	int i;
+
+	for (i = 0; feature_desc[i].vfd_val != 0; i++)
+		if (val == feature_desc[i].vfd_val)
+			return (feature_desc[i].vfd_str);
+
+	return (NULL);
+}
+
+/*
+ * VirtIO bus method wrappers.
+ */
+
+void
+virtio_read_ivar(device_t dev, int ivar, uintptr_t *val)
+{
+
+	*val = -1;
+	BUS_READ_IVAR(device_get_parent(dev), dev, ivar, val);
+}
+
+void
+virtio_write_ivar(device_t dev, int ivar, uintptr_t val)
+{
+
+	BUS_WRITE_IVAR(device_get_parent(dev), dev, ivar, val);
+}
+
+uint64_t
+virtio_negotiate_features(device_t dev, uint64_t child_features)
+{
+
+	return (VIRTIO_BUS_NEGOTIATE_FEATURES(device_get_parent(dev),
+	    child_features));
+}
+
+int
+virtio_alloc_virtqueues(device_t dev, int flags, int nvqs,
+    struct vq_alloc_info *info)
+{
+
+	return (VIRTIO_BUS_ALLOC_VIRTQUEUES(device_get_parent(dev), flags,
+	    nvqs, info));
+}
+
+int
+virtio_setup_intr(device_t dev, enum intr_type type)
+{
+
+	return (VIRTIO_BUS_SETUP_INTR(device_get_parent(dev), type));
+}
+
+int
+virtio_with_feature(device_t dev, uint64_t feature)
+{
+
+	return (VIRTIO_BUS_WITH_FEATURE(device_get_parent(dev), feature));
+}
+
+void
+virtio_stop(device_t dev)
+{
+
+	VIRTIO_BUS_STOP(device_get_parent(dev));
+}
+
+int
+virtio_reinit(device_t dev, uint64_t features)
+{
+
+	return (VIRTIO_BUS_REINIT(device_get_parent(dev), features));
+}
+
+void
+virtio_reinit_complete(device_t dev)
+{
+
+	VIRTIO_BUS_REINIT_COMPLETE(device_get_parent(dev));
+}
+
+void
+virtio_read_device_config(device_t dev, bus_size_t offset, void *dst, int len)
+{
+
+	VIRTIO_BUS_READ_DEVICE_CONFIG(device_get_parent(dev),
+	    offset, dst, len);
+}
+
+void
+virtio_write_device_config(device_t dev, bus_size_t offset, void *dst, int len)
+{
+
+	VIRTIO_BUS_WRITE_DEVICE_CONFIG(device_get_parent(dev),
+	    offset, dst, len);
+}
+
+static int
+virtio_modevent(module_t mod, int type, void *unused)
+{
+	int error;
+
+	error = 0;
+
+	switch (type) {
+	case MOD_LOAD:
+	case MOD_QUIESCE:
+	case MOD_UNLOAD:
+	case MOD_SHUTDOWN:
+		break;
+	default:
+		error = EOPNOTSUPP;
+		break;
+	}
+
+	return (error);
+}
+
+static moduledata_t virtio_mod = {
+	"virtio",
+	virtio_modevent,
+	0
+};
+
+DECLARE_MODULE(virtio, virtio_mod, SI_SUB_DRIVERS, SI_ORDER_FIRST);
+MODULE_VERSION(virtio, 1);
diff --git a/sys/dev/virtio/virtio.h b/sys/dev/virtio/virtio.h
new file mode 100644
index 0000000..4d069dd
--- /dev/null
+++ b/sys/dev/virtio/virtio.h
@@ -0,0 +1,185 @@
+/*-
+ * This header is BSD licensed so anyone can use the definitions to implement
+ * compatible drivers/servers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of IBM nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL IBM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+
+#ifndef _VIRTIO_H_
+#define _VIRTIO_H_
+
+struct vq_alloc_info;
+
+/* VirtIO device IDs. */
+#define VIRTIO_ID_NETWORK	0x01
+#define VIRTIO_ID_BLOCK		0x02
+#define VIRTIO_ID_CONSOLE	0x03
+#define VIRTIO_ID_ENTROPY	0x04
+#define VIRTIO_ID_BALLOON	0x05
+#define VIRTIO_ID_IOMEMORY	0x06
+#define VIRTIO_ID_SCSI		0x08
+#define VIRTIO_ID_9P		0x09
+
+/* Status byte for guest to report progress. */
+#define VIRTIO_CONFIG_STATUS_RESET	0x00
+#define VIRTIO_CONFIG_STATUS_ACK	0x01
+#define VIRTIO_CONFIG_STATUS_DRIVER	0x02
+#define VIRTIO_CONFIG_STATUS_DRIVER_OK	0x04
+#define VIRTIO_CONFIG_STATUS_FAILED	0x80
+
+/*
+ * Generate interrupt when the virtqueue ring is
+ * completely used, even if we've suppressed them.
+ */
+#define VIRTIO_F_NOTIFY_ON_EMPTY (1 << 24)
+
+/*
+ * The guest should never negotiate this feature; it
+ * is used to detect faulty drivers.
+ */
+#define VIRTIO_F_BAD_FEATURE (1 << 30)
+
+/*
+ * Some VirtIO feature bits (currently bits 28 through 31) are
+ * reserved for the transport being used (eg. virtio_ring), the
+ * rest are per-device feature bits.
+ */
+#define VIRTIO_TRANSPORT_F_START	28
+#define VIRTIO_TRANSPORT_F_END		32
+
+/*
+ * Maximum number of virtqueues per device.
+ */
+#define VIRTIO_MAX_VIRTQUEUES 8
+
+/*
+ * Each virtqueue indirect descriptor list must be physically contiguous.
+ * To allow us to malloc(9) each list individually, limit the number
+ * supported to what will fit in one page. With 4KB pages, this is a limit
+ * of 256 descriptors. If there is ever a need for more, we can switch to
+ * contigmalloc(9) for the larger allocations, similar to what
+ * bus_dmamem_alloc(9) does.
+ *
+ * Note the sizeof(struct vring_desc) is 16 bytes.
+ */
+#define VIRTIO_MAX_INDIRECT ((int) (PAGE_SIZE / 16))
+
+/*
+ * VirtIO instance variables indices.
+ */
+#define VIRTIO_IVAR_DEVTYPE		1
+#define VIRTIO_IVAR_FEATURE_DESC	2
+#define VIRTIO_IVAR_VENDOR		3
+#define VIRTIO_IVAR_DEVICE		4
+#define VIRTIO_IVAR_SUBVENDOR		5
+#define VIRTIO_IVAR_SUBDEVICE		6
+
+struct virtio_feature_desc {
+	uint64_t	 vfd_val;
+	char		*vfd_str;
+};
+
+const char *virtio_device_name(uint16_t devid);
+void	 virtio_describe(device_t dev, const char *msg,
+	     uint64_t features, struct virtio_feature_desc *feature_desc);
+
+/*
+ * VirtIO Bus Methods.
+ */
+void	 virtio_read_ivar(device_t dev, int ivar, uintptr_t *val);
+void	 virtio_write_ivar(device_t dev, int ivar, uintptr_t val);
+uint64_t virtio_negotiate_features(device_t dev, uint64_t child_features);
+int	 virtio_alloc_virtqueues(device_t dev, int flags, int nvqs,
+	     struct vq_alloc_info *info);
+int	 virtio_setup_intr(device_t dev, enum intr_type type);
+int	 virtio_with_feature(device_t dev, uint64_t feature);
+void	 virtio_stop(device_t dev);
+int	 virtio_reinit(device_t dev, uint64_t features);
+void	 virtio_reinit_complete(device_t dev);
+
+/*
+ * Read/write a variable amount from the device specific (ie, network)
+ * configuration region. This region is encoded in the same endian as
+ * the guest.
+ */
+void	 virtio_read_device_config(device_t dev, bus_size_t offset,
+	     void *dst, int length);
+void	 virtio_write_device_config(device_t dev, bus_size_t offset,
+	     void *src, int length);
+
+/* Inlined device specific read/write functions for common lengths. */
+#define VIRTIO_RDWR_DEVICE_CONFIG(size, type)				\
+static inline type							\
+__CONCAT(virtio_read_dev_config_,size)(device_t dev,			\
+    bus_size_t offset)							\
+{									\
+	type val;							\
+	virtio_read_device_config(dev, offset, &val, sizeof(type));	\
+	return (val);							\
+}									\
+									\
+static inline void							\
+__CONCAT(virtio_write_dev_config_,size)(device_t dev,			\
+    bus_size_t offset, type val)					\
+{									\
+	virtio_write_device_config(dev, offset, &val, sizeof(type));	\
+}
+
+VIRTIO_RDWR_DEVICE_CONFIG(1, uint8_t);
+VIRTIO_RDWR_DEVICE_CONFIG(2, uint16_t);
+VIRTIO_RDWR_DEVICE_CONFIG(4, uint32_t);
+
+#undef VIRTIO_RDWR_DEVICE_CONFIG
+
+#define VIRTIO_READ_IVAR(name, ivar)					\
+static inline int							\
+__CONCAT(virtio_get_,name)(device_t dev)				\
+{									\
+	uintptr_t val;							\
+	virtio_read_ivar(dev, ivar, &val);				\
+	return ((int) val);						\
+}
+
+VIRTIO_READ_IVAR(device_type,	VIRTIO_IVAR_DEVTYPE);
+VIRTIO_READ_IVAR(vendor,	VIRTIO_IVAR_VENDOR);
+VIRTIO_READ_IVAR(device,	VIRTIO_IVAR_DEVICE);
+VIRTIO_READ_IVAR(subvendor,	VIRTIO_IVAR_SUBVENDOR);
+VIRTIO_READ_IVAR(subdevice,	VIRTIO_IVAR_SUBDEVICE);
+
+#undef VIRTIO_READ_IVAR
+
+#define VIRTIO_WRITE_IVAR(name, ivar)					\
+static inline void							\
+__CONCAT(virtio_set_,name)(device_t dev, void *val)			\
+{									\
+	virtio_write_ivar(dev, ivar, (uintptr_t) val);			\
+}
+
+VIRTIO_WRITE_IVAR(feature_desc,	VIRTIO_IVAR_FEATURE_DESC);
+
+#undef VIRTIO_WRITE_IVAR
+
+#endif /* _VIRTIO_H_ */
diff --git a/sys/dev/virtio/virtio_bus_if.m b/sys/dev/virtio/virtio_bus_if.m
new file mode 100644
index 0000000..ec2029d
--- /dev/null
+++ b/sys/dev/virtio/virtio_bus_if.m
@@ -0,0 +1,92 @@
+#-
+# Copyright (c) 2011, Bryan Venteicher <bryanv@daemoninthecloset.org>
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in the
+#    documentation and/or other materials provided with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+# SUCH DAMAGE.
+#
+# $FreeBSD$
+
+#include <sys/bus.h>
+#include <machine/bus.h>
+
+INTERFACE virtio_bus;
+
+HEADER {
+struct vq_alloc_info;
+};
+
+METHOD uint64_t negotiate_features {
+	device_t	dev;
+	uint64_t	child_features;
+};
+
+METHOD int with_feature {
+	device_t	dev;
+	uint64_t	feature;
+};
+
+METHOD int alloc_virtqueues {
+	device_t	dev;
+	int		flags;
+	int		nvqs;
+	struct vq_alloc_info *info;
+};
+HEADER {
+#define VIRTIO_ALLOC_VQS_DISABLE_MSIX 0x1
+};
+
+METHOD int setup_intr {
+	device_t	dev;
+	enum intr_type	type;
+};
+
+METHOD void stop {
+	device_t	dev;
+};
+
+METHOD int reinit {
+	device_t	dev;
+	uint64_t	features;
+};
+
+METHOD void reinit_complete {
+	device_t	dev;
+};
+
+METHOD void notify_vq {
+	device_t	dev;
+	uint16_t	queue;
+};
+
+METHOD void read_device_config {
+	device_t	dev;
+	bus_size_t	offset;
+	void		*dst;
+	int		len;
+};
+
+METHOD void write_device_config {
+	device_t	dev;
+	bus_size_t	offset;
+	void		*src;
+	int		len;
+};
diff --git a/sys/dev/virtio/virtio_if.m b/sys/dev/virtio/virtio_if.m
new file mode 100644
index 0000000..701678c
--- /dev/null
+++ b/sys/dev/virtio/virtio_if.m
@@ -0,0 +1,43 @@
+#-
+# Copyright (c) 2011, Bryan Venteicher <bryanv@daemoninthecloset.org>
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in the
+#    documentation and/or other materials provided with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+# SUCH DAMAGE.
+#
+# $FreeBSD$
+
+#include <sys/bus.h>
+
+INTERFACE virtio;
+
+CODE {
+	static int
+	virtio_default_config_change(device_t dev)
+	{
+		/* Return that we've handled the change. */
+		return (1);
+	}
+};
+
+METHOD int config_change {
+	device_t	dev;
+} DEFAULT virtio_default_config_change;
diff --git a/sys/dev/virtio/virtio_ring.h b/sys/dev/virtio/virtio_ring.h
new file mode 100644
index 0000000..8e902ab
--- /dev/null
+++ b/sys/dev/virtio/virtio_ring.h
@@ -0,0 +1,165 @@
+/*-
+ * Copyright Rusty Russell IBM Corporation 2007.
+ *
+ * This header is BSD licensed so anyone can use the definitions to implement
+ * compatible drivers/servers.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of IBM nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL IBM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+
+#ifndef VIRTIO_RING_H
+#define	VIRTIO_RING_H
+
+/* This marks a buffer as continuing via the next field. */
+#define VRING_DESC_F_NEXT       1
+/* This marks a buffer as write-only (otherwise read-only). */
+#define VRING_DESC_F_WRITE      2
+/* This means the buffer contains a list of buffer descriptors. */
+#define VRING_DESC_F_INDIRECT	4
+
+/* The Host uses this in used->flags to advise the Guest: don't kick me
+ * when you add a buffer.  It's unreliable, so it's simply an
+ * optimization.  Guest will still kick if it's out of buffers. */
+#define VRING_USED_F_NO_NOTIFY  1
+/* The Guest uses this in avail->flags to advise the Host: don't
+ * interrupt me when you consume a buffer.  It's unreliable, so it's
+ * simply an optimization.  */
+#define VRING_AVAIL_F_NO_INTERRUPT      1
+
+/* VirtIO ring descriptors: 16 bytes.
+ * These can chain together via "next". */
+struct vring_desc {
+        /* Address (guest-physical). */
+        uint64_t addr;
+        /* Length. */
+        uint32_t len;
+        /* The flags as indicated above. */
+        uint16_t flags;
+        /* We chain unused descriptors via this, too. */
+        uint16_t next;
+};
+
+struct vring_avail {
+        uint16_t flags;
+        uint16_t idx;
+        uint16_t ring[0];
+};
+
+/* uint32_t is used here for ids for padding reasons. */
+struct vring_used_elem {
+        /* Index of start of used descriptor chain. */
+        uint32_t id;
+        /* Total length of the descriptor chain which was written to. */
+        uint32_t len;
+};
+
+struct vring_used {
+        uint16_t flags;
+        uint16_t idx;
+        struct vring_used_elem ring[0];
+};
+
+struct vring {
+	unsigned int num;
+
+	struct vring_desc *desc;
+	struct vring_avail *avail;
+	struct vring_used *used;
+};
+
+/* The standard layout for the ring is a continuous chunk of memory which
+ * looks like this.  We assume num is a power of 2.
+ *
+ * struct vring {
+ *      // The actual descriptors (16 bytes each)
+ *      struct vring_desc desc[num];
+ *
+ *      // A ring of available descriptor heads with free-running index.
+ *      __u16 avail_flags;
+ *      __u16 avail_idx;
+ *      __u16 available[num];
+ *      __u16 used_event_idx;
+ *
+ *      // Padding to the next align boundary.
+ *      char pad[];
+ *
+ *      // A ring of used descriptor heads with free-running index.
+ *      __u16 used_flags;
+ *      __u16 used_idx;
+ *      struct vring_used_elem used[num];
+ *      __u16 avail_event_idx;
+ * };
+ *
+ * NOTE: for VirtIO PCI, align is 4096.
+ */
+
+/*
+ * We publish the used event index at the end of the available ring, and vice
+ * versa. They are at the end for backwards compatibility.
+ */
+#define vring_used_event(vr)	((vr)->avail->ring[(vr)->num])
+#define vring_avail_event(vr)	(*(uint16_t *)&(vr)->used->ring[(vr)->num])
+
+static inline int
+vring_size(unsigned int num, unsigned long align)
+{
+	int size;
+
+	size = num * sizeof(struct vring_desc);
+	size += sizeof(struct vring_avail) + (num * sizeof(uint16_t)) +
+	    sizeof(uint16_t);
+	size = (size + align - 1) & ~(align - 1);
+	size += sizeof(struct vring_used) +
+	    (num * sizeof(struct vring_used_elem)) + sizeof(uint16_t);
+	return (size);
+}
+
+static inline void
+vring_init(struct vring *vr, unsigned int num, uint8_t *p,
+    unsigned long align)
+{
+        vr->num = num;
+        vr->desc = (struct vring_desc *) p;
+        vr->avail = (struct vring_avail *) (p +
+	    num * sizeof(struct vring_desc));
+        vr->used = (void *)
+	    (((unsigned long) &vr->avail->ring[num] + align-1) & ~(align-1));
+}
+
+/*
+ * The following is used with VIRTIO_RING_F_EVENT_IDX.
+ *
+ * Assuming a given event_idx value from the other size, if we have
+ * just incremented index from old to new_idx, should we trigger an
+ * event?
+ */
+static inline int
+vring_need_event(uint16_t event_idx, uint16_t new_idx, uint16_t old)
+{
+
+	return (uint16_t)(new_idx - event_idx - 1) < (uint16_t)(new_idx - old);
+}
+#endif /* VIRTIO_RING_H */
diff --git a/sys/dev/virtio/virtqueue.c b/sys/dev/virtio/virtqueue.c
new file mode 100644
index 0000000..7e02deb
--- /dev/null
+++ b/sys/dev/virtio/virtqueue.c
@@ -0,0 +1,803 @@
+/*-
+ * Copyright (c) 2011, Bryan Venteicher <bryanv@daemoninthecloset.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice unmodified, this list of conditions, and the following
+ *    disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * Implements the virtqueue interface as basically described
+ * in the original VirtIO paper.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/kernel.h>
+#include <sys/malloc.h>
+#include <sys/sglist.h>
+#include <vm/vm.h>
+#include <vm/pmap.h>
+
+#include <machine/cpu.h>
+#include <machine/bus.h>
+#include <machine/atomic.h>
+#include <machine/resource.h>
+#include <sys/bus.h>
+#include <sys/rman.h>
+
+#include <dev/virtio/virtio.h>
+#include <dev/virtio/virtqueue.h>
+#include <dev/virtio/virtio_ring.h>
+
+#include "virtio_bus_if.h"
+
+struct virtqueue {
+	device_t		 vq_dev;
+	char			 vq_name[VIRTQUEUE_MAX_NAME_SZ];
+	uint16_t		 vq_queue_index;
+	uint16_t		 vq_nentries;
+	uint32_t		 vq_flags;
+#define	VIRTQUEUE_FLAG_INDIRECT	 0x0001
+#define	VIRTQUEUE_FLAG_EVENT_IDX 0x0002
+
+	int			 vq_alignment;
+	int			 vq_ring_size;
+	void			*vq_ring_mem;
+	int			 vq_max_indirect_size;
+	int			 vq_indirect_mem_size;
+	virtqueue_intr_t	*vq_intrhand;
+	void			*vq_intrhand_arg;
+
+	struct vring		 vq_ring;
+	uint16_t		 vq_free_cnt;
+	uint16_t		 vq_queued_cnt;
+	/*
+	 * Head of the free chain in the descriptor table. If
+	 * there are no free descriptors, this will be set to
+	 * VQ_RING_DESC_CHAIN_END.
+	 */
+	uint16_t		 vq_desc_head_idx;
+	/*
+	 * Last consumed descriptor in the used table,
+	 * trails vq_ring.used->idx.
+	 */
+	uint16_t		 vq_used_cons_idx;
+
+	struct vq_desc_extra {
+		void		  *cookie;
+		struct vring_desc *indirect;
+		vm_paddr_t	   indirect_paddr;
+		uint16_t	   ndescs;
+	} vq_descx[0];
+};
+
+/*
+ * The maximum virtqueue size is 2^15. Use that value as the end of
+ * descriptor chain terminator since it will never be a valid index
+ * in the descriptor table. This is used to verify we are correctly
+ * handling vq_free_cnt.
+ */
+#define VQ_RING_DESC_CHAIN_END 32768
+
+#define VQASSERT(_vq, _exp, _msg, ...)				\
+    KASSERT((_exp),("%s: %s - "_msg, __func__, (_vq)->vq_name,	\
+	##__VA_ARGS__))
+
+#define VQ_RING_ASSERT_VALID_IDX(_vq, _idx)			\
+    VQASSERT((_vq), (_idx) < (_vq)->vq_nentries,		\
+	"invalid ring index: %d, max: %d", (_idx),		\
+	(_vq)->vq_nentries)
+
+#define VQ_RING_ASSERT_CHAIN_TERM(_vq)				\
+    VQASSERT((_vq), (_vq)->vq_desc_head_idx ==			\
+	VQ_RING_DESC_CHAIN_END,	"full ring terminated "		\
+	"incorrectly: head idx: %d", (_vq)->vq_desc_head_idx)
+
+static int	virtqueue_init_indirect(struct virtqueue *vq, int);
+static void	virtqueue_free_indirect(struct virtqueue *vq);
+static void	virtqueue_init_indirect_list(struct virtqueue *,
+		    struct vring_desc *);
+
+static void	vq_ring_init(struct virtqueue *);
+static void	vq_ring_update_avail(struct virtqueue *, uint16_t);
+static uint16_t	vq_ring_enqueue_segments(struct virtqueue *,
+		    struct vring_desc *, uint16_t, struct sglist *, int, int);
+static int	vq_ring_use_indirect(struct virtqueue *, int);
+static void	vq_ring_enqueue_indirect(struct virtqueue *, void *,
+		    struct sglist *, int, int);
+static int 	vq_ring_enable_interrupt(struct virtqueue *, uint16_t);
+static int	vq_ring_must_notify_host(struct virtqueue *);
+static void	vq_ring_notify_host(struct virtqueue *);
+static void	vq_ring_free_chain(struct virtqueue *, uint16_t);
+
+uint64_t
+virtqueue_filter_features(uint64_t features)
+{
+	uint64_t mask;
+
+	mask = (1 << VIRTIO_TRANSPORT_F_START) - 1;
+	mask |= VIRTIO_RING_F_INDIRECT_DESC;
+	mask |= VIRTIO_RING_F_EVENT_IDX;
+
+	return (features & mask);
+}
+
+int
+virtqueue_alloc(device_t dev, uint16_t queue, uint16_t size, int align,
+    vm_paddr_t highaddr, struct vq_alloc_info *info, struct virtqueue **vqp)
+{
+	struct virtqueue *vq;
+	int error;
+
+	*vqp = NULL;
+	error = 0;
+
+	if (size == 0) {
+		device_printf(dev,
+		    "virtqueue %d (%s) does not exist (size is zero)\n",
+		    queue, info->vqai_name);
+		return (ENODEV);
+	} else if (!powerof2(size)) {
+		device_printf(dev,
+		    "virtqueue %d (%s) size is not a power of 2: %d\n",
+		    queue, info->vqai_name, size);
+		return (ENXIO);
+	} else if (info->vqai_maxindirsz > VIRTIO_MAX_INDIRECT) {
+		device_printf(dev, "virtqueue %d (%s) requested too many "
+		    "indirect descriptors: %d, max %d\n",
+		    queue, info->vqai_name, info->vqai_maxindirsz,
+		    VIRTIO_MAX_INDIRECT);
+		return (EINVAL);
+	}
+
+	vq = malloc(sizeof(struct virtqueue) +
+	    size * sizeof(struct vq_desc_extra), M_DEVBUF, M_NOWAIT | M_ZERO);
+	if (vq == NULL) {
+		device_printf(dev, "cannot allocate virtqueue\n");
+		return (ENOMEM);
+	}
+
+	vq->vq_dev = dev;
+	strlcpy(vq->vq_name, info->vqai_name, sizeof(vq->vq_name));
+	vq->vq_queue_index = queue;
+	vq->vq_alignment = align;
+	vq->vq_nentries = size;
+	vq->vq_free_cnt = size;
+	vq->vq_intrhand = info->vqai_intr;
+	vq->vq_intrhand_arg = info->vqai_intr_arg;
+
+	if (VIRTIO_BUS_WITH_FEATURE(dev, VIRTIO_RING_F_EVENT_IDX) != 0)
+		vq->vq_flags |= VIRTQUEUE_FLAG_EVENT_IDX;
+
+	if (info->vqai_maxindirsz > 1) {
+		error = virtqueue_init_indirect(vq, info->vqai_maxindirsz);
+		if (error)
+			goto fail;
+	}
+
+	vq->vq_ring_size = round_page(vring_size(size, align));
+	vq->vq_ring_mem = contigmalloc(vq->vq_ring_size, M_DEVBUF,
+	    M_NOWAIT | M_ZERO, 0, highaddr, PAGE_SIZE, 0);
+	if (vq->vq_ring_mem == NULL) {
+		device_printf(dev,
+		    "cannot allocate memory for virtqueue ring\n");
+		error = ENOMEM;
+		goto fail;
+	}
+
+	vq_ring_init(vq);
+	virtqueue_disable_intr(vq);
+
+	*vqp = vq;
+
+fail:
+	if (error)
+		virtqueue_free(vq);
+
+	return (error);
+}
+
+static int
+virtqueue_init_indirect(struct virtqueue *vq, int indirect_size)
+{
+	device_t dev;
+	struct vq_desc_extra *dxp;
+	int i, size;
+
+	dev = vq->vq_dev;
+
+	if (VIRTIO_BUS_WITH_FEATURE(dev, VIRTIO_RING_F_INDIRECT_DESC) == 0) {
+		/*
+		 * Indirect descriptors requested by the driver but not
+		 * negotiated. Return zero to keep the initialization
+		 * going: we'll run fine without.
+		 */
+		if (bootverbose)
+			device_printf(dev, "virtqueue %d (%s) requested "
+			    "indirect descriptors but not negotiated\n",
+			    vq->vq_queue_index, vq->vq_name);
+		return (0);
+	}
+
+	size = indirect_size * sizeof(struct vring_desc);
+	vq->vq_max_indirect_size = indirect_size;
+	vq->vq_indirect_mem_size = size;
+	vq->vq_flags |= VIRTQUEUE_FLAG_INDIRECT;
+
+	for (i = 0; i < vq->vq_nentries; i++) {
+		dxp = &vq->vq_descx[i];
+
+		dxp->indirect = malloc(size, M_DEVBUF, M_NOWAIT);
+		if (dxp->indirect == NULL) {
+			device_printf(dev, "cannot allocate indirect list\n");
+			return (ENOMEM);
+		}
+
+		dxp->indirect_paddr = vtophys(dxp->indirect);
+		virtqueue_init_indirect_list(vq, dxp->indirect);
+	}
+
+	return (0);
+}
+
+static void
+virtqueue_free_indirect(struct virtqueue *vq)
+{
+	struct vq_desc_extra *dxp;
+	int i;
+
+	for (i = 0; i < vq->vq_nentries; i++) {
+		dxp = &vq->vq_descx[i];
+
+		if (dxp->indirect == NULL)
+			break;
+
+		free(dxp->indirect, M_DEVBUF);
+		dxp->indirect = NULL;
+		dxp->indirect_paddr = 0;
+	}
+
+	vq->vq_flags &= ~VIRTQUEUE_FLAG_INDIRECT;
+	vq->vq_indirect_mem_size = 0;
+}
+
+static void
+virtqueue_init_indirect_list(struct virtqueue *vq,
+    struct vring_desc *indirect)
+{
+	int i;
+
+	bzero(indirect, vq->vq_indirect_mem_size);
+
+	for (i = 0; i < vq->vq_max_indirect_size - 1; i++)
+		indirect[i].next = i + 1;
+	indirect[i].next = VQ_RING_DESC_CHAIN_END;
+}
+
+int
+virtqueue_reinit(struct virtqueue *vq, uint16_t size)
+{
+	struct vq_desc_extra *dxp;
+	int i;
+
+	if (vq->vq_nentries != size) {
+		device_printf(vq->vq_dev,
+		    "%s: '%s' changed size; old=%hu, new=%hu\n",
+		    __func__, vq->vq_name, vq->vq_nentries, size);
+		return (EINVAL);
+	}
+
+	/* Warn if the virtqueue was not properly cleaned up. */
+	if (vq->vq_free_cnt != vq->vq_nentries) {
+		device_printf(vq->vq_dev,
+		    "%s: warning '%s' virtqueue not empty, "
+		    "leaking %d entries\n", __func__, vq->vq_name,
+		    vq->vq_nentries - vq->vq_free_cnt);
+	}
+
+	vq->vq_desc_head_idx = 0;
+	vq->vq_used_cons_idx = 0;
+	vq->vq_queued_cnt = 0;
+	vq->vq_free_cnt = vq->vq_nentries;
+
+	/* To be safe, reset all our allocated memory. */
+	bzero(vq->vq_ring_mem, vq->vq_ring_size);
+	for (i = 0; i < vq->vq_nentries; i++) {
+		dxp = &vq->vq_descx[i];
+		dxp->cookie = NULL;
+		dxp->ndescs = 0;
+		if (vq->vq_flags & VIRTQUEUE_FLAG_INDIRECT)
+			virtqueue_init_indirect_list(vq, dxp->indirect);
+	}
+
+	vq_ring_init(vq);
+	virtqueue_disable_intr(vq);
+
+	return (0);
+}
+
+void
+virtqueue_free(struct virtqueue *vq)
+{
+
+	if (vq->vq_free_cnt != vq->vq_nentries) {
+		device_printf(vq->vq_dev, "%s: freeing non-empty virtqueue, "
+		    "leaking %d entries\n", vq->vq_name,
+		    vq->vq_nentries - vq->vq_free_cnt);
+	}
+
+	if (vq->vq_flags & VIRTQUEUE_FLAG_INDIRECT)
+		virtqueue_free_indirect(vq);
+
+	if (vq->vq_ring_mem != NULL) {
+		contigfree(vq->vq_ring_mem, vq->vq_ring_size, M_DEVBUF);
+		vq->vq_ring_size = 0;
+		vq->vq_ring_mem = NULL;
+	}
+
+	free(vq, M_DEVBUF);
+}
+
+vm_paddr_t
+virtqueue_paddr(struct virtqueue *vq)
+{
+
+	return (vtophys(vq->vq_ring_mem));
+}
+
+int
+virtqueue_size(struct virtqueue *vq)
+{
+
+	return (vq->vq_nentries);
+}
+
+int
+virtqueue_empty(struct virtqueue *vq)
+{
+
+	return (vq->vq_nentries == vq->vq_free_cnt);
+}
+
+int
+virtqueue_full(struct virtqueue *vq)
+{
+
+	return (vq->vq_free_cnt == 0);
+}
+
+void
+virtqueue_notify(struct virtqueue *vq)
+{
+
+	/* Ensure updated avail->idx is visible to host. */
+	mb();
+
+	if (vq_ring_must_notify_host(vq))
+		vq_ring_notify_host(vq);
+	vq->vq_queued_cnt = 0;
+}
+
+int
+virtqueue_nused(struct virtqueue *vq)
+{
+	uint16_t used_idx, nused;
+
+	used_idx = vq->vq_ring.used->idx;
+
+	nused = (uint16_t)(used_idx - vq->vq_used_cons_idx);
+	VQASSERT(vq, nused <= vq->vq_nentries, "used more than available");
+
+	return (nused);
+}
+
+int
+virtqueue_intr(struct virtqueue *vq)
+{
+
+	if (vq->vq_intrhand == NULL ||
+	    vq->vq_used_cons_idx == vq->vq_ring.used->idx)
+		return (0);
+
+	vq->vq_intrhand(vq->vq_intrhand_arg);
+
+	return (1);
+}
+
+int
+virtqueue_enable_intr(struct virtqueue *vq)
+{
+
+	return (vq_ring_enable_interrupt(vq, 0));
+}
+
+int
+virtqueue_postpone_intr(struct virtqueue *vq)
+{
+	uint16_t ndesc, avail_idx;
+
+	/*
+	 * Request the next interrupt be postponed until at least half
+	 * of the available descriptors have been consumed.
+	 */
+	avail_idx = vq->vq_ring.avail->idx;
+	ndesc = (uint16_t)(avail_idx - vq->vq_used_cons_idx) / 2;
+
+	return (vq_ring_enable_interrupt(vq, ndesc));
+}
+
+void
+virtqueue_disable_intr(struct virtqueue *vq)
+{
+
+	/*
+	 * Note this is only considered a hint to the host.
+	 */
+	if ((vq->vq_flags & VIRTQUEUE_FLAG_EVENT_IDX) == 0)
+		vq->vq_ring.avail->flags |= VRING_AVAIL_F_NO_INTERRUPT;
+}
+
+int
+virtqueue_enqueue(struct virtqueue *vq, void *cookie, struct sglist *sg,
+    int readable, int writable)
+{
+	struct vq_desc_extra *dxp;
+	int needed;
+	uint16_t head_idx, idx;
+
+	needed = readable + writable;
+
+	VQASSERT(vq, cookie != NULL, "enqueuing with no cookie");
+	VQASSERT(vq, needed == sg->sg_nseg,
+	    "segment count mismatch, %d, %d", needed, sg->sg_nseg);
+	VQASSERT(vq,
+	    needed <= vq->vq_nentries || needed <= vq->vq_max_indirect_size,
+	    "too many segments to enqueue: %d, %d/%d", needed,
+	    vq->vq_nentries, vq->vq_max_indirect_size);
+
+	if (needed < 1)
+		return (EINVAL);
+	if (vq->vq_free_cnt == 0)
+		return (ENOSPC);
+
+	if (vq_ring_use_indirect(vq, needed)) {
+		vq_ring_enqueue_indirect(vq, cookie, sg, readable, writable);
+		return (0);
+	} else if (vq->vq_free_cnt < needed)
+		return (EMSGSIZE);
+
+	head_idx = vq->vq_desc_head_idx;
+	VQ_RING_ASSERT_VALID_IDX(vq, head_idx);
+	dxp = &vq->vq_descx[head_idx];
+
+	VQASSERT(vq, dxp->cookie == NULL,
+	    "cookie already exists for index %d", head_idx);
+	dxp->cookie = cookie;
+	dxp->ndescs = needed;
+
+	idx = vq_ring_enqueue_segments(vq, vq->vq_ring.desc, head_idx,
+	    sg, readable, writable);
+
+	vq->vq_desc_head_idx = idx;
+	vq->vq_free_cnt -= needed;
+	if (vq->vq_free_cnt == 0)
+		VQ_RING_ASSERT_CHAIN_TERM(vq);
+	else
+		VQ_RING_ASSERT_VALID_IDX(vq, idx);
+
+	vq_ring_update_avail(vq, head_idx);
+
+	return (0);
+}
+
+void *
+virtqueue_dequeue(struct virtqueue *vq, uint32_t *len)
+{
+	struct vring_used_elem *uep;
+	void *cookie;
+	uint16_t used_idx, desc_idx;
+
+	if (vq->vq_used_cons_idx == vq->vq_ring.used->idx)
+		return (NULL);
+
+	used_idx = vq->vq_used_cons_idx++ & (vq->vq_nentries - 1);
+	uep = &vq->vq_ring.used->ring[used_idx];
+
+	mb();
+	desc_idx = (uint16_t) uep->id;
+	if (len != NULL)
+		*len = uep->len;
+
+	vq_ring_free_chain(vq, desc_idx);
+
+	cookie = vq->vq_descx[desc_idx].cookie;
+	VQASSERT(vq, cookie != NULL, "no cookie for index %d", desc_idx);
+	vq->vq_descx[desc_idx].cookie = NULL;
+
+	return (cookie);
+}
+
+void *
+virtqueue_poll(struct virtqueue *vq, uint32_t *len)
+{
+	void *cookie;
+
+	while ((cookie = virtqueue_dequeue(vq, len)) == NULL)
+		cpu_spinwait();
+
+	return (cookie);
+}
+
+void *
+virtqueue_drain(struct virtqueue *vq, int *last)
+{
+	void *cookie;
+	int idx;
+
+	cookie = NULL;
+	idx = *last;
+
+	while (idx < vq->vq_nentries && cookie == NULL) {
+		if ((cookie = vq->vq_descx[idx].cookie) != NULL) {
+			vq->vq_descx[idx].cookie = NULL;
+			/* Free chain to keep free count consistent. */
+			vq_ring_free_chain(vq, idx);
+		}
+		idx++;
+	}
+
+	*last = idx;
+
+	return (cookie);
+}
+
+void
+virtqueue_dump(struct virtqueue *vq)
+{
+
+	if (vq == NULL)
+		return;
+
+	printf("VQ: %s - size=%d; free=%d; used=%d; queued=%d; "
+	    "desc_head_idx=%d; avail.idx=%d; used_cons_idx=%d; "
+	    "used.idx=%d; avail.flags=0x%x; used.flags=0x%x\n",
+	    vq->vq_name, vq->vq_nentries, vq->vq_free_cnt,
+	    virtqueue_nused(vq), vq->vq_queued_cnt, vq->vq_desc_head_idx,
+	    vq->vq_ring.avail->idx, vq->vq_used_cons_idx,
+	    vq->vq_ring.used->idx, vq->vq_ring.avail->flags,
+	    vq->vq_ring.used->flags);
+}
+
+static void
+vq_ring_init(struct virtqueue *vq)
+{
+	struct vring *vr;
+	char *ring_mem;
+	int i, size;
+
+	ring_mem = vq->vq_ring_mem;
+	size = vq->vq_nentries;
+	vr = &vq->vq_ring;
+
+	vring_init(vr, size, ring_mem, vq->vq_alignment);
+
+	for (i = 0; i < size - 1; i++)
+		vr->desc[i].next = i + 1;
+	vr->desc[i].next = VQ_RING_DESC_CHAIN_END;
+}
+
+static void
+vq_ring_update_avail(struct virtqueue *vq, uint16_t desc_idx)
+{
+	uint16_t avail_idx;
+
+	/*
+	 * Place the head of the descriptor chain into the next slot and make
+	 * it usable to the host. The chain is made available now rather than
+	 * deferring to virtqueue_notify() in the hopes that if the host is
+	 * currently running on another CPU, we can keep it processing the new
+	 * descriptor.
+	 */
+	avail_idx = vq->vq_ring.avail->idx & (vq->vq_nentries - 1);
+	vq->vq_ring.avail->ring[avail_idx] = desc_idx;
+
+	mb();
+	vq->vq_ring.avail->idx++;
+
+	/* Keep pending count until virtqueue_notify(). */
+	vq->vq_queued_cnt++;
+}
+
+static uint16_t
+vq_ring_enqueue_segments(struct virtqueue *vq, struct vring_desc *desc,
+    uint16_t head_idx, struct sglist *sg, int readable, int writable)
+{
+	struct sglist_seg *seg;
+	struct vring_desc *dp;
+	int i, needed;
+	uint16_t idx;
+
+	needed = readable + writable;
+
+	for (i = 0, idx = head_idx, seg = sg->sg_segs;
+	     i < needed;
+	     i++, idx = dp->next, seg++) {
+		VQASSERT(vq, idx != VQ_RING_DESC_CHAIN_END,
+		    "premature end of free desc chain");
+
+		dp = &desc[idx];
+		dp->addr = seg->ss_paddr;
+		dp->len = seg->ss_len;
+		dp->flags = 0;
+
+		if (i < needed - 1)
+			dp->flags |= VRING_DESC_F_NEXT;
+		if (i >= readable)
+			dp->flags |= VRING_DESC_F_WRITE;
+	}
+
+	return (idx);
+}
+
+static int
+vq_ring_use_indirect(struct virtqueue *vq, int needed)
+{
+
+	if ((vq->vq_flags & VIRTQUEUE_FLAG_INDIRECT) == 0)
+		return (0);
+
+	if (vq->vq_max_indirect_size < needed)
+		return (0);
+
+	if (needed < 2)
+		return (0);
+
+	return (1);
+}
+
+static void
+vq_ring_enqueue_indirect(struct virtqueue *vq, void *cookie,
+    struct sglist *sg, int readable, int writable)
+{
+	struct vring_desc *dp;
+	struct vq_desc_extra *dxp;
+	int needed;
+	uint16_t head_idx;
+
+	needed = readable + writable;
+	VQASSERT(vq, needed <= vq->vq_max_indirect_size,
+	    "enqueuing too many indirect descriptors");
+
+	head_idx = vq->vq_desc_head_idx;
+	VQ_RING_ASSERT_VALID_IDX(vq, head_idx);
+	dp = &vq->vq_ring.desc[head_idx];
+	dxp = &vq->vq_descx[head_idx];
+
+	VQASSERT(vq, dxp->cookie == NULL,
+	    "cookie already exists for index %d", head_idx);
+	dxp->cookie = cookie;
+	dxp->ndescs = 1;
+
+	dp->addr = dxp->indirect_paddr;
+	dp->len = needed * sizeof(struct vring_desc);
+	dp->flags = VRING_DESC_F_INDIRECT;
+
+	vq_ring_enqueue_segments(vq, dxp->indirect, 0,
+	    sg, readable, writable);
+
+	vq->vq_desc_head_idx = dp->next;
+	vq->vq_free_cnt--;
+	if (vq->vq_free_cnt == 0)
+		VQ_RING_ASSERT_CHAIN_TERM(vq);
+	else
+		VQ_RING_ASSERT_VALID_IDX(vq, vq->vq_desc_head_idx);
+
+	vq_ring_update_avail(vq, head_idx);
+}
+
+static int
+vq_ring_enable_interrupt(struct virtqueue *vq, uint16_t ndesc)
+{
+
+	/*
+	 * Enable interrupts, making sure we get the latest index of
+	 * what's already been consumed.
+	 */
+	if (vq->vq_flags & VIRTQUEUE_FLAG_EVENT_IDX)
+		vring_used_event(&vq->vq_ring) = vq->vq_used_cons_idx + ndesc;
+	else
+		vq->vq_ring.avail->flags &= ~VRING_AVAIL_F_NO_INTERRUPT;
+
+	mb();
+
+	/*
+	 * Enough items may have already been consumed to meet our threshold
+	 * since we last checked. Let our caller know so it processes the new
+	 * entries.
+	 */
+	if (virtqueue_nused(vq) > ndesc)
+		return (1);
+
+	return (0);
+}
+
+static int
+vq_ring_must_notify_host(struct virtqueue *vq)
+{
+	uint16_t new_idx, prev_idx, event_idx;
+
+	if (vq->vq_flags & VIRTQUEUE_FLAG_EVENT_IDX) {
+		new_idx = vq->vq_ring.avail->idx;
+		prev_idx = new_idx - vq->vq_queued_cnt;
+		event_idx = vring_avail_event(&vq->vq_ring);
+
+		return (vring_need_event(event_idx, new_idx, prev_idx) != 0);
+	}
+
+	return ((vq->vq_ring.used->flags & VRING_USED_F_NO_NOTIFY) == 0);
+}
+
+static void
+vq_ring_notify_host(struct virtqueue *vq)
+{
+
+	VIRTIO_BUS_NOTIFY_VQ(vq->vq_dev, vq->vq_queue_index);
+}
+
+static void
+vq_ring_free_chain(struct virtqueue *vq, uint16_t desc_idx)
+{
+	struct vring_desc *dp;
+	struct vq_desc_extra *dxp;
+
+	VQ_RING_ASSERT_VALID_IDX(vq, desc_idx);
+	dp = &vq->vq_ring.desc[desc_idx];
+	dxp = &vq->vq_descx[desc_idx];
+
+	if (vq->vq_free_cnt == 0)
+		VQ_RING_ASSERT_CHAIN_TERM(vq);
+
+	vq->vq_free_cnt += dxp->ndescs;
+	dxp->ndescs--;
+
+	if ((dp->flags & VRING_DESC_F_INDIRECT) == 0) {
+		while (dp->flags & VRING_DESC_F_NEXT) {
+			VQ_RING_ASSERT_VALID_IDX(vq, dp->next);
+			dp = &vq->vq_ring.desc[dp->next];
+			dxp->ndescs--;
+		}
+	}
+
+	VQASSERT(vq, dxp->ndescs == 0,
+	    "failed to free entire desc chain, remaining: %d", dxp->ndescs);
+
+	/*
+	 * We must append the existing free chain, if any, to the end of
+	 * newly freed chain. If the virtqueue was completely used, then
+	 * head would be VQ_RING_DESC_CHAIN_END (ASSERTed above).
+	 */
+	dp->next = vq->vq_desc_head_idx;
+	vq->vq_desc_head_idx = desc_idx;
+}
diff --git a/sys/dev/virtio/virtqueue.h b/sys/dev/virtio/virtqueue.h
new file mode 100644
index 0000000..0296b8c
--- /dev/null
+++ b/sys/dev/virtio/virtqueue.h
@@ -0,0 +1,93 @@
+/*-
+ * Copyright (c) 2011, Bryan Venteicher <bryanv@daemoninthecloset.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice unmodified, this list of conditions, and the following
+ *    disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+
+#ifndef _VIRTIO_VIRTQUEUE_H
+#define _VIRTIO_VIRTQUEUE_H
+
+struct virtqueue;
+struct sglist;
+
+/* Support for indirect buffer descriptors. */
+#define VIRTIO_RING_F_INDIRECT_DESC	(1 << 28)
+
+/* Support to suppress interrupt until specific index is reached. */
+#define VIRTIO_RING_F_EVENT_IDX		(1 << 29)
+
+/* Device callback for a virtqueue interrupt. */
+typedef int virtqueue_intr_t(void *);
+
+#define VIRTQUEUE_MAX_NAME_SZ	32
+
+/* One for each virtqueue the device wishes to allocate. */
+struct vq_alloc_info {
+	char		   vqai_name[VIRTQUEUE_MAX_NAME_SZ];
+	int		   vqai_maxindirsz;
+	virtqueue_intr_t  *vqai_intr;
+	void		  *vqai_intr_arg;
+	struct virtqueue **vqai_vq;
+};
+
+#define VQ_ALLOC_INFO_INIT(_i,_nsegs,_intr,_arg,_vqp,_str,...) do {	\
+	snprintf((_i)->vqai_name, VIRTQUEUE_MAX_NAME_SZ, _str,		\
+	    ##__VA_ARGS__);						\
+	(_i)->vqai_maxindirsz = (_nsegs);				\
+	(_i)->vqai_intr = (_intr);					\
+	(_i)->vqai_intr_arg = (_arg);					\
+	(_i)->vqai_vq = (_vqp);						\
+} while (0)
+
+uint64_t virtqueue_filter_features(uint64_t features);
+
+int	 virtqueue_alloc(device_t dev, uint16_t queue, uint16_t size,
+	     int align, vm_paddr_t highaddr, struct vq_alloc_info *info,
+	     struct virtqueue **vqp);
+void	*virtqueue_drain(struct virtqueue *vq, int *last);
+void	 virtqueue_free(struct virtqueue *vq);
+int	 virtqueue_reinit(struct virtqueue *vq, uint16_t size);
+
+int	 virtqueue_intr(struct virtqueue *vq);
+int	 virtqueue_enable_intr(struct virtqueue *vq);
+int	 virtqueue_postpone_intr(struct virtqueue *vq);
+void	 virtqueue_disable_intr(struct virtqueue *vq);
+
+/* Get physical address of the virtqueue ring. */
+vm_paddr_t virtqueue_paddr(struct virtqueue *vq);
+
+int	 virtqueue_full(struct virtqueue *vq);
+int	 virtqueue_empty(struct virtqueue *vq);
+int	 virtqueue_size(struct virtqueue *vq);
+int	 virtqueue_nused(struct virtqueue *vq);
+void	 virtqueue_notify(struct virtqueue *vq);
+void	 virtqueue_dump(struct virtqueue *vq);
+
+int	 virtqueue_enqueue(struct virtqueue *vq, void *cookie,
+	     struct sglist *sg, int readable, int writable);
+void	*virtqueue_dequeue(struct virtqueue *vq, uint32_t *len);
+void	*virtqueue_poll(struct virtqueue *vq, uint32_t *len);
+
+#endif /* _VIRTIO_VIRTQUEUE_H */
diff --git a/sys/modules/Makefile b/sys/modules/Makefile
index d61f785..d3e22af 100644
--- a/sys/modules/Makefile
+++ b/sys/modules/Makefile
@@ -308,6 +308,7 @@ SUBDIR=	${_3dfx} \
 	usb \
 	utopia \
 	${_vesa} \
+	${_virtio} \
 	vge \
 	${_viawd} \
 	vkbd \
@@ -518,6 +519,7 @@ _padlock=	padlock
 _s3=		s3
 _twa=		twa
 _vesa=		vesa
+_virtio=	virtio
 _x86bios=	x86bios
 .elif ${MACHINE} == "pc98"
 _canbepm=	canbepm
@@ -612,6 +614,7 @@ _tpm=		tpm
 _twa=		twa
 _vesa=		vesa
 _viawd=		viawd
+_virtio=	virtio
 _x86bios=	x86bios
 _wi=		wi
 _wpi=		wpi
diff --git a/sys/modules/virtio/Makefile b/sys/modules/virtio/Makefile
new file mode 100644
index 0000000..12846b2
--- /dev/null
+++ b/sys/modules/virtio/Makefile
@@ -0,0 +1,28 @@
+#
+# $FreeBSD$
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in the
+#    documentation and/or other materials provided with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+# SUCH DAMAGE.
+#
+
+SUBDIR=	virtio pci network block balloon scsi
+
+.include <bsd.subdir.mk>
diff --git a/sys/modules/virtio/balloon/Makefile b/sys/modules/virtio/balloon/Makefile
new file mode 100644
index 0000000..dc14cbc
--- /dev/null
+++ b/sys/modules/virtio/balloon/Makefile
@@ -0,0 +1,36 @@
+#
+# $FreeBSD$
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in the
+#    documentation and/or other materials provided with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+# SUCH DAMAGE.
+#
+
+.PATH: ${.CURDIR}/../../../dev/virtio/balloon
+
+KMOD=	virtio_balloon
+SRCS=	virtio_balloon.c
+SRCS+=	virtio_bus_if.h virtio_if.h
+SRCS+=	bus_if.h device_if.h 
+
+MFILES=	kern/bus_if.m kern/device_if.m \
+	dev/virtio/virtio_bus_if.m dev/virtio/virtio_if.m
+
+.include <bsd.kmod.mk>
diff --git a/sys/modules/virtio/block/Makefile b/sys/modules/virtio/block/Makefile
new file mode 100644
index 0000000..5df9eab
--- /dev/null
+++ b/sys/modules/virtio/block/Makefile
@@ -0,0 +1,36 @@
+#
+# $FreeBSD$
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in the
+#    documentation and/or other materials provided with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+# SUCH DAMAGE.
+#
+
+.PATH: ${.CURDIR}/../../../dev/virtio/block
+
+KMOD=	virtio_blk
+SRCS=	virtio_blk.c
+SRCS+=	virtio_bus_if.h virtio_if.h
+SRCS+=	bus_if.h device_if.h 
+
+MFILES=	kern/bus_if.m kern/device_if.m \
+	dev/virtio/virtio_bus_if.m dev/virtio/virtio_if.m
+
+.include <bsd.kmod.mk>
diff --git a/sys/modules/virtio/network/Makefile b/sys/modules/virtio/network/Makefile
new file mode 100644
index 0000000..8463309c
--- /dev/null
+++ b/sys/modules/virtio/network/Makefile
@@ -0,0 +1,36 @@
+#
+# $FreeBSD$
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in the
+#    documentation and/or other materials provided with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+# SUCH DAMAGE.
+#
+
+.PATH: ${.CURDIR}/../../../dev/virtio/network
+
+KMOD=	if_vtnet
+SRCS=	if_vtnet.c
+SRCS+=	virtio_bus_if.h virtio_if.h
+SRCS+=	bus_if.h device_if.h 
+
+MFILES=	kern/bus_if.m kern/device_if.m \
+	dev/virtio/virtio_bus_if.m dev/virtio/virtio_if.m
+
+.include <bsd.kmod.mk>
diff --git a/sys/modules/virtio/pci/Makefile b/sys/modules/virtio/pci/Makefile
new file mode 100644
index 0000000..a58d64c
--- /dev/null
+++ b/sys/modules/virtio/pci/Makefile
@@ -0,0 +1,36 @@
+#
+# $FreeBSD$
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in the
+#    documentation and/or other materials provided with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+# SUCH DAMAGE.
+#
+
+.PATH: ${.CURDIR}/../../../dev/virtio/pci
+
+KMOD=	virtio_pci
+SRCS=	virtio_pci.c
+SRCS+=	virtio_bus_if.h virtio_if.h 
+SRCS+=	bus_if.h device_if.h pci_if.h
+
+MFILES=	kern/bus_if.m kern/device_if.m dev/pci/pci_if.m \
+	dev/virtio/virtio_bus_if.m dev/virtio/virtio_if.m
+
+.include <bsd.kmod.mk>
diff --git a/sys/modules/virtio/scsi/Makefile b/sys/modules/virtio/scsi/Makefile
new file mode 100644
index 0000000..640912f
--- /dev/null
+++ b/sys/modules/virtio/scsi/Makefile
@@ -0,0 +1,36 @@
+#
+# $FreeBSD$
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in the
+#    documentation and/or other materials provided with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+# SUCH DAMAGE.
+#
+
+.PATH: ${.CURDIR}/../../../dev/virtio/scsi
+
+KMOD=	virtio_scsi
+SRCS=	virtio_scsi.c
+SRCS+=	virtio_bus_if.h virtio_if.h
+SRCS+=	bus_if.h device_if.h opt_scsi.h opt_cam.h
+
+MFILES=	kern/bus_if.m kern/device_if.m \
+	dev/virtio/virtio_bus_if.m dev/virtio/virtio_if.m
+
+.include <bsd.kmod.mk>
diff --git a/sys/modules/virtio/virtio/Makefile b/sys/modules/virtio/virtio/Makefile
new file mode 100644
index 0000000..e8973c0
--- /dev/null
+++ b/sys/modules/virtio/virtio/Makefile
@@ -0,0 +1,38 @@
+#
+# $FreeBSD$
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in the
+#    documentation and/or other materials provided with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+# SUCH DAMAGE.
+#
+
+.PATH: ${.CURDIR}/../../../dev/virtio
+
+KMOD=	virtio
+
+SRCS=	virtio.c virtqueue.c
+SRCS+=	virtio_bus_if.c virtio_bus_if.h
+SRCS+=	virtio_if.c virtio_if.h
+SRCS+=	bus_if.h device_if.h 
+
+MFILES=	kern/bus_if.m kern/device_if.m \
+	dev/virtio/virtio_bus_if.m dev/virtio/virtio_if.m
+
+.include <bsd.kmod.mk>

diff --git a/sys/net/if_tun.c b/sys/net/if_tun.c
index 1c49868..88e6db6 100644
--- a/sys/net/if_tun.c
+++ b/sys/net/if_tun.c
@@ -327,31 +327,22 @@ static void
 tunstart(struct ifnet *ifp)
 {
 	struct tun_softc *tp = ifp->if_softc;
-	struct mbuf *m;
 
 	TUNDEBUG(ifp,"%s starting\n", ifp->if_xname);
-	if (ALTQ_IS_ENABLED(&ifp->if_snd)) {
-		IFQ_LOCK(&ifp->if_snd);
-		IFQ_POLL_NOLOCK(&ifp->if_snd, m);
-		if (m == NULL) {
-			IFQ_UNLOCK(&ifp->if_snd);
-			return;
-		}
-		IFQ_UNLOCK(&ifp->if_snd);
-	}
+	if (IFQ_IS_EMPTY(&ifp->if_snd))
+		return;
 
-	mtx_lock(&tp->tun_mtx);
-	if (tp->tun_flags & TUN_RWAIT) {
-		tp->tun_flags &= ~TUN_RWAIT;
+	if (tp->tun_flags & TUN_RWAIT)
 		wakeup(tp);
-	}
-	selwakeuppri(&tp->tun_rsel, PZERO + 1);
-	KNOTE_LOCKED(&tp->tun_rsel.si_note, 0);
-	if (tp->tun_flags & TUN_ASYNC && tp->tun_sigio) {
+	if (!TAILQ_EMPTY(&tp->run_rsel.si_tdlist))
+		selwakeuppri(&tp->tun_rsel, PZERO + 1);
+	if (!KNLIST_EMPTY(&tp->tun_rsel.si_note)) {
+		mtx_lock(&tp->tun_mtx);
+		KNOTE_LOCKED(&tp->tun_rsel.si_note, 0);
 		mtx_unlock(&tp->tun_mtx);
+	}
+	if (tp->tun_flags & TUN_ASYNC && tp->tun_sigio)
 		pgsigio(&tp->tun_sigio, SIGIO, 0);
-	} else
-		mtx_unlock(&tp->tun_mtx);
 }
 
 /* XXX: should return an error code so it can fail. */
@@ -595,9 +586,7 @@ tunoutput(struct ifnet *ifp, struct mbuf *m0, struct sockaddr *dst,
 #endif
 
 	/* Could be unlocked read? */
-	mtx_lock(&tp->tun_mtx);
 	cached_tun_flags = tp->tun_flags;
-	mtx_unlock(&tp->tun_mtx);
 	if ((cached_tun_flags & TUN_READY) != TUN_READY) {
 		TUNDEBUG (ifp, "not ready 0%o\n", tp->tun_flags);
 		m_freem (m0);
@@ -806,13 +795,12 @@ tunread(struct cdev *dev, struct uio *uio, int flag)
 	int		error=0, len;
 
 	TUNDEBUG (ifp, "read\n");
-	mtx_lock(&tp->tun_mtx);
 	if ((tp->tun_flags & TUN_READY) != TUN_READY) {
-		mtx_unlock(&tp->tun_mtx);
 		TUNDEBUG (ifp, "not ready 0%o\n", tp->tun_flags);
 		return (EHOSTDOWN);
 	}
 
+	mtx_lock(&tp->tun_mtx);
 	tp->tun_flags &= ~TUN_RWAIT;
 
 	do {
@@ -825,6 +813,7 @@ tunread(struct cdev *dev, struct uio *uio, int flag)
 			tp->tun_flags |= TUN_RWAIT;
 			error = mtx_sleep(tp, &tp->tun_mtx, PCATCH | (PZERO + 1),
 			    "tunread", 0);
+			tp->tun_flags &= ~TUN_RWAIT;
 			if (error != 0) {
 				mtx_unlock(&tp->tun_mtx);
 				return (error);
@@ -883,17 +872,14 @@ tunwrite(struct cdev *dev, struct uio *uio, int flag)
 	mac_ifnet_create_mbuf(ifp, m);
 #endif
 
-	/* Could be unlocked read? */
-	mtx_lock(&tp->tun_mtx);
+	/* XXX: unlocked read? */
 	if (tp->tun_flags & TUN_IFHEAD) {
-		mtx_unlock(&tp->tun_mtx);
 		if (m->m_len < sizeof(family) &&
 		    (m = m_pullup(m, sizeof(family))) == NULL)
 			return (ENOBUFS);
 		family = ntohl(*mtod(m, u_int32_t *));
 		m_adj(m, sizeof(family));
 	} else {
-		mtx_unlock(&tp->tun_mtx);
 		family = AF_INET;
 	}
 
@@ -947,21 +933,17 @@ tunpoll(struct cdev *dev, int events, struct thread *td)
 	struct tun_softc *tp = dev->si_drv1;
 	struct ifnet	*ifp = TUN2IFP(tp);
 	int		revents = 0;
-	struct mbuf	*m;
 
 	TUNDEBUG(ifp, "tunpoll\n");
 
 	if (events & (POLLIN | POLLRDNORM)) {
-		IFQ_LOCK(&ifp->if_snd);
-		IFQ_POLL_NOLOCK(&ifp->if_snd, m);
-		if (m != NULL) {
-			TUNDEBUG(ifp, "tunpoll q=%d\n", ifp->if_snd.ifq_len);
-			revents |= events & (POLLIN | POLLRDNORM);
-		} else {
+		if (IFQ_IS_EMPTY(&ifp->if_snd)) {
 			TUNDEBUG(ifp, "tunpoll waiting\n");
 			selrecord(td, &tp->tun_rsel);
+		} else {
+			TUNDEBUG(ifp, "tunpoll q=%d\n", ifp->if_snd.ifq_len);
+			revents |= events & (POLLIN | POLLRDNORM);
 		}
-		IFQ_UNLOCK(&ifp->if_snd);
 	}
 	if (events & (POLLOUT | POLLWRNORM))
 		revents |= events & (POLLOUT | POLLWRNORM);
